Disassembly Listing for BFPowerPIC-Test
Generated From:
D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/dist/default/production/BFPowerPIC-WORKING.X.production.elf
Feb 4, 2017 1:31:38 PM

---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/SharedCommunication.c
1:                 /* File:    SharedCommunication.c
2:                  * Authors: Dan Baker
3:                  *          Nathan Chaney
4:                  */
5:                 
6:                 /* Ensure that SharedCommunication.c is excluded from the source build path!
7:                  * SharedCommunication.c must be included LAST in your main source file
8:                  * like this to ensure the compiler builds the correct version:
9:                  *    #define COMM_INCLUDED
10:                 *    #include "../Shared/SharedCommunication.c"
11:                 */
12:                
13:                
14:                /* Includes *******************************************************************/
15:                
16:                #ifndef COMM_INCLUDED
17:                #error Please add #define COMM_INCLUDED and #include "../Shared/SharedCommunication.c" to your main source and exclude SharedCommunication.c from the source build path.
18:                #endif
19:                
20:                #include <xc.h>
21:                #include <stdlib.h>
22:                
23:                #include "ExternSharedDefinitions.h"
24:                
25:                #ifdef POWER_BOX
26:                void commInit(void) {
000430  FA0000     LNK #0x0
27:                
28:                    sendIndexU1 = receiveIndexU1 = 0;
000432  EB0200     CLR W4
000434  885854     MOV W4, receiveIndexU1
000436  805854     MOV receiveIndexU1, W4
000438  885844     MOV W4, sendIndexU1
29:                    newSendDataU1 = 0;
00043A  EB4200     CLR.B W4
00043C  780004     MOV W4, W0
00043E  B7EB07     MOV.B WREG, newSendDataU1
30:                
31:                    sendIndexU2 = receiveIndexU2 = 0;
000440  EB0200     CLR W4
000442  8855A4     MOV W4, receiveIndexU2
000444  8055A4     MOV receiveIndexU2, W4
000446  885594     MOV W4, sendIndexU2
32:                    newSendDataU2 = 0;
000448  EB4200     CLR.B W4
00044A  780004     MOV W4, W0
00044C  B7EAB0     MOV.B WREG, newSendDataU2
33:                    newSendData = 0;
00044E  EB4200     CLR.B W4
000450  780004     MOV W4, W0
000452  B7EA8F     MOV.B WREG, newSendData
34:                
35:                    sendBuffer1Used = sendBuffer2Used = sendBuffer3Used =
000466  780004     MOV W4, W0
000468  B7EA86     MOV.B WREG, sendBuffer3Used
00046A  20A864     MOV #0xA86, W4
00046C  784214     MOV.B [W4], W4
00046E  780004     MOV W4, W0
000470  B7EA85     MOV.B WREG, sendBuffer2Used
000472  20A854     MOV #0xA85, W4
000474  784214     MOV.B [W4], W4
000476  780004     MOV W4, W0
000478  B7EA84     MOV.B WREG, sendBuffer1Used
36:                            sendBuffer4Used = sendBuffer5Used = 0;
000454  EB4200     CLR.B W4
000456  780004     MOV W4, W0
000458  B7EA88     MOV.B WREG, sendBuffer5Used
00045A  20A884     MOV #0xA88, W4
00045C  784214     MOV.B [W4], W4
00045E  780004     MOV W4, W0
000460  B7EA87     MOV.B WREG, sendBuffer4Used
000462  20A874     MOV #0xA87, W4
000464  784214     MOV.B [W4], W4
37:                
38:                    receiveBuffer1Used = receiveBuffer2Used = receiveBuffer3Used =
00048C  780004     MOV W4, W0
00048E  B7EA8B     MOV.B WREG, receiveBuffer3Used
000490  20A8B4     MOV #0xA8B, W4
000492  784214     MOV.B [W4], W4
000494  780004     MOV W4, W0
000496  B7EA8A     MOV.B WREG, receiveBuffer2Used
000498  20A8A4     MOV #0xA8A, W4
00049A  784214     MOV.B [W4], W4
00049C  780004     MOV W4, W0
00049E  B7EA89     MOV.B WREG, receiveBuffer1Used
39:                            receiveBuffer4Used = receiveBuffer5Used = 0;
00047A  EB4200     CLR.B W4
00047C  780004     MOV W4, W0
00047E  B7EA8D     MOV.B WREG, receiveBuffer5Used
000480  20A8D4     MOV #0xA8D, W4
000482  784214     MOV.B [W4], W4
000484  780004     MOV W4, W0
000486  B7EA8C     MOV.B WREG, receiveBuffer4Used
000488  20A8C4     MOV #0xA8C, W4
00048A  784214     MOV.B [W4], W4
40:                
41:                }
0004A0  FA8000     ULNK
42:                #endif
43:                
44:                void commFunctions(void) {
0004A4  FA0000     LNK #0x0
45:                    splitReceivedCommand();
0004A6  070003     RCALL splitReceivedCommand
46:                    sendCommands();
0004A8  070168     RCALL sendCommands
47:                }
0004AA  FA8000     ULNK
48:                
49:                void splitReceivedCommand(void) {
0004AE  FA0006     LNK #0x6
50:                
51:                    // promote buffers if there is data in one or more of them
52:                    while (newReceiveData == 0 && (receiveBuffer1Used || receiveBuffer2Used ||
0004B0  370069     BRA 0x584
000584  20A904     MOV #0xA90, W4
000586  784214     MOV.B [W4], W4
000588  524FE0     SUB.B W4, #0x0, [W15]
00058A  3A0014     BRA NZ, 0x5B4
00058C  20A894     MOV #0xA89, W4
00058E  784214     MOV.B [W4], W4
000590  524FE0     SUB.B W4, #0x0, [W15]
000592  3AFF8F     BRA NZ, 0x4B2
000594  20A8A4     MOV #0xA8A, W4
000596  784214     MOV.B [W4], W4
000598  524FE0     SUB.B W4, #0x0, [W15]
00059A  3AFF8B     BRA NZ, 0x4B2
00059C  20A8B4     MOV #0xA8B, W4
00059E  784214     MOV.B [W4], W4
0005A0  524FE0     SUB.B W4, #0x0, [W15]
0005A2  3AFF87     BRA NZ, 0x4B2
53:                           receiveBuffer3Used || receiveBuffer4Used || receiveBuffer5Used)) {
0005A4  20A8C4     MOV #0xA8C, W4
0005A6  784214     MOV.B [W4], W4
0005A8  524FE0     SUB.B W4, #0x0, [W15]
0005AA  3AFF83     BRA NZ, 0x4B2
0005AC  20A8D4     MOV #0xA8D, W4
0005AE  784214     MOV.B [W4], W4
0005B0  524FE0     SUB.B W4, #0x0, [W15]
0005B2  3AFF7F     BRA NZ, 0x4B2
54:                
55:                        if (newReceiveData == 0 && receiveBuffer1Used != 0) {
0004B2  20A904     MOV #0xA90, W4
0004B4  784214     MOV.B [W4], W4
0004B6  524FE0     SUB.B W4, #0x0, [W15]
0004B8  3A0011     BRA NZ, 0x4DC
0004BA  20A894     MOV #0xA89, W4
0004BC  784214     MOV.B [W4], W4
0004BE  524FE0     SUB.B W4, #0x0, [W15]
0004C0  32000D     BRA Z, 0x4DC
56:                            stringCopy(receiveBuffer1, receivedToProcess);
0004C2  209291     MOV #0x929, W1
0004C4  209520     MOV #0x952, W0
0004C6  0702BB     RCALL stringCopy
57:                            receiveBuffer1Used = 0;
0004C8  EB4200     CLR.B W4
0004CA  780004     MOV W4, W0
0004CC  B7EA89     MOV.B WREG, receiveBuffer1Used
58:                            flushBuffer(receiveBuffer1, RECEIVE_STRING_LENGTH);
0004CE  200291     MOV #0x29, W1
0004D0  209520     MOV #0x952, W0
0004D2  0702A3     RCALL flushBuffer
59:                            newReceiveData = 1;
0004D4  B3C014     MOV.B #0x1, W4
0004D6  FD0200     EXCH W0, W4
0004D8  B7EA90     MOV.B WREG, newReceiveData
0004DA  FD0200     EXCH W0, W4
60:                        }
61:                
62:                        if (receiveBuffer1Used == 0 && receiveBuffer2Used != 0) {
0004DC  20A894     MOV #0xA89, W4
0004DE  784214     MOV.B [W4], W4
0004E0  524FE0     SUB.B W4, #0x0, [W15]
0004E2  3A0011     BRA NZ, 0x506
0004E4  20A8A4     MOV #0xA8A, W4
0004E6  784214     MOV.B [W4], W4
0004E8  524FE0     SUB.B W4, #0x0, [W15]
0004EA  32000D     BRA Z, 0x506
63:                            stringCopy(receiveBuffer2, receiveBuffer1);
0004EC  209521     MOV #0x952, W1
0004EE  2097B0     MOV #0x97B, W0
0004F0  0702A6     RCALL stringCopy
64:                            receiveBuffer2Used = 0;
0004F2  EB4200     CLR.B W4
0004F4  780004     MOV W4, W0
0004F6  B7EA8A     MOV.B WREG, receiveBuffer2Used
65:                            flushBuffer(receiveBuffer2, RECEIVE_STRING_LENGTH);
0004F8  200291     MOV #0x29, W1
0004FA  2097B0     MOV #0x97B, W0
0004FC  07028E     RCALL flushBuffer
66:                            receiveBuffer1Used = 1;
0004FE  B3C014     MOV.B #0x1, W4
000500  FD0200     EXCH W0, W4
000502  B7EA89     MOV.B WREG, receiveBuffer1Used
000504  FD0200     EXCH W0, W4
67:                        }
68:                
69:                        if (receiveBuffer2Used == 0 && receiveBuffer3Used != 0) {
000506  20A8A4     MOV #0xA8A, W4
000508  784214     MOV.B [W4], W4
00050A  524FE0     SUB.B W4, #0x0, [W15]
00050C  3A0011     BRA NZ, 0x530
00050E  20A8B4     MOV #0xA8B, W4
000510  784214     MOV.B [W4], W4
000512  524FE0     SUB.B W4, #0x0, [W15]
000514  32000D     BRA Z, 0x530
70:                            stringCopy(receiveBuffer3, receiveBuffer2);
000516  2097B1     MOV #0x97B, W1
000518  209A40     MOV #0x9A4, W0
00051A  070291     RCALL stringCopy
71:                            receiveBuffer3Used = 0;
00051C  EB4200     CLR.B W4
00051E  780004     MOV W4, W0
000520  B7EA8B     MOV.B WREG, receiveBuffer3Used
72:                            flushBuffer(receiveBuffer3, RECEIVE_STRING_LENGTH);
000522  200291     MOV #0x29, W1
000524  209A40     MOV #0x9A4, W0
000526  070279     RCALL flushBuffer
73:                            receiveBuffer2Used = 1;
000528  B3C014     MOV.B #0x1, W4
00052A  FD0200     EXCH W0, W4
00052C  B7EA8A     MOV.B WREG, receiveBuffer2Used
00052E  FD0200     EXCH W0, W4
74:                        }
75:                
76:                        if (receiveBuffer3Used == 0 && receiveBuffer4Used != 0) {
000530  20A8B4     MOV #0xA8B, W4
000532  784214     MOV.B [W4], W4
000534  524FE0     SUB.B W4, #0x0, [W15]
000536  3A0011     BRA NZ, 0x55A
000538  20A8C4     MOV #0xA8C, W4
00053A  784214     MOV.B [W4], W4
00053C  524FE0     SUB.B W4, #0x0, [W15]
00053E  32000D     BRA Z, 0x55A
77:                            stringCopy(receiveBuffer4, receiveBuffer3);
000540  209A41     MOV #0x9A4, W1
000542  209CD0     MOV #0x9CD, W0
000544  07027C     RCALL stringCopy
78:                            receiveBuffer4Used = 0;
000546  EB4200     CLR.B W4
000548  780004     MOV W4, W0
00054A  B7EA8C     MOV.B WREG, receiveBuffer4Used
79:                            flushBuffer(receiveBuffer4, RECEIVE_STRING_LENGTH);
00054C  200291     MOV #0x29, W1
00054E  209CD0     MOV #0x9CD, W0
000550  070264     RCALL flushBuffer
80:                            receiveBuffer3Used = 1;
000552  B3C014     MOV.B #0x1, W4
000554  FD0200     EXCH W0, W4
000556  B7EA8B     MOV.B WREG, receiveBuffer3Used
000558  FD0200     EXCH W0, W4
81:                        }
82:                
83:                        if (receiveBuffer4Used == 0 && receiveBuffer5Used != 0) {
00055A  20A8C4     MOV #0xA8C, W4
00055C  784214     MOV.B [W4], W4
00055E  524FE0     SUB.B W4, #0x0, [W15]
000560  3A0011     BRA NZ, 0x584
000562  20A8D4     MOV #0xA8D, W4
000564  784214     MOV.B [W4], W4
000566  524FE0     SUB.B W4, #0x0, [W15]
000568  32000D     BRA Z, 0x584
84:                            stringCopy(receiveBuffer5, receiveBuffer4);
00056A  209CD1     MOV #0x9CD, W1
00056C  209F60     MOV #0x9F6, W0
00056E  070267     RCALL stringCopy
85:                            receiveBuffer5Used = 0;
000570  EB4200     CLR.B W4
000572  780004     MOV W4, W0
000574  B7EA8D     MOV.B WREG, receiveBuffer5Used
86:                            flushBuffer(receiveBuffer5, RECEIVE_STRING_LENGTH);
000576  200291     MOV #0x29, W1
000578  209F60     MOV #0x9F6, W0
00057A  07024F     RCALL flushBuffer
87:                            receiveBuffer4Used = 1;
00057C  B3C014     MOV.B #0x1, W4
00057E  FD0200     EXCH W0, W4
000580  B7EA8C     MOV.B WREG, receiveBuffer4Used
000582  FD0200     EXCH W0, W4
88:                        }
89:                    }
90:                
91:                    // check for received information and split it up
92:                    if (newReceiveData != 0 && readyToProcess == 0) {
0005B4  20A904     MOV #0xA90, W4
0005B6  784214     MOV.B [W4], W4
0005B8  524FE0     SUB.B W4, #0x0, [W15]
0005BA  3200DD     BRA Z, 0x776
0005BC  20A8E4     MOV #0xA8E, W4
0005BE  784214     MOV.B [W4], W4
0005C0  524FE0     SUB.B W4, #0x0, [W15]
0005C2  3A00D9     BRA NZ, 0x776
93:                
94:                        // Initialize receivedCommand, receivedAttribute, and receivedValue
95:                        short k = 0;
0005C4  EB0200     CLR W4
0005C6  780F04     MOV W4, [W14]
96:                        while (k < RECEIVE_PARAM_LENGTH) {
0005C8  370011     BRA 0x5EC
0005EC  78021E     MOV [W14], W4
0005EE  520FF3     SUB W4, #0x13, [W15]
0005F0  34FFEC     BRA LE, 0x5CA
97:                            receivedCommand[k] = receivedAttribute[k] = receivedValue[k] = 0;
0005CA  20A704     MOV #0xA70, W4
0005CC  42029E     ADD W4, [W14], W5
0005CE  EB4200     CLR.B W4
0005D0  784A84     MOV.B W4, [W5]
0005D2  20A704     MOV #0xA70, W4
0005D4  42021E     ADD W4, [W14], W4
0005D6  784214     MOV.B [W4], W4
0005D8  20A5C5     MOV #0xA5C, W5
0005DA  42829E     ADD W5, [W14], W5
0005DC  784A84     MOV.B W4, [W5]
0005DE  20A5C4     MOV #0xA5C, W4
0005E0  42021E     ADD W4, [W14], W4
0005E2  784214     MOV.B [W4], W4
0005E4  20A485     MOV #0xA48, W5
0005E6  42829E     ADD W5, [W14], W5
0005E8  784A84     MOV.B W4, [W5]
98:                            k++;
0005EA  E80F1E     INC [W14], [W14]
99:                        }
100:               
101:                       // Check for beginning of command. If not, abort.
102:                       if (receivedToProcess[0] != '%') {
0005F2  209295     MOV #0x929, W5
0005F4  784295     MOV.B [W5], W5
0005F6  B3C254     MOV.B #0x25, W4
0005F8  52CF84     SUB.B W5, W4, [W15]
0005FA  320005     BRA Z, 0x606
103:                           newReceiveData = 0;
0005FC  EB4200     CLR.B W4
0005FE  FD0200     EXCH W0, W4
000600  B7EA90     MOV.B WREG, newReceiveData
000602  FD0200     EXCH W0, W4
104:                           return;
000604  3700B8     BRA 0x776
105:                       }
106:                       // Command start was present. Split string into components.
107:                       else {
108:                           short i = 1;
000606  200014     MOV #0x1, W4
000608  980714     MOV W4, [W14+2]
109:                           short j = 0;
00060A  EB0200     CLR W4
00060C  980724     MOV W4, [W14+4]
110:               
111:                           // Extract receivedCommand
112:                           while  (receivedToProcess[i] > 47 && receivedToProcess[i] < 127 &&
00060E  37000E     BRA 0x62C
00062C  90029E     MOV [W14+2], W5
00062E  209294     MOV #0x929, W4
000630  428204     ADD W5, W4, W4
000632  784294     MOV.B [W4], W5
000634  B3C2F4     MOV.B #0x2F, W4
000636  52CF84     SUB.B W5, W4, [W15]
000638  34000E     BRA LE, 0x656
00063A  90029E     MOV [W14+2], W5
00063C  209294     MOV #0x929, W4
00063E  428204     ADD W5, W4, W4
000640  784294     MOV.B [W4], W5
000642  B3C7F4     MOV.B #0x7F, W4
000644  52CF84     SUB.B W5, W4, [W15]
000646  320007     BRA Z, 0x656
000648  90022E     MOV [W14+4], W4
00064A  520FF3     SUB W4, #0x13, [W15]
00064C  3C0004     BRA GT, 0x656
113:                                   j < RECEIVE_PARAM_LENGTH && i < RECEIVE_STRING_LENGTH - 1) { // RECEIVE_STRING_LENGTH - 1 because of check for '.' in the last step
00064E  90029E     MOV [W14+2], W5
000650  200274     MOV #0x27, W4
000652  528F84     SUB W5, W4, [W15]
000654  34FFDD     BRA LE, 0x610
114:                               receivedCommand[j++] = receivedToProcess[i++];
000610  90029E     MOV [W14+2], W5
000612  209294     MOV #0x929, W4
000614  428204     ADD W5, W4, W4
000616  784214     MOV.B [W4], W4
000618  90032E     MOV [W14+4], W6
00061A  20A485     MOV #0xA48, W5
00061C  430285     ADD W6, W5, W5
00061E  784A84     MOV.B W4, [W5]
000620  90022E     MOV [W14+4], W4
000622  E80204     INC W4, W4
000624  980724     MOV W4, [W14+4]
000626  90021E     MOV [W14+2], W4
000628  E80204     INC W4, W4
00062A  980714     MOV W4, [W14+2]
115:                           }
116:                           // If delimeter is not next, something went wrong. Abort.
117:                           if (receivedToProcess[i++] != ' ') {
000656  90029E     MOV [W14+2], W5
000658  209294     MOV #0x929, W4
00065A  428204     ADD W5, W4, W4
00065C  784294     MOV.B [W4], W5
00065E  B3C204     MOV.B #0x20, W4
000660  6AC204     XOR.B W5, W4, W4
000662  FB8204     ZE W4, W4
000664  EA0204     NEG W4, W4
000666  DE224F     LSR W4, #15, W4
000668  784204     MOV.B W4, W4
00066A  90029E     MOV [W14+2], W5
00066C  E80285     INC W5, W5
00066E  980715     MOV W5, [W14+2]
000670  524FE0     SUB.B W4, #0x0, [W15]
000672  320005     BRA Z, 0x67E
118:                               newReceiveData = 0;
000674  EB4200     CLR.B W4
000676  FD0200     EXCH W0, W4
000678  B7EA90     MOV.B WREG, newReceiveData
00067A  FD0200     EXCH W0, W4
119:                               return;
00067C  37007C     BRA 0x776
120:                           }
121:               
122:                           // Extract receivedAttribute
123:                           j = 0;
00067E  EB0200     CLR W4
000680  980724     MOV W4, [W14+4]
124:                           while  (receivedToProcess[i] > 47 && receivedToProcess[i] < 127 &&
000682  37000E     BRA 0x6A0
0006A0  90029E     MOV [W14+2], W5
0006A2  209294     MOV #0x929, W4
0006A4  428204     ADD W5, W4, W4
0006A6  784294     MOV.B [W4], W5
0006A8  B3C2F4     MOV.B #0x2F, W4
0006AA  52CF84     SUB.B W5, W4, [W15]
0006AC  34000E     BRA LE, 0x6CA
0006AE  90029E     MOV [W14+2], W5
0006B0  209294     MOV #0x929, W4
0006B2  428204     ADD W5, W4, W4
0006B4  784294     MOV.B [W4], W5
0006B6  B3C7F4     MOV.B #0x7F, W4
0006B8  52CF84     SUB.B W5, W4, [W15]
0006BA  320007     BRA Z, 0x6CA
0006BC  90022E     MOV [W14+4], W4
0006BE  520FF3     SUB W4, #0x13, [W15]
0006C0  3C0004     BRA GT, 0x6CA
125:                                   j < RECEIVE_PARAM_LENGTH && i < RECEIVE_STRING_LENGTH - 1) {
0006C2  90029E     MOV [W14+2], W5
0006C4  200274     MOV #0x27, W4
0006C6  528F84     SUB W5, W4, [W15]
0006C8  34FFDD     BRA LE, 0x684
126:                               receivedAttribute[j++] = receivedToProcess[i++];
000684  90029E     MOV [W14+2], W5
000686  209294     MOV #0x929, W4
000688  428204     ADD W5, W4, W4
00068A  784214     MOV.B [W4], W4
00068C  90032E     MOV [W14+4], W6
00068E  20A5C5     MOV #0xA5C, W5
000690  430285     ADD W6, W5, W5
000692  784A84     MOV.B W4, [W5]
000694  90022E     MOV [W14+4], W4
000696  E80204     INC W4, W4
000698  980724     MOV W4, [W14+4]
00069A  90021E     MOV [W14+2], W4
00069C  E80204     INC W4, W4
00069E  980714     MOV W4, [W14+2]
127:                           }
128:                           // If delimeter is not next, something went wrong. Abort.
129:                           if (receivedToProcess[i++] != ' ') {
0006CA  90029E     MOV [W14+2], W5
0006CC  209294     MOV #0x929, W4
0006CE  428204     ADD W5, W4, W4
0006D0  784294     MOV.B [W4], W5
0006D2  B3C204     MOV.B #0x20, W4
0006D4  6AC204     XOR.B W5, W4, W4
0006D6  FB8204     ZE W4, W4
0006D8  EA0204     NEG W4, W4
0006DA  DE224F     LSR W4, #15, W4
0006DC  784204     MOV.B W4, W4
0006DE  90029E     MOV [W14+2], W5
0006E0  E80285     INC W5, W5
0006E2  980715     MOV W5, [W14+2]
0006E4  524FE0     SUB.B W4, #0x0, [W15]
0006E6  320005     BRA Z, 0x6F2
130:                               newReceiveData = 0;
0006E8  EB4200     CLR.B W4
0006EA  FD0200     EXCH W0, W4
0006EC  B7EA90     MOV.B WREG, newReceiveData
0006EE  FD0200     EXCH W0, W4
131:                               return;
0006F0  370042     BRA 0x776
132:                           }
133:               
134:                           // Extract receivedValue
135:                           j = 0;
0006F2  EB0200     CLR W4
0006F4  980724     MOV W4, [W14+4]
136:                           while  (receivedToProcess[i] > 47 && receivedToProcess[i] < 127 &&
0006F6  37000E     BRA 0x714
000714  90029E     MOV [W14+2], W5
000716  209294     MOV #0x929, W4
000718  428204     ADD W5, W4, W4
00071A  784294     MOV.B [W4], W5
00071C  B3C2F4     MOV.B #0x2F, W4
00071E  52CF84     SUB.B W5, W4, [W15]
000720  34000E     BRA LE, 0x73E
000722  90029E     MOV [W14+2], W5
000724  209294     MOV #0x929, W4
000726  428204     ADD W5, W4, W4
000728  784294     MOV.B [W4], W5
00072A  B3C7F4     MOV.B #0x7F, W4
00072C  52CF84     SUB.B W5, W4, [W15]
00072E  320007     BRA Z, 0x73E
000730  90022E     MOV [W14+4], W4
000732  520FF3     SUB W4, #0x13, [W15]
000734  3C0004     BRA GT, 0x73E
137:                                   j < RECEIVE_PARAM_LENGTH && i < RECEIVE_STRING_LENGTH - 1) {
000736  90029E     MOV [W14+2], W5
000738  200274     MOV #0x27, W4
00073A  528F84     SUB W5, W4, [W15]
00073C  34FFDD     BRA LE, 0x6F8
138:                               receivedValue[j++] = receivedToProcess[i++];
0006F8  90029E     MOV [W14+2], W5
0006FA  209294     MOV #0x929, W4
0006FC  428204     ADD W5, W4, W4
0006FE  784214     MOV.B [W4], W4
000700  90032E     MOV [W14+4], W6
000702  20A705     MOV #0xA70, W5
000704  430285     ADD W6, W5, W5
000706  784A84     MOV.B W4, [W5]
000708  90022E     MOV [W14+4], W4
00070A  E80204     INC W4, W4
00070C  980724     MOV W4, [W14+4]
00070E  90021E     MOV [W14+2], W4
000710  E80204     INC W4, W4
000712  980714     MOV W4, [W14+2]
139:                           }
140:                           // If end of command is not next, something went wrong. Abort.
141:                           if (receivedToProcess[i] != '.') {
00073E  90029E     MOV [W14+2], W5
000740  209294     MOV #0x929, W4
000742  428204     ADD W5, W4, W4
000744  784294     MOV.B [W4], W5
000746  B3C2E4     MOV.B #0x2E, W4
000748  52CF84     SUB.B W5, W4, [W15]
00074A  320005     BRA Z, 0x756
142:                               newReceiveData = 0;
00074C  EB4200     CLR.B W4
00074E  FD0200     EXCH W0, W4
000750  B7EA90     MOV.B WREG, newReceiveData
000752  FD0200     EXCH W0, W4
143:                               return;
000754  370010     BRA 0x776
144:                           }
145:               
146:                           // Received string was in the right format
147:                           // and has been split up successfully
148:                           readyToProcess = 1;
000756  B3C014     MOV.B #0x1, W4
000758  FD0200     EXCH W0, W4
00075A  B7EA8E     MOV.B WREG, readyToProcess
00075C  FD0200     EXCH W0, W4
149:                           newReceiveData = 0;
00075E  EB4200     CLR.B W4
000760  FD0200     EXCH W0, W4
000762  B7EA90     MOV.B WREG, newReceiveData
000764  FD0200     EXCH W0, W4
150:                           commError = 0;
000766  EB4200     CLR.B W4
000768  FD0200     EXCH W0, W4
00076A  B7EA91     MOV.B WREG, commError
00076C  FD0200     EXCH W0, W4
151:               
152:                           processReceivedCommand();
00076E  0702B8     RCALL processReceivedCommand
153:                           flushBuffer(receivedToProcess, SEND_STRING_LENGTH);
000770  200281     MOV #0x28, W1
000772  209290     MOV #0x929, W0
000774  070152     RCALL flushBuffer
154:                       }
155:                   }
156:               }
000776  FA8000     ULNK
157:               
158:               void sendCommands(void) {
00077A  FA0000     LNK #0x0
159:                   // Move data from sendBuffer1 into stringToSend if possible
160:                   // and promote data in other sendBuffers
161:                   if (newSendData == 0 && sendBuffer1Used != 0) {
00077C  20A8F4     MOV #0xA8F, W4
00077E  784214     MOV.B [W4], W4
000780  524FE0     SUB.B W4, #0x0, [W15]
000782  3A001A     BRA NZ, 0x7B8
000784  20A844     MOV #0xA84, W4
000786  784214     MOV.B [W4], W4
000788  524FE0     SUB.B W4, #0x0, [W15]
00078A  320016     BRA Z, 0x7B8
162:                       stringCopy(sendBuffer1, stringToSendU2);
00078C  20AB61     MOV #0xAB6, W1
00078E  208390     MOV #0x839, W0
000790  070156     RCALL stringCopy
163:                       newSendDataU2 = 1;
000792  B3C014     MOV.B #0x1, W4
000794  780004     MOV W4, W0
000796  B7EAB0     MOV.B WREG, newSendDataU2
164:               #ifdef POWER_BOX
165:                       stringCopy(sendBuffer1, stringToSendU1);
000798  20B0C1     MOV #0xB0C, W1
00079A  208390     MOV #0x839, W0
00079C  070150     RCALL stringCopy
166:                       newSendDataU1 = 1;
00079E  B3C014     MOV.B #0x1, W4
0007A0  780004     MOV W4, W0
0007A2  B7EB07     MOV.B WREG, newSendDataU1
167:               #endif
168:                       sendBuffer1Used = 0;
0007A4  EB4200     CLR.B W4
0007A6  780004     MOV W4, W0
0007A8  B7EA84     MOV.B WREG, sendBuffer1Used
169:                       flushBuffer(sendBuffer1, SEND_STRING_LENGTH);
0007AA  200281     MOV #0x28, W1
0007AC  208390     MOV #0x839, W0
0007AE  070135     RCALL flushBuffer
170:                       newSendData = 1;
0007B0  B3C014     MOV.B #0x1, W4
0007B2  FD0200     EXCH W0, W4
0007B4  B7EA8F     MOV.B WREG, newSendData
0007B6  FD0200     EXCH W0, W4
171:               
172:                   }
173:               
174:                   if (sendBuffer1Used == 0 && sendBuffer2Used != 0) {
0007B8  20A844     MOV #0xA84, W4
0007BA  784214     MOV.B [W4], W4
0007BC  524FE0     SUB.B W4, #0x0, [W15]
0007BE  3A0011     BRA NZ, 0x7E2
0007C0  20A854     MOV #0xA85, W4
0007C2  784214     MOV.B [W4], W4
0007C4  524FE0     SUB.B W4, #0x0, [W15]
0007C6  32000D     BRA Z, 0x7E2
175:                       stringCopy(sendBuffer2, sendBuffer1);
0007C8  208391     MOV #0x839, W1
0007CA  208610     MOV #0x861, W0
0007CC  070138     RCALL stringCopy
176:                       sendBuffer2Used = 0;
0007CE  EB4200     CLR.B W4
0007D0  780004     MOV W4, W0
0007D2  B7EA85     MOV.B WREG, sendBuffer2Used
177:                       flushBuffer(sendBuffer2, SEND_STRING_LENGTH);
0007D4  200281     MOV #0x28, W1
0007D6  208610     MOV #0x861, W0
0007D8  070120     RCALL flushBuffer
178:                       sendBuffer1Used = 1;
0007DA  B3C014     MOV.B #0x1, W4
0007DC  FD0200     EXCH W0, W4
0007DE  B7EA84     MOV.B WREG, sendBuffer1Used
0007E0  FD0200     EXCH W0, W4
179:                   }
180:               
181:                   if (sendBuffer2Used == 0 && sendBuffer3Used != 0) {
0007E2  20A854     MOV #0xA85, W4
0007E4  784214     MOV.B [W4], W4
0007E6  524FE0     SUB.B W4, #0x0, [W15]
0007E8  3A0011     BRA NZ, 0x80C
0007EA  20A864     MOV #0xA86, W4
0007EC  784214     MOV.B [W4], W4
0007EE  524FE0     SUB.B W4, #0x0, [W15]
0007F0  32000D     BRA Z, 0x80C
182:                       stringCopy(sendBuffer3, sendBuffer2);
0007F2  208611     MOV #0x861, W1
0007F4  208890     MOV #0x889, W0
0007F6  070123     RCALL stringCopy
183:                       sendBuffer3Used = 0;
0007F8  EB4200     CLR.B W4
0007FA  780004     MOV W4, W0
0007FC  B7EA86     MOV.B WREG, sendBuffer3Used
184:                       flushBuffer(sendBuffer3, SEND_STRING_LENGTH);
0007FE  200281     MOV #0x28, W1
000800  208890     MOV #0x889, W0
000802  07010B     RCALL flushBuffer
185:                       sendBuffer2Used = 1;
000804  B3C014     MOV.B #0x1, W4
000806  FD0200     EXCH W0, W4
000808  B7EA85     MOV.B WREG, sendBuffer2Used
00080A  FD0200     EXCH W0, W4
186:                   }
187:               
188:                   if (sendBuffer3Used == 0 && sendBuffer4Used != 0) {
00080C  20A864     MOV #0xA86, W4
00080E  784214     MOV.B [W4], W4
000810  524FE0     SUB.B W4, #0x0, [W15]
000812  3A0011     BRA NZ, 0x836
000814  20A874     MOV #0xA87, W4
000816  784214     MOV.B [W4], W4
000818  524FE0     SUB.B W4, #0x0, [W15]
00081A  32000D     BRA Z, 0x836
189:                       stringCopy(sendBuffer4, sendBuffer3);
00081C  208891     MOV #0x889, W1
00081E  208B10     MOV #0x8B1, W0
000820  07010E     RCALL stringCopy
190:                       sendBuffer4Used = 0;
000822  EB4200     CLR.B W4
000824  780004     MOV W4, W0
000826  B7EA87     MOV.B WREG, sendBuffer4Used
191:                       flushBuffer(sendBuffer4, SEND_STRING_LENGTH);
000828  200281     MOV #0x28, W1
00082A  208B10     MOV #0x8B1, W0
00082C  0700F6     RCALL flushBuffer
192:                       sendBuffer3Used = 1;
00082E  B3C014     MOV.B #0x1, W4
000830  FD0200     EXCH W0, W4
000832  B7EA86     MOV.B WREG, sendBuffer3Used
000834  FD0200     EXCH W0, W4
193:                   }
194:               
195:                   if (sendBuffer4Used == 0 && sendBuffer5Used != 0) {
000836  20A874     MOV #0xA87, W4
000838  784214     MOV.B [W4], W4
00083A  524FE0     SUB.B W4, #0x0, [W15]
00083C  3A002E     BRA NZ, 0x89A
00083E  20A884     MOV #0xA88, W4
000840  784214     MOV.B [W4], W4
000842  524FE0     SUB.B W4, #0x0, [W15]
000844  32002C     BRA Z, 0x89E
196:                       stringCopy(sendBuffer5, sendBuffer4);
000846  208B11     MOV #0x8B1, W1
000848  208D90     MOV #0x8D9, W0
00084A  0700F9     RCALL stringCopy
197:                       sendBuffer5Used = 0;
00084C  EB4200     CLR.B W4
00084E  780004     MOV W4, W0
000850  B7EA88     MOV.B WREG, sendBuffer5Used
198:                       flushBuffer(sendBuffer5, SEND_STRING_LENGTH);
000852  200281     MOV #0x28, W1
000854  208D90     MOV #0x8D9, W0
000856  0700E1     RCALL flushBuffer
199:                       sendBuffer4Used = 1;
000858  B3C014     MOV.B #0x1, W4
00085A  FD0200     EXCH W0, W4
00085C  B7EA87     MOV.B WREG, sendBuffer4Used
00085E  FD0200     EXCH W0, W4
200:                   }
201:               
202:                   /* Fill UART transmit buffers with characters.
203:                    * When checking if we can send another character
204:                    * UxSTAbits.UTXBF == 0 is not a valid check.
205:                    * UTXBF doesn't always update correctly.
206:                    * See PIC errata */
207:                   while (U2STAbits.TRMT == 1 && stringToSendU2[sendIndexU2] != 0 && newSendDataU2 != 0) {
000860  37001F     BRA 0x8A0
00089A  000000     NOP
00089C  370001     BRA 0x8A0
00089E  000000     NOP
0008A0  801195     MOV U2STA, W5
0008A2  201004     MOV #0x100, W4
0008A4  628204     AND W5, W4, W4
0008A6  520FE0     SUB W4, #0x0, [W15]
0008A8  320027     BRA Z, 0x8F8
0008AA  805595     MOV sendIndexU2, W5
0008AC  20AB64     MOV #0xAB6, W4
0008AE  428204     ADD W5, W4, W4
0008B0  784214     MOV.B [W4], W4
0008B2  524FE0     SUB.B W4, #0x0, [W15]
0008B4  320023     BRA Z, 0x8FC
0008B6  20AB04     MOV #0xAB0, W4
0008B8  784214     MOV.B [W4], W4
0008BA  524FE0     SUB.B W4, #0x0, [W15]
0008BC  3AFFD2     BRA NZ, 0x862
208:                       U2TXREG = stringToSendU2[sendIndexU2++];
000862  805595     MOV sendIndexU2, W5
000864  20AB64     MOV #0xAB6, W4
000866  428204     ADD W5, W4, W4
000868  784214     MOV.B [W4], W4
00086A  FB0204     SE W4, W4
00086C  8811A4     MOV W4, U2TXREG
00086E  E80205     INC W5, W4
000870  885594     MOV W4, sendIndexU2
209:               
210:                       if (stringToSendU2[sendIndexU2] == 0 || stringToSendU2[sendIndexU2 - 1] == '\n') {
000872  805595     MOV sendIndexU2, W5
000874  20AB64     MOV #0xAB6, W4
000876  428204     ADD W5, W4, W4
000878  784214     MOV.B [W4], W4
00087A  524FE0     SUB.B W4, #0x0, [W15]
00087C  320007     BRA Z, 0x88C
00087E  805594     MOV sendIndexU2, W4
000880  E90284     DEC W4, W5
000882  20AB64     MOV #0xAB6, W4
000884  428204     ADD W5, W4, W4
000886  784214     MOV.B [W4], W4
000888  524FEA     SUB.B W4, #0xA, [W15]
00088A  3A000A     BRA NZ, 0x8A0
211:                           sendIndexU2 = 0;
00088C  EB0200     CLR W4
00088E  885594     MOV W4, sendIndexU2
212:                           newSendDataU2 = 0;
000890  EB4200     CLR.B W4
000892  FD0200     EXCH W0, W4
000894  B7EAB0     MOV.B WREG, newSendDataU2
000896  FD0200     EXCH W0, W4
000898  370003     BRA 0x8A0
213:                       }
214:                   }
215:               
216:               #ifdef DISPLAY_BOX
217:                   if (newSendData != 0 && newSendDataU2 == 0) {
218:                       newSendData = 0;
219:                   }
220:               #endif
221:               #ifdef POWER_BOX
222:                   while (U1STAbits.TRMT == 1 && stringToSendU1[sendIndexU1] != 0 && newSendDataU1 != 0) {
0008BE  37001F     BRA 0x8FE
0008F8  000000     NOP
0008FA  370001     BRA 0x8FE
0008FC  000000     NOP
0008FE  801115     MOV U1STA, W5
000900  201004     MOV #0x100, W4
000902  628204     AND W5, W4, W4
000904  520FE0     SUB W4, #0x0, [W15]
000906  32000A     BRA Z, 0x91C
000908  805845     MOV sendIndexU1, W5
00090A  20B0C4     MOV #0xB0C, W4
00090C  428204     ADD W5, W4, W4
00090E  784214     MOV.B [W4], W4
000910  524FE0     SUB.B W4, #0x0, [W15]
000912  320004     BRA Z, 0x91C
000914  20B074     MOV #0xB07, W4
000916  784214     MOV.B [W4], W4
000918  524FE0     SUB.B W4, #0x0, [W15]
00091A  3AFFD2     BRA NZ, 0x8C0
223:                       U1TXREG = stringToSendU1[sendIndexU1++];
0008C0  805845     MOV sendIndexU1, W5
0008C2  20B0C4     MOV #0xB0C, W4
0008C4  428204     ADD W5, W4, W4
0008C6  784214     MOV.B [W4], W4
0008C8  FB0204     SE W4, W4
0008CA  881124     MOV W4, U1TXREG
0008CC  E80205     INC W5, W4
0008CE  885844     MOV W4, sendIndexU1
224:               
225:                       if (stringToSendU1[sendIndexU1] == 0 || stringToSendU1[sendIndexU1 - 1] == '\n') {
0008D0  805845     MOV sendIndexU1, W5
0008D2  20B0C4     MOV #0xB0C, W4
0008D4  428204     ADD W5, W4, W4
0008D6  784214     MOV.B [W4], W4
0008D8  524FE0     SUB.B W4, #0x0, [W15]
0008DA  320007     BRA Z, 0x8EA
0008DC  805844     MOV sendIndexU1, W4
0008DE  E90284     DEC W4, W5
0008E0  20B0C4     MOV #0xB0C, W4
0008E2  428204     ADD W5, W4, W4
0008E4  784214     MOV.B [W4], W4
0008E6  524FEA     SUB.B W4, #0xA, [W15]
0008E8  3A000A     BRA NZ, 0x8FE
226:                           sendIndexU1 = 0;
0008EA  EB0200     CLR W4
0008EC  885844     MOV W4, sendIndexU1
227:                           newSendDataU1 = 0;
0008EE  EB4200     CLR.B W4
0008F0  FD0200     EXCH W0, W4
0008F2  B7EB07     MOV.B WREG, newSendDataU1
0008F4  FD0200     EXCH W0, W4
0008F6  370003     BRA 0x8FE
228:                       }
229:                   }
230:                   if (newSendData != 0 && newSendDataU2 == 0 && newSendDataU1 == 0) {
00091C  20A8F4     MOV #0xA8F, W4
00091E  784214     MOV.B [W4], W4
000920  524FE0     SUB.B W4, #0x0, [W15]
000922  32000B     BRA Z, 0x93A
000924  20AB04     MOV #0xAB0, W4
000926  784214     MOV.B [W4], W4
000928  524FE0     SUB.B W4, #0x0, [W15]
00092A  3A0007     BRA NZ, 0x93A
00092C  20B074     MOV #0xB07, W4
00092E  784214     MOV.B [W4], W4
000930  524FE0     SUB.B W4, #0x0, [W15]
000932  3A0003     BRA NZ, 0x93A
231:                       newSendData = 0;
000934  EB4200     CLR.B W4
000936  780004     MOV W4, W0
000938  B7EA8F     MOV.B WREG, newSendData
232:                   }
233:               #endif
234:               
235:               }
00093A  FA8000     ULNK
236:               
237:               char* sendBuffer(void) {
00093E  FA0000     LNK #0x0
238:                   if (sendBuffer1Used == 0) {
000940  20A844     MOV #0xA84, W4
000942  784214     MOV.B [W4], W4
000944  524FE0     SUB.B W4, #0x0, [W15]
000946  3A0006     BRA NZ, 0x954
239:                       sendBuffer1Used = 1;
000948  B3C014     MOV.B #0x1, W4
00094A  FD0200     EXCH W0, W4
00094C  B7EA84     MOV.B WREG, sendBuffer1Used
00094E  FD0200     EXCH W0, W4
240:                       return sendBuffer1;
000950  208394     MOV #0x839, W4
000952  370029     BRA 0x9A6
241:                   }
242:                   else if (sendBuffer2Used == 0) {
000954  20A854     MOV #0xA85, W4
000956  784214     MOV.B [W4], W4
000958  524FE0     SUB.B W4, #0x0, [W15]
00095A  3A0006     BRA NZ, 0x968
243:                       sendBuffer2Used = 1;
00095C  B3C014     MOV.B #0x1, W4
00095E  FD0200     EXCH W0, W4
000960  B7EA85     MOV.B WREG, sendBuffer2Used
000962  FD0200     EXCH W0, W4
244:                       return sendBuffer2;
000964  208614     MOV #0x861, W4
000966  37001F     BRA 0x9A6
245:                   }
246:                   else if (sendBuffer3Used == 0) {
000968  20A864     MOV #0xA86, W4
00096A  784214     MOV.B [W4], W4
00096C  524FE0     SUB.B W4, #0x0, [W15]
00096E  3A0006     BRA NZ, 0x97C
247:                       sendBuffer3Used = 1;
000970  B3C014     MOV.B #0x1, W4
000972  FD0200     EXCH W0, W4
000974  B7EA86     MOV.B WREG, sendBuffer3Used
000976  FD0200     EXCH W0, W4
248:                       return sendBuffer3;
000978  208894     MOV #0x889, W4
00097A  370015     BRA 0x9A6
249:                   }
250:                   else if (sendBuffer4Used == 0) {
00097C  20A874     MOV #0xA87, W4
00097E  784214     MOV.B [W4], W4
000980  524FE0     SUB.B W4, #0x0, [W15]
000982  3A0006     BRA NZ, 0x990
251:                       sendBuffer4Used = 1;
000984  B3C014     MOV.B #0x1, W4
000986  FD0200     EXCH W0, W4
000988  B7EA87     MOV.B WREG, sendBuffer4Used
00098A  FD0200     EXCH W0, W4
252:                       return sendBuffer4;
00098C  208B14     MOV #0x8B1, W4
00098E  37000B     BRA 0x9A6
253:                   }
254:                   else if (sendBuffer5Used == 0) {
000990  20A884     MOV #0xA88, W4
000992  784214     MOV.B [W4], W4
000994  524FE0     SUB.B W4, #0x0, [W15]
000996  3A0006     BRA NZ, 0x9A4
255:                       sendBuffer5Used = 1;
000998  B3C014     MOV.B #0x1, W4
00099A  FD0200     EXCH W0, W4
00099C  B7EA88     MOV.B WREG, sendBuffer5Used
00099E  FD0200     EXCH W0, W4
256:                       return sendBuffer5;
0009A0  208D94     MOV #0x8D9, W4
0009A2  370001     BRA 0x9A6
257:                   }
258:                   // no room in any buffer, throw data away
259:                   else return sendBlackHole;
0009A4  209014     MOV #0x901, W4
260:               }
0009A6  780004     MOV W4, W0
261:               
262:               char* receiveBuffer(void) {
0009AC  FA0000     LNK #0x0
263:                   if (receiveBuffer1Used == 0) {
0009AE  20A894     MOV #0xA89, W4
0009B0  784214     MOV.B [W4], W4
0009B2  524FE0     SUB.B W4, #0x0, [W15]
0009B4  3A0006     BRA NZ, 0x9C2
264:                       receiveBuffer1Used = 1;
0009B6  B3C014     MOV.B #0x1, W4
0009B8  FD0200     EXCH W0, W4
0009BA  B7EA89     MOV.B WREG, receiveBuffer1Used
0009BC  FD0200     EXCH W0, W4
265:                       return receiveBuffer1;
0009BE  209524     MOV #0x952, W4
0009C0  370029     BRA 0xA14
266:                   }
267:                   else if (receiveBuffer2Used == 0) {
0009C2  20A8A4     MOV #0xA8A, W4
0009C4  784214     MOV.B [W4], W4
0009C6  524FE0     SUB.B W4, #0x0, [W15]
0009C8  3A0006     BRA NZ, 0x9D6
268:                       receiveBuffer2Used = 1;
0009CA  B3C014     MOV.B #0x1, W4
0009CC  FD0200     EXCH W0, W4
0009CE  B7EA8A     MOV.B WREG, receiveBuffer2Used
0009D0  FD0200     EXCH W0, W4
269:                       return receiveBuffer2;
0009D2  2097B4     MOV #0x97B, W4
0009D4  37001F     BRA 0xA14
270:                   }
271:                   else if (receiveBuffer3Used == 0) {
0009D6  20A8B4     MOV #0xA8B, W4
0009D8  784214     MOV.B [W4], W4
0009DA  524FE0     SUB.B W4, #0x0, [W15]
0009DC  3A0006     BRA NZ, 0x9EA
272:                       receiveBuffer3Used = 1;
0009DE  B3C014     MOV.B #0x1, W4
0009E0  FD0200     EXCH W0, W4
0009E2  B7EA8B     MOV.B WREG, receiveBuffer3Used
0009E4  FD0200     EXCH W0, W4
273:                       return receiveBuffer3;
0009E6  209A44     MOV #0x9A4, W4
0009E8  370015     BRA 0xA14
274:                   }
275:                   else if (receiveBuffer4Used == 0) {
0009EA  20A8C4     MOV #0xA8C, W4
0009EC  784214     MOV.B [W4], W4
0009EE  524FE0     SUB.B W4, #0x0, [W15]
0009F0  3A0006     BRA NZ, 0x9FE
276:                       receiveBuffer4Used = 1;
0009F2  B3C014     MOV.B #0x1, W4
0009F4  FD0200     EXCH W0, W4
0009F6  B7EA8C     MOV.B WREG, receiveBuffer4Used
0009F8  FD0200     EXCH W0, W4
277:                       return receiveBuffer4;
0009FA  209CD4     MOV #0x9CD, W4
0009FC  37000B     BRA 0xA14
278:                   }
279:                   else if (receiveBuffer5Used == 0) {
0009FE  20A8D4     MOV #0xA8D, W4
000A00  784214     MOV.B [W4], W4
000A02  524FE0     SUB.B W4, #0x0, [W15]
000A04  3A0006     BRA NZ, 0xA12
280:                       receiveBuffer5Used = 1;
000A06  B3C014     MOV.B #0x1, W4
000A08  FD0200     EXCH W0, W4
000A0A  B7EA8D     MOV.B WREG, receiveBuffer5Used
000A0C  FD0200     EXCH W0, W4
281:                       return receiveBuffer5;
000A0E  209F64     MOV #0x9F6, W4
000A10  370001     BRA 0xA14
282:                   }
283:                   // no room in any buffer, throw data away
284:                   else return receiveBlackHole;
000A12  20A1F4     MOV #0xA1F, W4
285:               }
000A14  780004     MOV W4, W0
286:               
287:               void flushBuffer(char* target, short length) {
000A1A  FA0006     LNK #0x6
000A1C  980710     MOV W0, [W14+2]
000A1E  980721     MOV W1, [W14+4]
288:                   short k = 0;
000A20  EB0200     CLR W4
000A22  780F04     MOV W4, [W14]
289:                   while (k < length)
000A24  370006     BRA 0xA32
000A32  90022E     MOV [W14+4], W4
000A34  78029E     MOV [W14], W5
000A36  528F84     SUB W5, W4, [W15]
000A38  35FFF6     BRA LT, 0xA26
290:                       target[k++] = 0;
000A26  78021E     MOV [W14], W4
000A28  90029E     MOV [W14+2], W5
000A2A  428284     ADD W5, W4, W5
000A2C  EB4200     CLR.B W4
000A2E  784A84     MOV.B W4, [W5]
000A30  E80F1E     INC [W14], [W14]
291:               }
000A3A  FA8000     ULNK
292:               
293:               void stringCopy(char* from, char* to) {
000A3E  FA0006     LNK #0x6
000A40  980710     MOV W0, [W14+2]
000A42  980721     MOV W1, [W14+4]
294:                   int i;
295:                   for (i = 0; from[i] != 0; i++) {
000A44  EB0200     CLR W4
000A46  780F04     MOV W4, [W14]
000A48  370009     BRA 0xA5C
000A5A  E80F1E     INC [W14], [W14]
000A5C  78021E     MOV [W14], W4
000A5E  90029E     MOV [W14+2], W5
000A60  428204     ADD W5, W4, W4
000A62  784214     MOV.B [W4], W4
000A64  524FE0     SUB.B W4, #0x0, [W15]
000A66  3AFFF1     BRA NZ, 0xA4A
296:                       to[i] = from[i];
000A4A  78021E     MOV [W14], W4
000A4C  9002AE     MOV [W14+4], W5
000A4E  428284     ADD W5, W4, W5
000A50  78021E     MOV [W14], W4
000A52  90031E     MOV [W14+2], W6
000A54  430204     ADD W6, W4, W4
000A56  784214     MOV.B [W4], W4
000A58  784A84     MOV.B W4, [W5]
297:                   }
298:                   to[i] = 0;
000A68  78021E     MOV [W14], W4
000A6A  9002AE     MOV [W14+4], W5
000A6C  428284     ADD W5, W4, W5
000A6E  EB4200     CLR.B W4
000A70  784A84     MOV.B W4, [W5]
299:               }
000A72  FA8000     ULNK
300:               
301:               // concatenate the second string onto the first
302:               void stringConcat(char* destination, char* source) {
000A76  FA0008     LNK #0x8
000A78  980720     MOV W0, [W14+4]
000A7A  980731     MOV W1, [W14+6]
303:                   int i = 0;
000A7C  EB0200     CLR W4
000A7E  780F04     MOV W4, [W14]
304:                   int start = stringLength(destination);
000A80  90002E     MOV [W14+4], W0
000A82  07003E     RCALL stringLength
000A84  780200     MOV W0, W4
000A86  980714     MOV W4, [W14+2]
305:                   while (source[i] != 0) {
000A88  37000A     BRA 0xA9E
000A9E  78021E     MOV [W14], W4
000AA0  9002BE     MOV [W14+6], W5
000AA2  428204     ADD W5, W4, W4
000AA4  784214     MOV.B [W4], W4
000AA6  524FE0     SUB.B W4, #0x0, [W15]
000AA8  3AFFF0     BRA NZ, 0xA8A
306:                       destination[start + i] = source[i];
000A8A  90021E     MOV [W14+2], W4
000A8C  42021E     ADD W4, [W14], W4
000A8E  9002AE     MOV [W14+4], W5
000A90  428284     ADD W5, W4, W5
000A92  78021E     MOV [W14], W4
000A94  90033E     MOV [W14+6], W6
000A96  430204     ADD W6, W4, W4
000A98  784214     MOV.B [W4], W4
000A9A  784A84     MOV.B W4, [W5]
307:                       i++;
000A9C  E80F1E     INC [W14], [W14]
308:                   }
309:                   destination[start + i] = 0;
000AAA  90021E     MOV [W14+2], W4
000AAC  42021E     ADD W4, [W14], W4
000AAE  9002AE     MOV [W14+4], W5
000AB0  428284     ADD W5, W4, W5
000AB2  EB4200     CLR.B W4
000AB4  784A84     MOV.B W4, [W5]
310:               }
000AB6  FA8000     ULNK
311:               
312:               // Returns 1 if strings differ, because that is
313:               // the convention for comparison methods.
314:               char stringCompare(char* a, char* b) {
000ABA  FA0006     LNK #0x6
000ABC  980710     MOV W0, [W14+2]
000ABE  980721     MOV W1, [W14+4]
315:                   short i = 0;
000AC0  EB0200     CLR W4
000AC2  780F04     MOV W4, [W14]
316:                   while (a[i] != 0 && b[i] != 0) {
000AC4  37000D     BRA 0xAE0
000AE0  78021E     MOV [W14], W4
000AE2  90029E     MOV [W14+2], W5
000AE4  428204     ADD W5, W4, W4
000AE6  784214     MOV.B [W4], W4
000AE8  524FE0     SUB.B W4, #0x0, [W15]
000AEA  320006     BRA Z, 0xAF8
000AEC  78021E     MOV [W14], W4
000AEE  9002AE     MOV [W14+4], W5
000AF0  428204     ADD W5, W4, W4
000AF2  784214     MOV.B [W4], W4
000AF4  524FE0     SUB.B W4, #0x0, [W15]
000AF6  3AFFE7     BRA NZ, 0xAC6
317:                       if (a[i] != b[i])
000AC6  78021E     MOV [W14], W4
000AC8  90029E     MOV [W14+2], W5
000ACA  428204     ADD W5, W4, W4
000ACC  784294     MOV.B [W4], W5
000ACE  78021E     MOV [W14], W4
000AD0  90032E     MOV [W14+4], W6
000AD2  430204     ADD W6, W4, W4
000AD4  784214     MOV.B [W4], W4
000AD6  52CF84     SUB.B W5, W4, [W15]
000AD8  320002     BRA Z, 0xADE
318:                           return 1;
000ADA  B3C014     MOV.B #0x1, W4
000ADC  37000E     BRA 0xAFA
319:                       i++;
000ADE  E80F1E     INC [W14], [W14]
320:                   }
321:                   return 0;
000AF8  EB4200     CLR.B W4
322:               }
000AFA  784004     MOV.B W4, W0
323:               
324:               int stringLength(char* string) {
000B00  FA0004     LNK #0x4
000B02  980710     MOV W0, [W14+2]
325:                   int i = 0;
000B04  EB0200     CLR W4
000B06  780F04     MOV W4, [W14]
326:                   while (string[i++] != 0);
000B08  000000     NOP
000B0A  78021E     MOV [W14], W4
000B0C  90029E     MOV [W14+2], W5
000B0E  428204     ADD W5, W4, W4
000B10  784214     MOV.B [W4], W4
000B12  FB8204     ZE W4, W4
000B14  EA0204     NEG W4, W4
000B16  DE224F     LSR W4, #15, W4
000B18  784204     MOV.B W4, W4
000B1A  E80F1E     INC [W14], [W14]
000B1C  524FE0     SUB.B W4, #0x0, [W15]
000B1E  3AFFF5     BRA NZ, 0xB0A
327:                   return i - 1;
000B20  E9021E     DEC [W14], W4
328:               }
000B22  780004     MOV W4, W0
329:               
330:               void commandBuilder1(char* command, char* attribute, char* value) {
000B28  FA001A     LNK #0x1A
000B2A  980F20     MOV W0, [W14+20]
000B2C  980F31     MOV W1, [W14+22]
000B2E  980F42     MOV W2, [W14+24]
331:                   char newCommand[RECEIVE_PARAM_LENGTH] = "%";
000B30  200254     MOV #0x25, W4
000B32  200005     MOV #0x0, W5
000B34  BE8F04     MOV.D W4, [W14]
000B36  470264     ADD W14, #0x4, W4
000B38  090007     REPEAT #0x7
000B3A  EB1A00     CLR [W4++]
332:                   stringConcat(newCommand, command);
000B3C  9008AE     MOV [W14+20], W1
000B3E  78000E     MOV W14, W0
000B40  07FF9A     RCALL stringConcat
333:                   stringConcat(newCommand, " ");
000B42  2834C1     MOV #0x834C, W1
000B44  78000E     MOV W14, W0
000B46  07FF97     RCALL stringConcat
334:                   stringConcat(newCommand, attribute);
000B48  9008BE     MOV [W14+22], W1
000B4A  78000E     MOV W14, W0
000B4C  07FF94     RCALL stringConcat
335:                   stringConcat(newCommand, " ");
000B4E  2834C1     MOV #0x834C, W1
000B50  78000E     MOV W14, W0
000B52  07FF91     RCALL stringConcat
336:                   stringConcat(newCommand, value);
000B54  9008CE     MOV [W14+24], W1
000B56  78000E     MOV W14, W0
000B58  07FF8E     RCALL stringConcat
337:                   stringConcat(newCommand, ".\r\n");
000B5A  2834E1     MOV #0x834E, W1
000B5C  78000E     MOV W14, W0
000B5E  07FF8B     RCALL stringConcat
338:                   stringCopy(newCommand, sendBuffer());
000B60  07FEEE     RCALL sendBuffer
000B62  780200     MOV W0, W4
000B64  780084     MOV W4, W1
000B66  78000E     MOV W14, W0
000B68  07FF6A     RCALL stringCopy
339:               }
000B6A  FA8000     ULNK
340:               
341:               void commandBuilder2(char* command, char* attribute, char* value1, char* value2) {
000B6E  FA001C     LNK #0x1C
000B70  980F20     MOV W0, [W14+20]
000B72  980F31     MOV W1, [W14+22]
000B74  980F42     MOV W2, [W14+24]
000B76  980F53     MOV W3, [W14+26]
342:                   char newValue[RECEIVE_PARAM_LENGTH] = "";
000B78  B82260     MUL.UU W4, #0, W4
000B7A  BE8F04     MOV.D W4, [W14]
000B7C  470264     ADD W14, #0x4, W4
000B7E  090007     REPEAT #0x7
000B80  EB1A00     CLR [W4++]
343:                   stringConcat(newValue, value1);
000B82  9008CE     MOV [W14+24], W1
000B84  78000E     MOV W14, W0
000B86  07FF77     RCALL stringConcat
344:                   stringConcat(newValue, ":");
000B88  283521     MOV #0x8352, W1
000B8A  78000E     MOV W14, W0
000B8C  07FF74     RCALL stringConcat
345:                   stringConcat(newValue, value2);
000B8E  9008DE     MOV [W14+26], W1
000B90  78000E     MOV W14, W0
000B92  07FF71     RCALL stringConcat
346:                   commandBuilder1(command, attribute, newValue);
000B94  78010E     MOV W14, W2
000B96  9008BE     MOV [W14+22], W1
000B98  90082E     MOV [W14+20], W0
000B9A  07FFC6     RCALL commandBuilder1
347:               }
000B9C  FA8000     ULNK
348:               
349:               void commandBuilder3(char* command, char* attribute, char* value1, char* value2, char* value3) {
000BA0  FA001E     LNK #0x1E
000BA2  980F20     MOV W0, [W14+20]
000BA4  980F31     MOV W1, [W14+22]
000BA6  980F42     MOV W2, [W14+24]
000BA8  980F53     MOV W3, [W14+26]
000BAA  980F64     MOV W4, [W14+28]
350:                   char newValue[RECEIVE_PARAM_LENGTH] = "";
000BAC  B82260     MUL.UU W4, #0, W4
000BAE  BE8F04     MOV.D W4, [W14]
000BB0  470264     ADD W14, #0x4, W4
000BB2  090007     REPEAT #0x7
000BB4  EB1A00     CLR [W4++]
351:                   stringConcat(newValue, value2);
000BB6  9008DE     MOV [W14+26], W1
000BB8  78000E     MOV W14, W0
000BBA  07FF5D     RCALL stringConcat
352:                   stringConcat(newValue, ":");
000BBC  283521     MOV #0x8352, W1
000BBE  78000E     MOV W14, W0
000BC0  07FF5A     RCALL stringConcat
353:                   stringConcat(newValue, value3);
000BC2  9008EE     MOV [W14+28], W1
000BC4  78000E     MOV W14, W0
000BC6  07FF57     RCALL stringConcat
354:                   commandBuilder2(command, attribute, value1, newValue);
000BC8  78018E     MOV W14, W3
000BCA  90094E     MOV [W14+24], W2
000BCC  9008BE     MOV [W14+22], W1
000BCE  90082E     MOV [W14+20], W0
000BD0  07FFCE     RCALL commandBuilder2
355:               }
000BD2  FA8000     ULNK
356:               
357:               void commandBuilder4(char* command, char* attribute, char* value1, char* value2, char* value3, char* value4) {
000BD6  FA0020     LNK #0x20
000BD8  980F20     MOV W0, [W14+20]
000BDA  980F31     MOV W1, [W14+22]
000BDC  980F42     MOV W2, [W14+24]
000BDE  980F53     MOV W3, [W14+26]
000BE0  980F64     MOV W4, [W14+28]
000BE2  980F75     MOV W5, [W14+30]
358:                   char newValue[RECEIVE_PARAM_LENGTH] = "";
000BE4  B82260     MUL.UU W4, #0, W4
000BE6  BE8F04     MOV.D W4, [W14]
000BE8  470264     ADD W14, #0x4, W4
000BEA  090007     REPEAT #0x7
000BEC  EB1A00     CLR [W4++]
359:                   stringConcat(newValue, value3);
000BEE  9008EE     MOV [W14+28], W1
000BF0  78000E     MOV W14, W0
000BF2  07FF41     RCALL stringConcat
360:                   stringConcat(newValue, ":");
000BF4  283521     MOV #0x8352, W1
000BF6  78000E     MOV W14, W0
000BF8  07FF3E     RCALL stringConcat
361:                   stringConcat(newValue, value4);
000BFA  9008FE     MOV [W14+30], W1
000BFC  78000E     MOV W14, W0
000BFE  07FF3B     RCALL stringConcat
362:                   commandBuilder3(command, attribute, value1, value2, newValue);
000C00  78020E     MOV W14, W4
000C02  9009DE     MOV [W14+26], W3
000C04  90094E     MOV [W14+24], W2
000C06  9008BE     MOV [W14+22], W1
000C08  90082E     MOV [W14+20], W0
000C0A  07FFCA     RCALL commandBuilder3
363:               }
000C0C  FA8000     ULNK
364:               
365:               void commandBuilder5(char* command, char* attribute, char* value1, char* value2, char* value3, char* value4, char* value5) {
000C10  FA0022     LNK #0x22
000C12  980F20     MOV W0, [W14+20]
000C14  980F31     MOV W1, [W14+22]
000C16  980F42     MOV W2, [W14+24]
000C18  980F53     MOV W3, [W14+26]
000C1A  980F64     MOV W4, [W14+28]
000C1C  980F75     MOV W5, [W14+30]
000C1E  981706     MOV W6, [W14+32]
366:                   char newValue[RECEIVE_PARAM_LENGTH] = "";
000C20  B82260     MUL.UU W4, #0, W4
000C22  BE8F04     MOV.D W4, [W14]
000C24  470264     ADD W14, #0x4, W4
000C26  090007     REPEAT #0x7
000C28  EB1A00     CLR [W4++]
367:                   stringConcat(newValue, value4);
000C2A  9008FE     MOV [W14+30], W1
000C2C  78000E     MOV W14, W0
000C2E  07FF23     RCALL stringConcat
368:                   stringConcat(newValue, ":");
000C30  283521     MOV #0x8352, W1
000C32  78000E     MOV W14, W0
000C34  07FF20     RCALL stringConcat
369:                   stringConcat(newValue, value5);
000C36  90108E     MOV [W14+32], W1
000C38  78000E     MOV W14, W0
000C3A  07FF1D     RCALL stringConcat
370:                   commandBuilder4(command, attribute, value1, value2, value3, newValue);
000C3C  78028E     MOV W14, W5
000C3E  900A6E     MOV [W14+28], W4
000C40  9009DE     MOV [W14+26], W3
000C42  90094E     MOV [W14+24], W2
000C44  9008BE     MOV [W14+22], W1
000C46  90082E     MOV [W14+20], W0
000C48  07FFC6     RCALL commandBuilder4
371:               }
000C4A  FA8000     ULNK
372:               
373:               // Split combined value string on colon and return desired part
374:               char* commandExpander(char* values, char index) {
000C4E  FA000A     LNK #0xA
000C50  980730     MOV W0, [W14+6]
000C52  984F01     MOV.B W1, [W14+8]
375:                   static char returnValue[RECEIVE_PARAM_LENGTH] = "";
376:                   int i = 0;
000C54  EB0200     CLR W4
000C56  780F04     MOV W4, [W14]
377:                   int j = 0;
000C58  EB0200     CLR W4
000C5A  980714     MOV W4, [W14+2]
378:                   char delimCount = 0;
000C5C  EB4200     CLR.B W4
000C5E  984744     MOV.B W4, [W14+4]
379:               
380:                   while (delimCount < index && i < RECEIVE_PARAM_LENGTH)
000C60  370010     BRA 0xC82
000C82  9042CE     MOV.B [W14+4], W5
000C84  904A0E     MOV.B [W14+8], W4
000C86  52CF84     SUB.B W5, W4, [W15]
000C88  3D0011     BRA GE, 0xCAC
000C8A  78021E     MOV [W14], W4
000C8C  520FF3     SUB W4, #0x13, [W15]
000C8E  34FFE9     BRA LE, 0xC62
381:                       if (values[i++] == ':') delimCount++;
000C62  78021E     MOV [W14], W4
000C64  9002BE     MOV [W14+6], W5
000C66  428204     ADD W5, W4, W4
000C68  784294     MOV.B [W4], W5
000C6A  B3C3A4     MOV.B #0x3A, W4
000C6C  6AC204     XOR.B W5, W4, W4
000C6E  FB8204     ZE W4, W4
000C70  E90204     DEC W4, W4
000C72  DE224F     LSR W4, #15, W4
000C74  784204     MOV.B W4, W4
000C76  E80F1E     INC [W14], [W14]
000C78  524FE0     SUB.B W4, #0x0, [W15]
000C7A  320003     BRA Z, 0xC82
000C7C  90424E     MOV.B [W14+4], W4
000C7E  E84204     INC.B W4, W4
000C80  984744     MOV.B W4, [W14+4]
382:                   while (values[i] != ':' && values[i] != 0 && i < RECEIVE_PARAM_LENGTH)
000C90  37000E     BRA 0xCAE
000CAC  000000     NOP
000CAE  78021E     MOV [W14], W4
000CB0  9002BE     MOV [W14+6], W5
000CB2  428204     ADD W5, W4, W4
000CB4  784294     MOV.B [W4], W5
000CB6  B3C3A4     MOV.B #0x3A, W4
000CB8  52CF84     SUB.B W5, W4, [W15]
000CBA  320009     BRA Z, 0xCCE
000CBC  78021E     MOV [W14], W4
000CBE  9002BE     MOV [W14+6], W5
000CC0  428204     ADD W5, W4, W4
000CC2  784214     MOV.B [W4], W4
000CC4  524FE0     SUB.B W4, #0x0, [W15]
000CC6  320003     BRA Z, 0xCCE
000CC8  78021E     MOV [W14], W4
000CCA  520FF3     SUB W4, #0x13, [W15]
000CCC  34FFE2     BRA LE, 0xC92
383:                       returnValue[j++] = values[i++];
000C92  78021E     MOV [W14], W4
000C94  9002BE     MOV [W14+6], W5
000C96  428204     ADD W5, W4, W4
000C98  784214     MOV.B [W4], W4
000C9A  90031E     MOV [W14+2], W6
000C9C  20C0B5     MOV #0xC0B, W5
000C9E  430285     ADD W6, W5, W5
000CA0  784A84     MOV.B W4, [W5]
000CA2  90021E     MOV [W14+2], W4
000CA4  E80204     INC W4, W4
000CA6  980714     MOV W4, [W14+2]
000CA8  E80F1E     INC [W14], [W14]
000CAA  370001     BRA 0xCAE
384:               
385:                   returnValue[j] = 0;
000CCE  90029E     MOV [W14+2], W5
000CD0  20C0B4     MOV #0xC0B, W4
000CD2  428284     ADD W5, W4, W5
000CD4  EB4200     CLR.B W4
000CD6  784A84     MOV.B W4, [W5]
386:                   return returnValue;
000CD8  20C0B4     MOV #0xC0B, W4
387:               }
000CDA  780004     MOV W4, W0
388:               
389:               void processReceivedCommand() {
000CE0  FA0006     LNK #0x6
390:               
391:                   if (readyToProcess == 0) return;
000CE2  20A8E4     MOV #0xA8E, W4
000CE4  784214     MOV.B [W4], W4
000CE6  524FE0     SUB.B W4, #0x0, [W15]
000CE8  32024F     BRA Z, 0x1188
001188  000000     NOP
392:               
393:                   // Everything will be LOWERCASED when it is received
394:                   if (stringCompare(receivedCommand, "set") == 0) {
000CEA  283541     MOV #0x8354, W1
000CEC  20A480     MOV #0xA48, W0
000CEE  07FEE5     RCALL stringCompare
000CF0  784200     MOV.B W0, W4
000CF2  524FE0     SUB.B W4, #0x0, [W15]
000CF4  3A01D4     BRA NZ, 0x109E
395:                       if (stringCompare(receivedAttribute, "time") == 0) {
000CF6  283581     MOV #0x8358, W1
000CF8  20A5C0     MOV #0xA5C, W0
000CFA  07FEDF     RCALL stringCompare
000CFC  784200     MOV.B W0, W4
000CFE  524FE0     SUB.B W4, #0x0, [W15]
000D00  3A0061     BRA NZ, 0xDC4
396:                           char newYear   = (char) ((receivedValue[0]  - 48) * 10 + receivedValue[1]  - 48);
000D02  20A704     MOV #0xA70, W4
000D04  784214     MOV.B [W4], W4
000D06  FB0204     SE W4, W4
000D08  B10304     SUB #0x30, W4
000D0A  784204     MOV.B W4, W4
000D0C  B9226A     MUL.SU W4, #10, W4
000D0E  780204     MOV W4, W4
000D10  784284     MOV.B W4, W5
000D12  20A714     MOV #0xA71, W4
000D14  784214     MOV.B [W4], W4
000D16  42C284     ADD.B W5, W4, W5
000D18  B3CD04     MOV.B #0xD0, W4
000D1A  42C204     ADD.B W5, W4, W4
000D1C  784F04     MOV.B W4, [W14]
397:                           char newMonth  = (char) ((receivedValue[2]  - 48) * 10 + receivedValue[3]  - 48);
000D1E  20A724     MOV #0xA72, W4
000D20  784214     MOV.B [W4], W4
000D22  FB0204     SE W4, W4
000D24  B10304     SUB #0x30, W4
000D26  784204     MOV.B W4, W4
000D28  B9226A     MUL.SU W4, #10, W4
000D2A  780204     MOV W4, W4
000D2C  784284     MOV.B W4, W5
000D2E  20A734     MOV #0xA73, W4
000D30  784214     MOV.B [W4], W4
000D32  42C284     ADD.B W5, W4, W5
000D34  B3CD04     MOV.B #0xD0, W4
000D36  42C204     ADD.B W5, W4, W4
000D38  984714     MOV.B W4, [W14+1]
398:                           char newDay    = (char) ((receivedValue[4]  - 48) * 10 + receivedValue[5]  - 48);
000D3A  20A744     MOV #0xA74, W4
000D3C  784214     MOV.B [W4], W4
000D3E  FB0204     SE W4, W4
000D40  B10304     SUB #0x30, W4
000D42  784204     MOV.B W4, W4
000D44  B9226A     MUL.SU W4, #10, W4
000D46  780204     MOV W4, W4
000D48  784284     MOV.B W4, W5
000D4A  20A754     MOV #0xA75, W4
000D4C  784214     MOV.B [W4], W4
000D4E  42C284     ADD.B W5, W4, W5
000D50  B3CD04     MOV.B #0xD0, W4
000D52  42C204     ADD.B W5, W4, W4
000D54  984724     MOV.B W4, [W14+2]
399:                           char newHour   = (char) ((receivedValue[6]  - 48) * 10 + receivedValue[7]  - 48);
000D56  20A764     MOV #0xA76, W4
000D58  784214     MOV.B [W4], W4
000D5A  FB0204     SE W4, W4
000D5C  B10304     SUB #0x30, W4
000D5E  784204     MOV.B W4, W4
000D60  B9226A     MUL.SU W4, #10, W4
000D62  780204     MOV W4, W4
000D64  784284     MOV.B W4, W5
000D66  20A774     MOV #0xA77, W4
000D68  784214     MOV.B [W4], W4
000D6A  42C284     ADD.B W5, W4, W5
000D6C  B3CD04     MOV.B #0xD0, W4
000D6E  42C204     ADD.B W5, W4, W4
000D70  984734     MOV.B W4, [W14+3]
400:                           char newMinute = (char) ((receivedValue[8]  - 48) * 10 + receivedValue[9]  - 48);
000D72  20A784     MOV #0xA78, W4
000D74  784214     MOV.B [W4], W4
000D76  FB0204     SE W4, W4
000D78  B10304     SUB #0x30, W4
000D7A  784204     MOV.B W4, W4
000D7C  B9226A     MUL.SU W4, #10, W4
000D7E  780204     MOV W4, W4
000D80  784284     MOV.B W4, W5
000D82  20A794     MOV #0xA79, W4
000D84  784214     MOV.B [W4], W4
000D86  42C284     ADD.B W5, W4, W5
000D88  B3CD04     MOV.B #0xD0, W4
000D8A  42C204     ADD.B W5, W4, W4
000D8C  984744     MOV.B W4, [W14+4]
401:                           char newSecond = (char) ((receivedValue[10] - 48) * 10 + receivedValue[11] - 48);
000D8E  20A7A4     MOV #0xA7A, W4
000D90  784214     MOV.B [W4], W4
000D92  FB0204     SE W4, W4
000D94  B10304     SUB #0x30, W4
000D96  784204     MOV.B W4, W4
000D98  B9226A     MUL.SU W4, #10, W4
000D9A  780204     MOV W4, W4
000D9C  784284     MOV.B W4, W5
000D9E  20A7B4     MOV #0xA7B, W4
000DA0  784214     MOV.B [W4], W4
000DA2  42C284     ADD.B W5, W4, W5
000DA4  B3CD04     MOV.B #0xD0, W4
000DA6  42C204     ADD.B W5, W4, W4
000DA8  984754     MOV.B W4, [W14+5]
402:               #ifdef DISPLAY_BOX
403:                           writeTime(newYear, newMonth, newDay, newHour, newMinute, newSecond);
404:               #endif
405:               #ifdef POWER_BOX
406:                           setI2CTime(newYear, newMonth, newDay, newHour, newMinute, newSecond);
000DAA  9042DE     MOV.B [W14+5], W5
000DAC  90424E     MOV.B [W14+4], W4
000DAE  9040BE     MOV.B [W14+3], W1
000DB0  90402E     MOV.B [W14+2], W0
000DB2  90439E     MOV.B [W14+1], W7
000DB4  78431E     MOV.B [W14], W6
000DB6  784181     MOV.B W1, W3
000DB8  784100     MOV.B W0, W2
000DBA  784087     MOV.B W7, W1
000DBC  784006     MOV.B W6, W0
000DBE  070F40     RCALL setI2CTime
407:               #endif
408:                           readTime();
000DC0  070EF2     RCALL readTime
000DC2  3701DD     BRA 0x117E
409:                       }
410:                       else if (stringCompare(receivedAttribute, "power") == 0) {
000DC4  2835D1     MOV #0x835D, W1
000DC6  20A5C0     MOV #0xA5C, W0
000DC8  07FE78     RCALL stringCompare
000DCA  784200     MOV.B W0, W4
000DCC  524FE0     SUB.B W4, #0x0, [W15]
000DCE  3A0037     BRA NZ, 0xE3E
411:                           powerAllocated = atoi(commandExpander(receivedValue, 0));
000DD0  EB4080     CLR.B W1
000DD2  20A700     MOV #0xA70, W0
000DD4  07FF3C     RCALL commandExpander
000DD6  780200     MOV W0, W4
000DD8  780004     MOV W4, W0
000DDA  07FA71     RCALL _atoi
000DDC  780200     MOV W0, W4
000DDE  DEA2CF     ASR W4, #15, W5
000DE0  885C94     MOV W4, powerAllocated
000DE2  885CA5     MOV W5, 0xB94
412:                           powerUsed = atoi(commandExpander(receivedValue, 1));
000DE4  B3C011     MOV.B #0x1, W1
000DE6  20A700     MOV #0xA70, W0
000DE8  07FF32     RCALL commandExpander
000DEA  780200     MOV W0, W4
000DEC  780004     MOV W4, W0
000DEE  07FA67     RCALL _atoi
000DF0  780200     MOV W0, W4
000DF2  DEA2CF     ASR W4, #15, W5
000DF4  885C74     MOV W4, powerUsed
000DF6  885C85     MOV W5, 0xB90
413:                           currentLoad = atoi(commandExpander(receivedValue, 2));
000DF8  B3C021     MOV.B #0x2, W1
000DFA  20A700     MOV #0xA70, W0
000DFC  07FF28     RCALL commandExpander
000DFE  780200     MOV W0, W4
000E00  780004     MOV W4, W0
000E02  07FA5D     RCALL _atoi
000E04  780200     MOV W0, W4
000E06  DEA2CF     ASR W4, #15, W5
000E08  885CB4     MOV W4, currentLoad
000E0A  885CC5     MOV W5, 0xB98
414:               
415:               #ifdef POWER_BOX
416:                           highAlloc = powerAllocated;
000E0C  805C94     MOV powerAllocated, W4
000E0E  805CA5     MOV 0xB94, W5
000E10  884034     MOV W4, highAlloc
000E12  884045     MOV W5, 0x808
417:                           lowAlloc = (powerAllocated * 3) / 4;
000E14  805C94     MOV powerAllocated, W4
000E16  805CA5     MOV 0xB94, W5
000E18  B92B63     MUL.SU W5, #3, W6
000E1A  780306     MOV W6, W6
000E1C  B92060     MUL.SU W4, #0, W0
000E1E  780380     MOV W0, W7
000E20  430307     ADD W6, W7, W6
000E22  780284     MOV W4, W5
000E24  200034     MOV #0x3, W4
000E26  B82A04     MUL.UU W5, W4, W4
000E28  430305     ADD W6, W5, W6
000E2A  780286     MOV W6, W5
000E2C  DD2B4E     SL W5, #14, W6
000E2E  DE2242     LSR W4, #2, W4
000E30  730204     IOR W6, W4, W4
000E32  DE2AC2     LSR W5, #2, W5
000E34  884054     MOV W4, lowAlloc
000E36  884065     MOV W5, 0x80C
418:                           setHighLow();
000E38  0706DF     RCALL setHighLow
419:                           EEwritePowerAlloc();
000E3A  070813     RCALL EEwritePowerAlloc
000E3C  3701A0     BRA 0x117E
420:               #endif
421:                       }
422:                       else if (stringCompare(receivedAttribute, "alarm") == 0) {
000E3E  283631     MOV #0x8363, W1
000E40  20A5C0     MOV #0xA5C, W0
000E42  07FE3B     RCALL stringCompare
000E44  784200     MOV.B W0, W4
000E46  524FE0     SUB.B W4, #0x0, [W15]
000E48  3A0035     BRA NZ, 0xEB4
423:                           audibleAlarm    = (char) atoi(commandExpander(receivedValue, 0));
000E4A  EB4080     CLR.B W1
000E4C  20A700     MOV #0xA70, W0
000E4E  07FEFF     RCALL commandExpander
000E50  780200     MOV W0, W4
000E52  780004     MOV W4, W0
000E54  07FA34     RCALL _atoi
000E56  780200     MOV W0, W4
000E58  784204     MOV.B W4, W4
000E5A  780004     MOV W4, W0
000E5C  B7E826     MOV.B WREG, audibleAlarm
424:                           alarmOneEnabled = (char) atoi(commandExpander(receivedValue, 1));
000E5E  B3C011     MOV.B #0x1, W1
000E60  20A700     MOV #0xA70, W0
000E62  07FEF5     RCALL commandExpander
000E64  780200     MOV W0, W4
000E66  780004     MOV W4, W0
000E68  07FA2A     RCALL _atoi
000E6A  780200     MOV W0, W4
000E6C  784204     MOV.B W4, W4
000E6E  780004     MOV W4, W0
000E70  B7E829     MOV.B WREG, alarmOneEnabled
425:                           alarmTwoEnabled = (char) atoi(commandExpander(receivedValue, 2));
000E72  B3C021     MOV.B #0x2, W1
000E74  20A700     MOV #0xA70, W0
000E76  07FEEB     RCALL commandExpander
000E78  780200     MOV W0, W4
000E7A  780004     MOV W4, W0
000E7C  07FA20     RCALL _atoi
000E7E  780200     MOV W0, W4
000E80  784204     MOV.B W4, W4
000E82  780004     MOV W4, W0
000E84  B7E82A     MOV.B WREG, alarmTwoEnabled
426:                           alarmOnePower   = (char) atoi(commandExpander(receivedValue, 3));
000E86  B3C031     MOV.B #0x3, W1
000E88  20A700     MOV #0xA70, W0
000E8A  07FEE1     RCALL commandExpander
000E8C  780200     MOV W0, W4
000E8E  780004     MOV W4, W0
000E90  07FA16     RCALL _atoi
000E92  780200     MOV W0, W4
000E94  784204     MOV.B W4, W4
000E96  780004     MOV W4, W0
000E98  B7E827     MOV.B WREG, alarmOnePower
427:                           alarmTwoPower   = (char) atoi(commandExpander(receivedValue, 4));
000E9A  B3C041     MOV.B #0x4, W1
000E9C  20A700     MOV #0xA70, W0
000E9E  07FED7     RCALL commandExpander
000EA0  780200     MOV W0, W4
000EA2  780004     MOV W4, W0
000EA4  07FA0C     RCALL _atoi
000EA6  780200     MOV W0, W4
000EA8  784204     MOV.B W4, W4
000EAA  FD0200     EXCH W0, W4
000EAC  B7E828     MOV.B WREG, alarmTwoPower
000EAE  FD0200     EXCH W0, W4
428:               #ifdef POWER_BOX
429:                           EEwriteAlarm();
000EB0  0708D2     RCALL EEwriteAlarm
000EB2  370165     BRA 0x117E
430:               #endif
431:                       }
432:                       else if (stringCompare(receivedAttribute, "pwd") == 0) {
000EB4  283691     MOV #0x8369, W1
000EB6  20A5C0     MOV #0xA5C, W0
000EB8  07FE00     RCALL stringCompare
000EBA  784200     MOV.B W0, W4
000EBC  524FE0     SUB.B W4, #0x0, [W15]
000EBE  3A0020     BRA NZ, 0xF00
433:                           passwordSet[0] = receivedValue[0];
000EC0  20A704     MOV #0xA70, W4
000EC2  784214     MOV.B [W4], W4
000EC4  FD0200     EXCH W0, W4
000EC6  B7E81A     MOV.B WREG, passwordSet
000EC8  FD0200     EXCH W0, W4
434:                           passwordSet[1] = receivedValue[1];
000ECA  20A714     MOV #0xA71, W4
000ECC  784214     MOV.B [W4], W4
000ECE  FD0200     EXCH W0, W4
000ED0  B7E81B     MOV.B WREG, 0x81B
000ED2  FD0200     EXCH W0, W4
435:                           passwordSet[2] = receivedValue[2];
000ED4  20A724     MOV #0xA72, W4
000ED6  784214     MOV.B [W4], W4
000ED8  FD0200     EXCH W0, W4
000EDA  B7E81C     MOV.B WREG, 0x81C
000EDC  FD0200     EXCH W0, W4
436:                           passwordSet[3] = receivedValue[3];
000EDE  20A734     MOV #0xA73, W4
000EE0  784214     MOV.B [W4], W4
000EE2  FD0200     EXCH W0, W4
000EE4  B7E81D     MOV.B WREG, 0x81D
000EE6  FD0200     EXCH W0, W4
437:                           passwordSet[4] = receivedValue[4];
000EE8  20A744     MOV #0xA74, W4
000EEA  784214     MOV.B [W4], W4
000EEC  FD0200     EXCH W0, W4
000EEE  B7E81E     MOV.B WREG, 0x81E
000EF0  FD0200     EXCH W0, W4
438:                           passwordSet[5] = receivedValue[5];
000EF2  20A754     MOV #0xA75, W4
000EF4  784214     MOV.B [W4], W4
000EF6  FD0200     EXCH W0, W4
000EF8  B7E81F     MOV.B WREG, 0x81F
000EFA  FD0200     EXCH W0, W4
439:               #ifdef POWER_BOX
440:                           EEwritePassword();
000EFC  0706E6     RCALL EEwritePassword
000EFE  37013F     BRA 0x117E
441:               #endif
442:                       }
443:                       else if (stringCompare(receivedAttribute, "emer") == 0) {
000F00  2836D1     MOV #0x836D, W1
000F02  20A5C0     MOV #0xA5C, W0
000F04  07FDDA     RCALL stringCompare
000F06  784200     MOV.B W0, W4
000F08  524FE0     SUB.B W4, #0x0, [W15]
000F0A  3A0063     BRA NZ, 0xFD2
444:               
445:                           emerButtonEnable = (char) atoi(commandExpander(receivedValue, 0));
000F0C  EB4080     CLR.B W1
000F0E  20A700     MOV #0xA70, W0
000F10  07FE9E     RCALL commandExpander
000F12  780200     MOV W0, W4
000F14  780004     MOV W4, W0
000F16  07F9D3     RCALL _atoi
000F18  780200     MOV W0, W4
000F1A  784204     MOV.B W4, W4
000F1C  780004     MOV W4, W0
000F1E  B7E823     MOV.B WREG, emerButtonEnable
446:                           emerButtonAlloc  = atoi(commandExpander(receivedValue, 1));
000F20  B3C011     MOV.B #0x1, W1
000F22  20A700     MOV #0xA70, W0
000F24  07FE94     RCALL commandExpander
000F26  780200     MOV W0, W4
000F28  780004     MOV W4, W0
000F2A  07F9C9     RCALL _atoi
000F2C  780200     MOV W0, W4
000F2E  884124     MOV W4, emerButtonAlloc
447:               
448:               #ifdef POWER_BOX
449:                           emerAllocNow     = atoi(commandExpander(receivedValue, 2));
000F30  B3C021     MOV.B #0x2, W1
000F32  20A700     MOV #0xA70, W0
000F34  07FE8C     RCALL commandExpander
000F36  780200     MOV W0, W4
000F38  780004     MOV W4, W0
000F3A  07F9C1     RCALL _atoi
000F3C  780200     MOV W0, W4
000F3E  8854A4     MOV W4, emerAllocNow
450:               
451:                           if (powerUsedMW / 1000 > emerAllocNow) {
000F40  8041A4     MOV powerUsedMW, W4
000F42  8041B5     MOV 0x836, W5
000F44  203E82     MOV #0x3E8, W2
000F46  200003     MOV #0x0, W3
000F48  BE0004     MOV.D W4, W0
000F4A  07F9A9     RCALL ___udivsi3
000F4C  BE0200     MOV.D W0, W4
000F4E  BE0304     MOV.D W4, W6
000F50  8054A4     MOV emerAllocNow, W4
000F52  DEA2CF     ASR W4, #15, W5
000F54  530F84     SUB W6, W4, [W15]
000F56  5B8F85     SUBB W7, W5, [W15]
000F58  36001F     BRA LEU, 0xF98
452:                               LATAbits.LATA3 = 0;
000F5A  A962C4     BCLR LATA, #3
453:                               powerUsedMW = powerUsedMW - ((long) emerAllocNow) * 1000;
000F5C  8054A4     MOV emerAllocNow, W4
000F5E  DEA2CF     ASR W4, #15, W5
000F60  2FC186     MOV #0xFC18, W6
000F62  B9AB06     MUL.SS W5, W6, W6
000F64  780306     MOV W6, W6
000F66  EB8380     SETM W7
000F68  B9A007     MUL.SS W4, W7, W0
000F6A  780380     MOV W0, W7
000F6C  430307     ADD W6, W7, W6
000F6E  780284     MOV W4, W5
000F70  2FC184     MOV #0xFC18, W4
000F72  B82A04     MUL.UU W5, W4, W4
000F74  430305     ADD W6, W5, W6
000F76  780286     MOV W6, W5
000F78  BE0304     MOV.D W4, W6
000F7A  8041A4     MOV powerUsedMW, W4
000F7C  8041B5     MOV 0x836, W5
000F7E  420206     ADD W4, W6, W4
000F80  4A8287     ADDC W5, W7, W5
000F82  8841A4     MOV W4, powerUsedMW
000F84  8841B5     MOV W5, 0x836
454:                               extraPower += emerAllocNow;
000F86  8054A4     MOV emerAllocNow, W4
000F88  B92361     MUL.SU W4, #1, W6
000F8A  806024     MOV extraPower, W4
000F8C  806035     MOV 0xC06, W5
000F8E  420206     ADD W4, W6, W4
000F90  4A8287     ADDC W5, W7, W5
000F92  886024     MOV W4, extraPower
000F94  886035     MOV W5, 0xC06
000F96  37001B     BRA 0xFCE
455:                           }
456:                           else {
457:                               if (emerAllocNow) {
000F98  8054A4     MOV emerAllocNow, W4
000F9A  520FE0     SUB W4, #0x0, [W15]
000F9C  320012     BRA Z, 0xFC2
458:                                   extraPower += (powerUsed / 1000) - powerAllocated;
000F9E  805C74     MOV powerUsed, W4
000FA0  805C85     MOV 0xB90, W5
000FA2  203E82     MOV #0x3E8, W2
000FA4  200003     MOV #0x0, W3
000FA6  BE0004     MOV.D W4, W0
000FA8  07F97A     RCALL ___udivsi3
000FAA  BE0200     MOV.D W0, W4
000FAC  BE0304     MOV.D W4, W6
000FAE  805C94     MOV powerAllocated, W4
000FB0  805CA5     MOV 0xB94, W5
000FB2  530304     SUB W6, W4, W6
000FB4  5B8385     SUBB W7, W5, W7
000FB6  806024     MOV extraPower, W4
000FB8  806035     MOV 0xC06, W5
000FBA  420206     ADD W4, W6, W4
000FBC  4A8287     ADDC W5, W7, W5
000FBE  886024     MOV W4, extraPower
000FC0  886035     MOV W5, 0xC06
459:                                   // Tommmy and I are a bit iffy about powerUsed
460:                                   // we think it maybe shoudl be powerUsedMW
461:                               }
462:               
463:                               powerUsedMW = 0;
000FC2  B82260     MUL.UU W4, #0, W4
000FC4  8841A4     MOV W4, powerUsedMW
000FC6  8841B5     MOV W5, 0x836
464:                               powerUsed = 0; // Adding this fixed the Emergency Now problem
000FC8  B82260     MUL.UU W4, #0, W4
000FCA  885C74     MOV W4, powerUsed
000FCC  885C85     MOV W5, 0xB90
465:                           }
466:               
467:                           EEwriteEmerButton();
000FCE  07078D     RCALL EEwriteEmerButton
000FD0  3700D6     BRA 0x117E
468:               #endif
469:                       }
470:               #ifdef DISPLAY_BOX
471:                       else if (stringCompare(receivedAttribute, "vers") == 0) {
472:                           stringCopy(receivedValue, powerBoxCodeVersionString);
473:                       }
474:                       else if (stringCompare(receivedAttribute, "pwrdowntime") == 0) {
475:                           stringCopy(receivedValue, powerDownTime);
476:                       }
477:                       else if (stringCompare(receivedAttribute, "pwruptime") == 0) {
478:                           stringCopy(receivedValue, powerUpTime);
479:                       }
480:               #endif
481:                       else if (stringCompare(receivedAttribute, "reset") == 0) {
000FD2  283721     MOV #0x8372, W1
000FD4  20A5C0     MOV #0xA5C, W0
000FD6  07FD71     RCALL stringCompare
000FD8  784200     MOV.B W0, W4
000FDA  524FE0     SUB.B W4, #0x0, [W15]
000FDC  3A0017     BRA NZ, 0x100C
482:                           resetHour   = (unsigned char) atoi(commandExpander(receivedValue, 0));
000FDE  EB4080     CLR.B W1
000FE0  20A700     MOV #0xA70, W0
000FE2  07FE35     RCALL commandExpander
000FE4  780200     MOV W0, W4
000FE6  780004     MOV W4, W0
000FE8  07F96A     RCALL _atoi
000FEA  780200     MOV W0, W4
000FEC  784204     MOV.B W4, W4
000FEE  780004     MOV W4, W0
000FF0  B7E803     MOV.B WREG, resetHour
483:                           resetMinute = (unsigned char) atoi(commandExpander(receivedValue, 1));
000FF2  B3C011     MOV.B #0x1, W1
000FF4  20A700     MOV #0xA70, W0
000FF6  07FE2B     RCALL commandExpander
000FF8  780200     MOV W0, W4
000FFA  780004     MOV W4, W0
000FFC  07F960     RCALL _atoi
000FFE  780200     MOV W0, W4
001000  784204     MOV.B W4, W4
001002  FD0200     EXCH W0, W4
001004  B7E804     MOV.B WREG, resetMinute
001006  FD0200     EXCH W0, W4
484:               #ifdef POWER_BOX
485:                           EEwriteResetTime();
001008  0707B3     RCALL EEwriteResetTime
00100A  3700B9     BRA 0x117E
486:               #endif
487:                       }
488:               
489:                       else if (stringCompare(receivedAttribute, "relay") == 0) {
00100C  283781     MOV #0x8378, W1
00100E  20A5C0     MOV #0xA5C, W0
001010  07FD54     RCALL stringCompare
001012  784200     MOV.B W0, W4
001014  524FE0     SUB.B W4, #0x0, [W15]
001016  3A0010     BRA NZ, 0x1038
490:                           // ON means relay control is on
491:                           // OFF means control is off
492:                           if (receivedValue[0] == 'f')
001018  20A705     MOV #0xA70, W5
00101A  784295     MOV.B [W5], W5
00101C  B3C664     MOV.B #0x66, W4
00101E  52CF84     SUB.B W5, W4, [W15]
001020  3A0005     BRA NZ, 0x102C
493:                               relayActive = 0;
001022  EB4200     CLR.B W4
001024  FD0200     EXCH W0, W4
001026  B7E80F     MOV.B WREG, relayActive
001028  FD0200     EXCH W0, W4
00102A  370004     BRA 0x1034
494:                           else
495:                               relayActive = 0xFF;
00102C  EBC200     SETM.B W4
00102E  FD0200     EXCH W0, W4
001030  B7E80F     MOV.B WREG, relayActive
001032  FD0200     EXCH W0, W4
496:               
497:               #ifdef POWER_BOX
498:                           EEwriteRelay();
001034  070D06     RCALL EEwriteRelay
001036  3700A3     BRA 0x117E
499:               #endif
500:                       }
501:               
502:                       else if (stringCompare(receivedAttribute, "stat") == 0) {
001038  2837E1     MOV #0x837E, W1
00103A  20A5C0     MOV #0xA5C, W0
00103C  07FD3E     RCALL stringCompare
00103E  784200     MOV.B W0, W4
001040  524FE0     SUB.B W4, #0x0, [W15]
001042  3A0015     BRA NZ, 0x106E
503:                           totalUsed = atoi(commandExpander(receivedValue, 0));
001044  EB4080     CLR.B W1
001046  20A700     MOV #0xA70, W0
001048  07FE02     RCALL commandExpander
00104A  780200     MOV W0, W4
00104C  780004     MOV W4, W0
00104E  07F937     RCALL _atoi
001050  780200     MOV W0, W4
001052  DEA2CF     ASR W4, #15, W5
001054  884084     MOV W4, totalUsed
001056  884095     MOV W5, 0x812
504:                           previousDayUsed = atoi(commandExpander(receivedValue, 1));
001058  B3C011     MOV.B #0x1, W1
00105A  20A700     MOV #0xA70, W0
00105C  07FDF8     RCALL commandExpander
00105E  780200     MOV W0, W4
001060  780004     MOV W4, W0
001062  07F92D     RCALL _atoi
001064  780200     MOV W0, W4
001066  DEA2CF     ASR W4, #15, W5
001068  8840A4     MOV W4, previousDayUsed
00106A  8840B5     MOV W5, 0x816
00106C  370088     BRA 0x117E
505:               
506:                       }
507:                       else if (stringCompare(receivedAttribute, "hl") == 0) {
00106E  283831     MOV #0x8383, W1
001070  20A5C0     MOV #0xA5C, W0
001072  07FD23     RCALL stringCompare
001074  784200     MOV.B W0, W4
001076  524FE0     SUB.B W4, #0x0, [W15]
001078  3A0082     BRA NZ, 0x117E
508:                           if (stringCompare(receivedValue, "high") == 0)
00107A  283861     MOV #0x8386, W1
00107C  20A700     MOV #0xA70, W0
00107E  07FD1D     RCALL stringCompare
001080  784200     MOV.B W0, W4
001082  524FE0     SUB.B W4, #0x0, [W15]
001084  3A0005     BRA NZ, 0x1090
509:                               isHigh = 0xFF;
001086  EBC200     SETM.B W4
001088  FD0200     EXCH W0, W4
00108A  B7E80E     MOV.B WREG, isHigh
00108C  FD0200     EXCH W0, W4
00108E  370004     BRA 0x1098
510:                           else
511:                               isHigh = 0;
001090  EB4200     CLR.B W4
001092  FD0200     EXCH W0, W4
001094  B7E80E     MOV.B WREG, isHigh
001096  FD0200     EXCH W0, W4
512:               #ifdef POWER_BOX
513:                           EEwriteHL();
001098  070C9E     RCALL EEwriteHL
514:                           setHighLow();
00109A  0705AE     RCALL setHighLow
00109C  370070     BRA 0x117E
515:               #endif
516:                       }
517:                   }
518:                   
519:               #ifdef POWER_BOX
520:                   // Everything will be LOWERCASED when it is received
521:                   else if (stringCompare(receivedCommand, "update") == 0) {
00109E  2838B1     MOV #0x838B, W1
0010A0  20A480     MOV #0xA48, W0
0010A2  07FD0B     RCALL stringCompare
0010A4  784200     MOV.B W0, W4
0010A6  524FE0     SUB.B W4, #0x0, [W15]
0010A8  3A0002     BRA NZ, 0x10AE
522:                       setRemotePower();
0010AA  0700F9     RCALL setRemotePower
0010AC  370068     BRA 0x117E
523:                   }
524:               
525:                   // Everything will be LOWERCASED when it is received
526:                   else if (stringCompare(receivedCommand, "reset") == 0) {
0010AE  283721     MOV #0x8372, W1
0010B0  20A480     MOV #0xA48, W0
0010B2  07FD03     RCALL stringCompare
0010B4  784200     MOV.B W0, W4
0010B6  524FE0     SUB.B W4, #0x0, [W15]
0010B8  3A0005     BRA NZ, 0x10C4
527:                       reset = 0xFF;
0010BA  EBC200     SETM.B W4
0010BC  FD0200     EXCH W0, W4
0010BE  B7EC08     MOV.B WREG, reset
0010C0  FD0200     EXCH W0, W4
0010C2  37005D     BRA 0x117E
528:                   }
529:               #endif
530:               
531:                   // Everything will be LOWERCASED when it is received
532:                   else if (stringCompare(receivedCommand, "read") == 0) {
0010C4  283921     MOV #0x8392, W1
0010C6  20A480     MOV #0xA48, W0
0010C8  07FCF8     RCALL stringCompare
0010CA  784200     MOV.B W0, W4
0010CC  524FE0     SUB.B W4, #0x0, [W15]
0010CE  3A0057     BRA NZ, 0x117E
533:                       if (stringCompare(receivedAttribute, "time") == 0) {
0010D0  283581     MOV #0x8358, W1
0010D2  20A5C0     MOV #0xA5C, W0
0010D4  07FCF2     RCALL stringCompare
0010D6  784200     MOV.B W0, W4
0010D8  524FE0     SUB.B W4, #0x0, [W15]
0010DA  3A0002     BRA NZ, 0x10E0
534:                           setRemoteTime();
0010DC  070058     RCALL setRemoteTime
0010DE  37004F     BRA 0x117E
535:                       }
536:                       else if (stringCompare(receivedAttribute, "power") == 0) {
0010E0  2835D1     MOV #0x835D, W1
0010E2  20A5C0     MOV #0xA5C, W0
0010E4  07FCEA     RCALL stringCompare
0010E6  784200     MOV.B W0, W4
0010E8  524FE0     SUB.B W4, #0x0, [W15]
0010EA  3A0002     BRA NZ, 0x10F0
537:                           setRemotePower();
0010EC  0700D8     RCALL setRemotePower
0010EE  370047     BRA 0x117E
538:                       }
539:                       else if (stringCompare(receivedAttribute, "alarm") == 0) {
0010F0  283631     MOV #0x8363, W1
0010F2  20A5C0     MOV #0xA5C, W0
0010F4  07FCE2     RCALL stringCompare
0010F6  784200     MOV.B W0, W4
0010F8  524FE0     SUB.B W4, #0x0, [W15]
0010FA  3A0002     BRA NZ, 0x1100
540:                           setRemoteAlarm();
0010FC  0700F1     RCALL setRemoteAlarm
0010FE  37003F     BRA 0x117E
541:                       }
542:                       else if (stringCompare(receivedAttribute, "pwd") == 0) {
001100  283691     MOV #0x8369, W1
001102  20A5C0     MOV #0xA5C, W0
001104  07FCDA     RCALL stringCompare
001106  784200     MOV.B W0, W4
001108  524FE0     SUB.B W4, #0x0, [W15]
00110A  3A0002     BRA NZ, 0x1110
543:                           setRemotePassword();
00110C  070121     RCALL setRemotePassword
00110E  370037     BRA 0x117E
544:                       }
545:                       else if (stringCompare(receivedAttribute, "emer") == 0) {
001110  2836D1     MOV #0x836D, W1
001112  20A5C0     MOV #0xA5C, W0
001114  07FCD2     RCALL stringCompare
001116  784200     MOV.B W0, W4
001118  524FE0     SUB.B W4, #0x0, [W15]
00111A  3A0002     BRA NZ, 0x1120
546:                           setRemoteEmergency();
00111C  070130     RCALL setRemoteEmergency
00111E  37002F     BRA 0x117E
547:                       }
548:               #ifdef POWER_BOX
549:                       else if (stringCompare(receivedAttribute, "vers") == 0) {
001120  283971     MOV #0x8397, W1
001122  20A5C0     MOV #0xA5C, W0
001124  07FCCA     RCALL stringCompare
001126  784200     MOV.B W0, W4
001128  524FE0     SUB.B W4, #0x0, [W15]
00112A  3A0002     BRA NZ, 0x1130
550:                           setRemoteVersion();
00112C  070148     RCALL setRemoteVersion
00112E  370027     BRA 0x117E
551:                       }
552:                       else if (stringCompare(receivedAttribute, "pwrfail") == 0) {
001130  2839C1     MOV #0x839C, W1
001132  20A5C0     MOV #0xA5C, W0
001134  07FCC2     RCALL stringCompare
001136  784200     MOV.B W0, W4
001138  524FE0     SUB.B W4, #0x0, [W15]
00113A  3A0002     BRA NZ, 0x1140
553:                           setRemotePowerDownUpTime();
00113C  0701C4     RCALL setRemotePowerDownUpTime
00113E  37001F     BRA 0x117E
554:                       }
555:               #endif
556:                       else if (stringCompare(receivedAttribute, "reset") == 0) {
001140  283721     MOV #0x8372, W1
001142  20A5C0     MOV #0xA5C, W0
001144  07FCBA     RCALL stringCompare
001146  784200     MOV.B W0, W4
001148  524FE0     SUB.B W4, #0x0, [W15]
00114A  3A0002     BRA NZ, 0x1150
557:                           setRemoteResetTime();
00114C  0701C7     RCALL setRemoteResetTime
00114E  370017     BRA 0x117E
558:                       }
559:                       else if (stringCompare(receivedAttribute, "relay") == 0) {
001150  283781     MOV #0x8378, W1
001152  20A5C0     MOV #0xA5C, W0
001154  07FCB2     RCALL stringCompare
001156  784200     MOV.B W0, W4
001158  524FE0     SUB.B W4, #0x0, [W15]
00115A  3A0002     BRA NZ, 0x1160
560:                           setRemoteRelay();
00115C  0701D9     RCALL setRemoteRelay
00115E  37000F     BRA 0x117E
561:                       }
562:                       else if (stringCompare(receivedAttribute, "stat") == 0) {
001160  2837E1     MOV #0x837E, W1
001162  20A5C0     MOV #0xA5C, W0
001164  07FCAA     RCALL stringCompare
001166  784200     MOV.B W0, W4
001168  524FE0     SUB.B W4, #0x0, [W15]
00116A  3A0002     BRA NZ, 0x1170
563:                           setRemoteStats();
00116C  0701E1     RCALL setRemoteStats
00116E  370007     BRA 0x117E
564:                       }
565:                       else if (stringCompare(receivedAttribute, "hl") == 0) {
001170  283831     MOV #0x8383, W1
001172  20A5C0     MOV #0xA5C, W0
001174  07FCA2     RCALL stringCompare
001176  784200     MOV.B W0, W4
001178  524FE0     SUB.B W4, #0x0, [W15]
00117A  3A0001     BRA NZ, 0x117E
566:                           setRemoteHL();
00117C  0701F8     RCALL setRemoteHL
567:                       }
568:                   }
569:               #ifdef DISPLAY_BOX
570:                   else if (stringCompare(receivedCommand, "reboot") == 0) {
571:                       BACKLIGHT = 1;
572:                       writeToDisplay("Power control system  has requested a     system restart.", 0, 80);
573:                       delayMS(2500);
574:                       asm("GOTO 0");
575:                       return;
576:                   }
577:               #endif
578:               
579:                   readyToProcess = 0;
00117E  EB4200     CLR.B W4
001180  FD0200     EXCH W0, W4
001182  B7EA8E     MOV.B WREG, readyToProcess
001184  FD0200     EXCH W0, W4
001186  370001     BRA 0x118A
580:               
581:               }
00118A  FA8000     ULNK
582:               
583:               /* Set commands **************************************************************/
584:               /* The space (' ') and period ('.') characters are reserved for delimiters.
585:                * Valid characters for use within commands are ASCII 0x30 ('0') through
586:                * 0x7e ('~'). Any character outside that set will be discarded. All alphabetic
587:                * characters will be converted to lowercase at receive time.
588:                */
589:               
590:               
591:               void setRemoteTime(void) {
00118E  FA000E     LNK #0xE
592:               
593:                   readTime();
001190  070D0A     RCALL readTime
594:               
595:               //    char newTime[11] = "";
596:                   char newTime[13] = "";
001192  B82260     MUL.UU W4, #0, W4
001194  BE8F04     MOV.D W4, [W14]
001196  470064     ADD W14, #0x4, W0
001198  090003     REPEAT #0x3
00119A  EB1800     CLR [W0++]
00119C  EB5800     CLR.B [W0++]
597:                   newTime[0]  = (timeYear / 10) + 0x30;
00119E  208204     MOV #0x820, W4
0011A0  784214     MOV.B [W4], W4
0011A2  FB8284     ZE W4, W5
0011A4  2000A4     MOV #0xA, W4
0011A6  090011     REPEAT #0x11
0011A8  D88284     DIV.UW W5, W4
0011AA  780200     MOV W0, W4
0011AC  784204     MOV.B W4, W4
0011AE  B04304     ADD.B #0x30, W4
0011B0  784F04     MOV.B W4, [W14]
598:                   newTime[1]  = (timeYear % 10) + 0x30;
0011B2  208204     MOV #0x820, W4
0011B4  784214     MOV.B [W4], W4
0011B6  FB8284     ZE W4, W5
0011B8  2000A4     MOV #0xA, W4
0011BA  090011     REPEAT #0x11
0011BC  D88284     DIV.UW W5, W4
0011BE  780201     MOV W1, W4
0011C0  784204     MOV.B W4, W4
0011C2  B04304     ADD.B #0x30, W4
0011C4  984714     MOV.B W4, [W14+1]
599:                   newTime[2]  = (timeMonth / 10) + 0x30;
0011C6  208214     MOV #0x821, W4
0011C8  784214     MOV.B [W4], W4
0011CA  FB8284     ZE W4, W5
0011CC  2000A4     MOV #0xA, W4
0011CE  090011     REPEAT #0x11
0011D0  D88284     DIV.UW W5, W4
0011D2  780200     MOV W0, W4
0011D4  784204     MOV.B W4, W4
0011D6  B04304     ADD.B #0x30, W4
0011D8  984724     MOV.B W4, [W14+2]
600:                   newTime[3]  = (timeMonth % 10) + 0x30;
0011DA  208214     MOV #0x821, W4
0011DC  784214     MOV.B [W4], W4
0011DE  FB8284     ZE W4, W5
0011E0  2000A4     MOV #0xA, W4
0011E2  090011     REPEAT #0x11
0011E4  D88284     DIV.UW W5, W4
0011E6  780201     MOV W1, W4
0011E8  784204     MOV.B W4, W4
0011EA  B04304     ADD.B #0x30, W4
0011EC  984734     MOV.B W4, [W14+3]
601:                   newTime[4]  = (timeDay / 10) + 0x30;
0011EE  208224     MOV #0x822, W4
0011F0  784214     MOV.B [W4], W4
0011F2  FB8284     ZE W4, W5
0011F4  2000A4     MOV #0xA, W4
0011F6  090011     REPEAT #0x11
0011F8  D88284     DIV.UW W5, W4
0011FA  780200     MOV W0, W4
0011FC  784204     MOV.B W4, W4
0011FE  B04304     ADD.B #0x30, W4
001200  984744     MOV.B W4, [W14+4]
602:                   newTime[5]  = (timeDay % 10) + 0x30;
001202  208224     MOV #0x822, W4
001204  784214     MOV.B [W4], W4
001206  FB8284     ZE W4, W5
001208  2000A4     MOV #0xA, W4
00120A  090011     REPEAT #0x11
00120C  D88284     DIV.UW W5, W4
00120E  780201     MOV W1, W4
001210  784204     MOV.B W4, W4
001212  B04304     ADD.B #0x30, W4
001214  984754     MOV.B W4, [W14+5]
603:                   newTime[6]  = (timeHour / 10) + 0x30;
001216  20B6D4     MOV #0xB6D, W4
001218  784214     MOV.B [W4], W4
00121A  FB8284     ZE W4, W5
00121C  2000A4     MOV #0xA, W4
00121E  090011     REPEAT #0x11
001220  D88284     DIV.UW W5, W4
001222  780200     MOV W0, W4
001224  784204     MOV.B W4, W4
001226  B04304     ADD.B #0x30, W4
001228  984764     MOV.B W4, [W14+6]
604:                   newTime[7]  = (timeHour % 10) + 0x30;
00122A  20B6D4     MOV #0xB6D, W4
00122C  784214     MOV.B [W4], W4
00122E  FB8284     ZE W4, W5
001230  2000A4     MOV #0xA, W4
001232  090011     REPEAT #0x11
001234  D88284     DIV.UW W5, W4
001236  780201     MOV W1, W4
001238  784204     MOV.B W4, W4
00123A  B04304     ADD.B #0x30, W4
00123C  984774     MOV.B W4, [W14+7]
605:                   newTime[8]  = (timeMinute / 10) + 0x30;
00123E  20B6E4     MOV #0xB6E, W4
001240  784214     MOV.B [W4], W4
001242  FB8284     ZE W4, W5
001244  2000A4     MOV #0xA, W4
001246  090011     REPEAT #0x11
001248  D88284     DIV.UW W5, W4
00124A  780200     MOV W0, W4
00124C  784204     MOV.B W4, W4
00124E  B04304     ADD.B #0x30, W4
001250  984F04     MOV.B W4, [W14+8]
606:                   newTime[9]  = (timeMinute % 10) + 0x30;
001252  20B6E4     MOV #0xB6E, W4
001254  784214     MOV.B [W4], W4
001256  FB8284     ZE W4, W5
001258  2000A4     MOV #0xA, W4
00125A  090011     REPEAT #0x11
00125C  D88284     DIV.UW W5, W4
00125E  780201     MOV W1, W4
001260  784204     MOV.B W4, W4
001262  B04304     ADD.B #0x30, W4
001264  984F14     MOV.B W4, [W14+9]
607:                   newTime[10] = (timeSecond / 10) + 0x30;
001266  208054     MOV #0x805, W4
001268  784214     MOV.B [W4], W4
00126A  FB8284     ZE W4, W5
00126C  2000A4     MOV #0xA, W4
00126E  090011     REPEAT #0x11
001270  D88284     DIV.UW W5, W4
001272  780200     MOV W0, W4
001274  784204     MOV.B W4, W4
001276  B04304     ADD.B #0x30, W4
001278  984F24     MOV.B W4, [W14+10]
608:                   newTime[11] = (timeSecond % 10) + 0x30;
00127A  208054     MOV #0x805, W4
00127C  784214     MOV.B [W4], W4
00127E  FB8284     ZE W4, W5
001280  2000A4     MOV #0xA, W4
001282  090011     REPEAT #0x11
001284  D88284     DIV.UW W5, W4
001286  780201     MOV W1, W4
001288  784204     MOV.B W4, W4
00128A  B04304     ADD.B #0x30, W4
00128C  984F34     MOV.B W4, [W14+11]
609:                   newTime[12] = 0;
00128E  EB4200     CLR.B W4
001290  984F44     MOV.B W4, [W14+12]
610:               
611:                   commandBuilder1("Set", "Time", newTime);
001292  78010E     MOV W14, W2
001294  283A41     MOV #0x83A4, W1
001296  283A90     MOV #0x83A9, W0
001298  07FC47     RCALL commandBuilder1
612:               
613:               }
00129A  FA8000     ULNK
614:               
615:               void setRemotePower(void) {
00129E  FA0010     LNK #0x10
616:               
617:                   char newPowerAllocated[5];
618:                   utoa(newPowerAllocated, (unsigned int) powerAllocated, 10);
0012A0  805C94     MOV powerAllocated, W4
0012A2  805CA5     MOV 0xB94, W5
0012A4  780204     MOV W4, W4
0012A6  2000A2     MOV #0xA, W2
0012A8  780084     MOV W4, W1
0012AA  78000E     MOV W14, W0
0012AC  07F827     RCALL _utoa
619:               
620:                   char newPowerUsed[5];
621:                   utoa(newPowerUsed, (unsigned int) powerUsed, 10);
0012AE  805C74     MOV powerUsed, W4
0012B0  805C85     MOV 0xB90, W5
0012B2  780284     MOV W4, W5
0012B4  470265     ADD W14, #0x5, W4
0012B6  2000A2     MOV #0xA, W2
0012B8  780085     MOV W5, W1
0012BA  780004     MOV W4, W0
0012BC  07F81F     RCALL _utoa
622:               
623:                   char newCurrentLoad[5];
624:                   utoa(newCurrentLoad, (unsigned int) currentLoad, 10);
0012BE  805CB4     MOV currentLoad, W4
0012C0  805CC5     MOV 0xB98, W5
0012C2  780284     MOV W4, W5
0012C4  47026A     ADD W14, #0xA, W4
0012C6  2000A2     MOV #0xA, W2
0012C8  780085     MOV W5, W1
0012CA  780004     MOV W4, W0
0012CC  07F817     RCALL _utoa
625:               
626:                   commandBuilder3("Set", "Power", newPowerAllocated,
0012CE  47026A     ADD W14, #0xA, W4
0012D0  4702E5     ADD W14, #0x5, W5
0012D2  780185     MOV W5, W3
0012D4  78010E     MOV W14, W2
0012D6  283AD1     MOV #0x83AD, W1
0012D8  283A90     MOV #0x83A9, W0
0012DA  07FC62     RCALL commandBuilder3
627:                           newPowerUsed, newCurrentLoad);
628:               }
0012DC  FA8000     ULNK
629:               
630:               void setRemoteAlarm(void) {
0012E0  FA000A     LNK #0xA
631:                   char* newAudibleAlarm    = itoa(buffer1, audibleAlarm,    10);
0012E2  208264     MOV #0x826, W4
0012E4  784214     MOV.B [W4], W4
0012E6  FB0204     SE W4, W4
0012E8  2000A2     MOV #0xA, W2
0012EA  780084     MOV W4, W1
0012EC  20B9A0     MOV #0xB9A, W0
0012EE  07F820     RCALL _itoa
0012F0  780200     MOV W0, W4
0012F2  780F04     MOV W4, [W14]
632:                   char* newAlarmOneEnabled = itoa(buffer2, alarmOneEnabled, 10);
0012F4  208294     MOV #0x829, W4
0012F6  784214     MOV.B [W4], W4
0012F8  FB0204     SE W4, W4
0012FA  2000A2     MOV #0xA, W2
0012FC  780084     MOV W4, W1
0012FE  20BA50     MOV #0xBA5, W0
001300  07F817     RCALL _itoa
001302  780200     MOV W0, W4
001304  980714     MOV W4, [W14+2]
633:                   char* newAlarmTwoEnabled = itoa(buffer3, alarmTwoEnabled, 10);
001306  2082A4     MOV #0x82A, W4
001308  784214     MOV.B [W4], W4
00130A  FB0204     SE W4, W4
00130C  2000A2     MOV #0xA, W2
00130E  780084     MOV W4, W1
001310  20BB00     MOV #0xBB0, W0
001312  07F80E     RCALL _itoa
001314  780200     MOV W0, W4
001316  980724     MOV W4, [W14+4]
634:                   char* newAlarmOnePower   = itoa(buffer4, alarmOnePower,   10);
001318  208274     MOV #0x827, W4
00131A  784214     MOV.B [W4], W4
00131C  FB0204     SE W4, W4
00131E  2000A2     MOV #0xA, W2
001320  780084     MOV W4, W1
001322  20BBB0     MOV #0xBBB, W0
001324  07F805     RCALL _itoa
001326  780200     MOV W0, W4
001328  980734     MOV W4, [W14+6]
635:                   char* newAlarmTwoPower   = itoa(buffer5, alarmTwoPower,   10);
00132A  208284     MOV #0x828, W4
00132C  784214     MOV.B [W4], W4
00132E  FB0204     SE W4, W4
001330  2000A2     MOV #0xA, W2
001332  780084     MOV W4, W1
001334  20BC60     MOV #0xBC6, W0
001336  07F7FC     RCALL _itoa
001338  780200     MOV W0, W4
00133A  980744     MOV W4, [W14+8]
636:               
637:                   commandBuilder5("Set", "Alarm", newAudibleAlarm,
00133C  90034E     MOV [W14+8], W6
00133E  9002BE     MOV [W14+6], W5
001340  90022E     MOV [W14+4], W4
001342  90019E     MOV [W14+2], W3
001344  78011E     MOV [W14], W2
001346  283B31     MOV #0x83B3, W1
001348  283A90     MOV #0x83A9, W0
00134A  07FC62     RCALL commandBuilder5
638:                           newAlarmOneEnabled, newAlarmTwoEnabled,
639:                           newAlarmOnePower, newAlarmTwoPower);
640:               }
00134C  FA8000     ULNK
641:               
642:               void setRemotePassword(void) {
001350  FA000A     LNK #0xA
643:                   char newPassword[7];
644:                   int i;
645:                   for (i = 0; i < 6; i++)
001352  EB0200     CLR W4
001354  780F04     MOV W4, [W14]
001356  370007     BRA 0x1366
001364  E80F1E     INC [W14], [W14]
001366  78021E     MOV [W14], W4
001368  520FE5     SUB W4, #0x5, [W15]
00136A  34FFF6     BRA LE, 0x1358
646:                       newPassword[i] = passwordSet[i];
001358  2081A4     MOV #0x81A, W4
00135A  42021E     ADD W4, [W14], W4
00135C  784214     MOV.B [W4], W4
00135E  E8828E     INC2 W14, W5
001360  42829E     ADD W5, [W14], W5
001362  784A84     MOV.B W4, [W5]
647:                   newPassword[6] = 0;
00136C  EB4200     CLR.B W4
00136E  984F04     MOV.B W4, [W14+8]
648:               
649:                   commandBuilder1("Set", "Pwd", newPassword);
001370  E8820E     INC2 W14, W4
001372  780104     MOV W4, W2
001374  283B91     MOV #0x83B9, W1
001376  283A90     MOV #0x83A9, W0
001378  07FBD7     RCALL commandBuilder1
650:               }
00137A  FA8000     ULNK
651:               
652:               void setRemoteEmergency(void) {
00137E  FA0006     LNK #0x6
653:                   char* newEmerButtonEnable = itoa(buffer1, (int) emerButtonEnable, 10);
001380  208234     MOV #0x823, W4
001382  784214     MOV.B [W4], W4
001384  FB0204     SE W4, W4
001386  2000A2     MOV #0xA, W2
001388  780084     MOV W4, W1
00138A  20B9A0     MOV #0xB9A, W0
00138C  07F7D1     RCALL _itoa
00138E  780200     MOV W0, W4
001390  780F04     MOV W4, [W14]
654:                   char* newEmerButtonAlloc  = itoa(buffer2, emerButtonAlloc,  10);
001392  804124     MOV emerButtonAlloc, W4
001394  2000A2     MOV #0xA, W2
001396  780084     MOV W4, W1
001398  20BA50     MOV #0xBA5, W0
00139A  07F7CA     RCALL _itoa
00139C  780200     MOV W0, W4
00139E  980714     MOV W4, [W14+2]
655:                   char* newEmerAllocSend    = itoa(buffer3, emerAllocSend,    10);
0013A0  8054B4     MOV emerAllocSend, W4
0013A2  2000A2     MOV #0xA, W2
0013A4  780084     MOV W4, W1
0013A6  20BB00     MOV #0xBB0, W0
0013A8  07F7C3     RCALL _itoa
0013AA  780200     MOV W0, W4
0013AC  980724     MOV W4, [W14+4]
656:               
657:                   commandBuilder3("Set", "Emer", newEmerButtonEnable,
0013AE  90022E     MOV [W14+4], W4
0013B0  90019E     MOV [W14+2], W3
0013B2  78011E     MOV [W14], W2
0013B4  283BD1     MOV #0x83BD, W1
0013B6  283A90     MOV #0x83A9, W0
0013B8  07FBF3     RCALL commandBuilder3
658:                           newEmerButtonAlloc, newEmerAllocSend);
659:               }
0013BA  FA8000     ULNK
660:               
661:               #ifdef POWER_BOX
662:               void setRemoteVersion(void) {
0013BE  FA000A     LNK #0xA
663:                   commandBuilder1("Set", "Vers", POWER_BOX_CODE_VERSION);
0013C0  B3C311     MOV.B #0x31, W1
0013C2  B3C370     MOV.B #0x37, W0
0013C4  B3C625     MOV.B #0x62, W5
0013C6  B3C6E4     MOV.B #0x6E, W4
0013C8  52CF84     SUB.B W5, W4, [W15]
0013CA  32001A     BRA Z, 0x1400
0013CC  B3C625     MOV.B #0x62, W5
0013CE  B3C624     MOV.B #0x62, W4
0013D0  52CF84     SUB.B W5, W4, [W15]
0013D2  320016     BRA Z, 0x1400
0013D4  B3C625     MOV.B #0x62, W5
0013D6  B3C724     MOV.B #0x72, W4
0013D8  52CF84     SUB.B W5, W4, [W15]
0013DA  320012     BRA Z, 0x1400
0013DC  B3C625     MOV.B #0x62, W5
0013DE  B3C794     MOV.B #0x79, W4
0013E0  52CF84     SUB.B W5, W4, [W15]
0013E2  32000E     BRA Z, 0x1400
0013E4  B3C625     MOV.B #0x62, W5
0013E6  B3C6C4     MOV.B #0x6C, W4
0013E8  52CF84     SUB.B W5, W4, [W15]
0013EA  32000A     BRA Z, 0x1400
0013EC  B3C625     MOV.B #0x62, W5
0013EE  B3C674     MOV.B #0x67, W4
0013F0  52CF84     SUB.B W5, W4, [W15]
0013F2  320006     BRA Z, 0x1400
0013F4  B3C625     MOV.B #0x62, W5
0013F6  B3C704     MOV.B #0x70, W4
0013F8  52CF84     SUB.B W5, W4, [W15]
0013FA  320002     BRA Z, 0x1400
0013FC  200014     MOV #0x1, W4
0013FE  370001     BRA 0x1402
001400  EB0200     CLR W4
001402  784204     MOV.B W4, W4
001404  B04304     ADD.B #0x30, W4
001406  784384     MOV.B W4, W7
001408  B3C625     MOV.B #0x62, W5
00140A  B3C6E4     MOV.B #0x6E, W4
00140C  52CF84     SUB.B W5, W4, [W15]
00140E  3A0009     BRA NZ, 0x1422
001410  B3C655     MOV.B #0x65, W5
001412  B3C614     MOV.B #0x61, W4
001414  52CF84     SUB.B W5, W4, [W15]
001416  3A0002     BRA NZ, 0x141C
001418  B3C314     MOV.B #0x31, W4
00141A  370001     BRA 0x141E
00141C  B3C364     MOV.B #0x36, W4
00141E  784284     MOV.B W4, W5
001420  370038     BRA 0x1492
001422  B3C625     MOV.B #0x62, W5
001424  B3C624     MOV.B #0x62, W4
001426  52CF84     SUB.B W5, W4, [W15]
001428  320032     BRA Z, 0x148E
00142A  B3C625     MOV.B #0x62, W5
00142C  B3C724     MOV.B #0x72, W4
00142E  52CF84     SUB.B W5, W4, [W15]
001430  3A0008     BRA NZ, 0x1442
001432  B3C465     MOV.B #0x46, W5
001434  B3C4D4     MOV.B #0x4D, W4
001436  52CF84     SUB.B W5, W4, [W15]
001438  3A0002     BRA NZ, 0x143E
00143A  B3C334     MOV.B #0x33, W4
00143C  370001     BRA 0x1440
00143E  B3C344     MOV.B #0x34, W4
001440  370025     BRA 0x148C
001442  B3C625     MOV.B #0x62, W5
001444  B3C794     MOV.B #0x79, W4
001446  52CF84     SUB.B W5, W4, [W15]
001448  320020     BRA Z, 0x148A
00144A  B3C625     MOV.B #0x62, W5
00144C  B3C6C4     MOV.B #0x6C, W4
00144E  52CF84     SUB.B W5, W4, [W15]
001450  32001A     BRA Z, 0x1486
001452  B3C625     MOV.B #0x62, W5
001454  B3C674     MOV.B #0x67, W4
001456  52CF84     SUB.B W5, W4, [W15]
001458  320014     BRA Z, 0x1482
00145A  B3C625     MOV.B #0x62, W5
00145C  B3C704     MOV.B #0x70, W4
00145E  52CF84     SUB.B W5, W4, [W15]
001460  32000E     BRA Z, 0x147E
001462  B3C625     MOV.B #0x62, W5
001464  B3C744     MOV.B #0x74, W4
001466  52CF84     SUB.B W5, W4, [W15]
001468  320008     BRA Z, 0x147A
00146A  B3C625     MOV.B #0x62, W5
00146C  B3C764     MOV.B #0x76, W4
00146E  52CF84     SUB.B W5, W4, [W15]
001470  3A0002     BRA NZ, 0x1476
001472  B3C314     MOV.B #0x31, W4
001474  370001     BRA 0x1478
001476  B3C324     MOV.B #0x32, W4
001478  370001     BRA 0x147C
00147A  B3C304     MOV.B #0x30, W4
00147C  370001     BRA 0x1480
00147E  B3C394     MOV.B #0x39, W4
001480  370001     BRA 0x1484
001482  B3C384     MOV.B #0x38, W4
001484  370001     BRA 0x1488
001486  B3C374     MOV.B #0x37, W4
001488  370001     BRA 0x148C
00148A  B3C354     MOV.B #0x35, W4
00148C  370001     BRA 0x1490
00148E  B3C324     MOV.B #0x32, W4
001490  784284     MOV.B W4, W5
001492  B3C206     MOV.B #0x20, W6
001494  B3C204     MOV.B #0x20, W4
001496  534F84     SUB.B W6, W4, [W15]
001498  320002     BRA Z, 0x149E
00149A  B3C204     MOV.B #0x20, W4
00149C  370001     BRA 0x14A0
00149E  B3C304     MOV.B #0x30, W4
0014A0  B3C346     MOV.B #0x34, W6
0014A2  784F01     MOV.B W1, [W14]
0014A4  984710     MOV.B W0, [W14+1]
0014A6  984727     MOV.B W7, [W14+2]
0014A8  984735     MOV.B W5, [W14+3]
0014AA  984744     MOV.B W4, [W14+4]
0014AC  984756     MOV.B W6, [W14+5]
0014AE  B3C304     MOV.B #0x30, W4
0014B0  984764     MOV.B W4, [W14+6]
0014B2  B3C314     MOV.B #0x31, W4
0014B4  984774     MOV.B W4, [W14+7]
0014B6  EB4200     CLR.B W4
0014B8  984F04     MOV.B W4, [W14+8]
0014BA  78010E     MOV W14, W2
0014BC  283C21     MOV #0x83C2, W1
0014BE  283A90     MOV #0x83A9, W0
0014C0  07FB33     RCALL commandBuilder1
664:               }
0014C2  FA8000     ULNK
665:               
666:               void setRemotePowerDownUpTime(void) {
0014C6  FA0000     LNK #0x0
667:                   commandBuilder1("Set", "PDT", powerDownTime);
0014C8  20A982     MOV #0xA98, W2
0014CA  283C71     MOV #0x83C7, W1
0014CC  283A90     MOV #0x83A9, W0
0014CE  07FB2C     RCALL commandBuilder1
668:                   commandBuilder1("Set", "PUT", powerUpTime);
0014D0  20AA42     MOV #0xAA4, W2
0014D2  283CB1     MOV #0x83CB, W1
0014D4  283A90     MOV #0x83A9, W0
0014D6  07FB28     RCALL commandBuilder1
669:               }
0014D8  FA8000     ULNK
670:               #endif
671:               
672:               void setRemoteResetTime(void) {
0014DC  FA0004     LNK #0x4
673:                   char* newResetHour   = itoa(buffer1, (int) resetHour, 10);
0014DE  208034     MOV #0x803, W4
0014E0  784214     MOV.B [W4], W4
0014E2  FB8204     ZE W4, W4
0014E4  2000A2     MOV #0xA, W2
0014E6  780084     MOV W4, W1
0014E8  20B9A0     MOV #0xB9A, W0
0014EA  07F722     RCALL _itoa
0014EC  780200     MOV W0, W4
0014EE  780F04     MOV W4, [W14]
674:                   char* newResetMinute = itoa(buffer2, (int) resetMinute, 10);
0014F0  208044     MOV #0x804, W4
0014F2  784214     MOV.B [W4], W4
0014F4  FB8204     ZE W4, W4
0014F6  2000A2     MOV #0xA, W2
0014F8  780084     MOV W4, W1
0014FA  20BA50     MOV #0xBA5, W0
0014FC  07F719     RCALL _itoa
0014FE  780200     MOV W0, W4
001500  980714     MOV W4, [W14+2]
675:               
676:                   commandBuilder2("Set", "Reset", newResetHour, newResetMinute);
001502  90019E     MOV [W14+2], W3
001504  78011E     MOV [W14], W2
001506  283CF1     MOV #0x83CF, W1
001508  283A90     MOV #0x83A9, W0
00150A  07FB31     RCALL commandBuilder2
677:               }
00150C  FA8000     ULNK
678:               
679:               void setRemoteRelay(void) {
001510  FA0000     LNK #0x0
680:                   if (relayActive)
001512  2080F4     MOV #0x80F, W4
001514  784214     MOV.B [W4], W4
001516  524FE0     SUB.B W4, #0x0, [W15]
001518  320005     BRA Z, 0x1524
681:                       commandBuilder1("Set", "Relay", "On");
00151A  283D52     MOV #0x83D5, W2
00151C  283D81     MOV #0x83D8, W1
00151E  283A90     MOV #0x83A9, W0
001520  07FB03     RCALL commandBuilder1
001522  370004     BRA 0x152C
682:                   else
683:                       commandBuilder1("Set", "Relay", "F");
001524  283DE2     MOV #0x83DE, W2
001526  283D81     MOV #0x83D8, W1
001528  283A90     MOV #0x83A9, W0
00152A  07FAFE     RCALL commandBuilder1
684:               }
00152C  FA8000     ULNK
685:               
686:               void setRemoteStats(void) {
001530  FA0004     LNK #0x4
687:                   char* stats = itoa(buffer1, totalUsed / 1000, 10);
001532  804084     MOV totalUsed, W4
001534  804095     MOV 0x812, W5
001536  203E82     MOV #0x3E8, W2
001538  200003     MOV #0x0, W3
00153A  BE0004     MOV.D W4, W0
00153C  07F6B0     RCALL ___udivsi3
00153E  BE0200     MOV.D W0, W4
001540  780204     MOV W4, W4
001542  2000A2     MOV #0xA, W2
001544  780084     MOV W4, W1
001546  20B9A0     MOV #0xB9A, W0
001548  07F6F3     RCALL _itoa
00154A  780200     MOV W0, W4
00154C  780F04     MOV W4, [W14]
688:                   char* previousDayStats = itoa(buffer2, previousDayUsed, 10);
00154E  8040A4     MOV previousDayUsed, W4
001550  8040B5     MOV 0x816, W5
001552  780204     MOV W4, W4
001554  2000A2     MOV #0xA, W2
001556  780084     MOV W4, W1
001558  20BA50     MOV #0xBA5, W0
00155A  07F6EA     RCALL _itoa
00155C  780200     MOV W0, W4
00155E  980714     MOV W4, [W14+2]
689:                   commandBuilder2("Set", "Stat", stats, previousDayStats);
001560  90019E     MOV [W14+2], W3
001562  78011E     MOV [W14], W2
001564  283E01     MOV #0x83E0, W1
001566  283A90     MOV #0x83A9, W0
001568  07FB02     RCALL commandBuilder2
690:               }
00156A  FA8000     ULNK
691:               
692:               void setRemoteHL(void) {
00156E  FA0000     LNK #0x0
693:                   if (isHigh)
001570  2080E4     MOV #0x80E, W4
001572  784214     MOV.B [W4], W4
001574  524FE0     SUB.B W4, #0x0, [W15]
001576  320005     BRA Z, 0x1582
694:                       commandBuilder1("Set", "HL", "High");
001578  283E52     MOV #0x83E5, W2
00157A  283EA1     MOV #0x83EA, W1
00157C  283A90     MOV #0x83A9, W0
00157E  07FAD4     RCALL commandBuilder1
001580  370004     BRA 0x158A
695:                   else
696:                       commandBuilder1("Set", "HL", "Low");
001582  283ED2     MOV #0x83ED, W2
001584  283EA1     MOV #0x83EA, W1
001586  283A90     MOV #0x83A9, W0
001588  07FACF     RCALL commandBuilder1
697:               }
00158A  FA8000     ULNK
698:               
699:               void doReset(void) {
00158E  FA0000     LNK #0x0
700:                   commandBuilder1("Reset", "0", "0");
001590  283F12     MOV #0x83F1, W2
001592  283F11     MOV #0x83F1, W1
001594  283CF0     MOV #0x83CF, W0
001596  07FAC8     RCALL commandBuilder1
701:               }
001598  FA8000     ULNK
702:               
703:               #ifdef POWER_BOX
704:               void sendUpdate(void) {
00159C  FA0000     LNK #0x0
705:                   setRemotePower();
00159E  07FE7F     RCALL setRemotePower
706:               }
0015A0  FA8000     ULNK
707:               #endif
708:               
709:               
710:               /* Read Commands **************************************************************/
711:               void readRemoteTime(void) {
0015A4  FA0000     LNK #0x0
712:                   commandBuilder1("Read", "Time", "0");
0015A6  283F12     MOV #0x83F1, W2
0015A8  283A41     MOV #0x83A4, W1
0015AA  283F30     MOV #0x83F3, W0
0015AC  07FABD     RCALL commandBuilder1
713:               }
0015AE  FA8000     ULNK
714:               
715:               void readRemotePower(void) {
0015B2  FA0000     LNK #0x0
716:                   commandBuilder1("Read", "Power", "0");
0015B4  283F12     MOV #0x83F1, W2
0015B6  283AD1     MOV #0x83AD, W1
0015B8  283F30     MOV #0x83F3, W0
0015BA  07FAB6     RCALL commandBuilder1
717:               }
0015BC  FA8000     ULNK
718:               
719:               void readRemoteAlarm(void) {
0015C0  FA0000     LNK #0x0
720:                   commandBuilder1("Read", "Alarm", "0");
0015C2  283F12     MOV #0x83F1, W2
0015C4  283B31     MOV #0x83B3, W1
0015C6  283F30     MOV #0x83F3, W0
0015C8  07FAAF     RCALL commandBuilder1
721:               }
0015CA  FA8000     ULNK
722:               
723:               void readRemotePassword(void) {
0015CE  FA0000     LNK #0x0
724:                   commandBuilder1("Read", "Pwd", "0");
0015D0  283F12     MOV #0x83F1, W2
0015D2  283B91     MOV #0x83B9, W1
0015D4  283F30     MOV #0x83F3, W0
0015D6  07FAA8     RCALL commandBuilder1
725:               }
0015D8  FA8000     ULNK
726:               
727:               void readRemoteEmergency(void) {
0015DC  FA0000     LNK #0x0
728:                   commandBuilder1("Read", "Emer", "0");
0015DE  283F12     MOV #0x83F1, W2
0015E0  283BD1     MOV #0x83BD, W1
0015E2  283F30     MOV #0x83F3, W0
0015E4  07FAA1     RCALL commandBuilder1
729:               }
0015E6  FA8000     ULNK
730:               
731:               void readRemoteVersion(void) {
0015EA  FA0000     LNK #0x0
732:                   commandBuilder1("Read", "Vers", "0");
0015EC  283F12     MOV #0x83F1, W2
0015EE  283C21     MOV #0x83C2, W1
0015F0  283F30     MOV #0x83F3, W0
0015F2  07FA9A     RCALL commandBuilder1
733:               }
0015F4  FA8000     ULNK
734:               
735:               void readRemoteResetTime(void) {
0015F8  FA0000     LNK #0x0
736:                   commandBuilder1("Read", "Reset", "0");
0015FA  283F12     MOV #0x83F1, W2
0015FC  283CF1     MOV #0x83CF, W1
0015FE  283F30     MOV #0x83F3, W0
001600  07FA93     RCALL commandBuilder1
737:               }
001602  FA8000     ULNK
738:               
739:               void readRemoteRelay(void) {
001606  FA0000     LNK #0x0
740:                   commandBuilder1("Read", "Relay", "0");
001608  283F12     MOV #0x83F1, W2
00160A  283D81     MOV #0x83D8, W1
00160C  283F30     MOV #0x83F3, W0
00160E  07FA8C     RCALL commandBuilder1
741:               }
001610  FA8000     ULNK
742:               
743:               void readRemoteStats(void) {
001614  FA0000     LNK #0x0
744:                   commandBuilder1("Read", "Stat", "0");
001616  283F12     MOV #0x83F1, W2
001618  283E01     MOV #0x83E0, W1
00161A  283F30     MOV #0x83F3, W0
00161C  07FA85     RCALL commandBuilder1
745:               }
00161E  FA8000     ULNK
746:               
747:               void readRemoteHL(void) {
001622  FA0000     LNK #0x0
748:                   commandBuilder1("Read", "HL", "0");
001624  283F12     MOV #0x83F1, W2
001626  283EA1     MOV #0x83EA, W1
001628  283F30     MOV #0x83F3, W0
00162A  07FA7E     RCALL commandBuilder1
749:               }
00162C  FA8000     ULNK
750:               
751:               void readRemotePowerDownUpTime(void) {
001630  FA0000     LNK #0x0
752:                   commandBuilder1("Read", "PwrFail", "0");
001632  283F12     MOV #0x83F1, W2
001634  283F81     MOV #0x83F8, W1
001636  283F30     MOV #0x83F3, W0
001638  07FA77     RCALL commandBuilder1
753:               }
00163A  FA8000     ULNK
754:               
755:               void readUpdate(void) {
00163E  FA0000     LNK #0x0
756:                   commandBuilder1("Update", "0", "0");
001640  283F12     MOV #0x83F1, W2
001642  283F11     MOV #0x83F1, W1
001644  284000     MOV #0x8400, W0
001646  07FA70     RCALL commandBuilder1
757:               }
001648  FA8000     ULNK
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/PowerUART.c
1:                 /* File:    PowerUART.c
2:                  * Authors: Dan Baker
3:                  *          Nathan Chaney
4:                  */
5:                 
6:                 /* Includes *******************************************************************/
7:                 
8:                 #include <p24FV32KA302.h>
9:                 #include "PowerPinDefinitions.h"
10:                #include "ExternPowerDefinitions.h"
11:                #include "ExternSharedDefinitions.h"
12:                
13:                /* Functions ******************************************************************/
14:                
15:                void initUART2(void);
16:                void initUART1(void);
17:                
18:                void initUART(void) {
002FFE  FA0000     LNK #0x0
19:                    initUART2();
003000  070003     RCALL initUART2
20:                    initUART1();
003002  07002B     RCALL initUART1
21:                }
003004  FA8000     ULNK
22:                
23:                void initUART2(void) {
003008  FA0000     LNK #0x0
24:                  // FCY = 2 MHz;
25:                  // BAUD = FCY / (16 * (U2BRG + 1))
26:                  // BRG = -1 + FCY / (16 * BAUD)
27:                  // Ok to be slightly off
28:                  // U2BRG = 1;  // baud rate is 62500
29:                  // U2BRG = 3;  // baud rate is 31250
30:                  // U2BRG = 6;  // baud rate is 17829
31:                   U2BRG = 12; // baud rate is 9615
00300A  2000C4     MOV #0xC, W4
00300C  8811C4     MOV W4, U2BRG
32:                  // U2BRG = 25; // baud rate is 4800
33:                  // U2BRG = 50; // baud rate is 2447
34:                
35:                
36:                    U2MODEbits.USIDL = 0b0;
00300E  A9A231     BCLR 0x231, #5
37:                    U2MODEbits.IREN = 0b0;
003010  A98231     BCLR 0x231, #4
38:                    U2MODEbits.RTSMD = 0b1;
003012  A86231     BSET 0x231, #3
39:                    U2MODEbits.UEN = 0b00;
003014  801184     MOV U2MODE, W4
003016  A18004     BCLR W4, #8
003018  A19004     BCLR W4, #9
00301A  881184     MOV W4, U2MODE
40:                    U2MODEbits.WAKE = 0b0;
00301C  A9E230     BCLR U2MODE, #7
41:                    U2MODEbits.LPBACK = 0b0;
00301E  A9C230     BCLR U2MODE, #6
42:                    U2MODEbits.ABAUD = 0b0;
003020  A9A230     BCLR U2MODE, #5
43:                    U2MODEbits.RXINV = 0b0;
003022  A98230     BCLR U2MODE, #4
44:                    U2MODEbits.BRGH = 0b0;
003024  A96230     BCLR U2MODE, #3
45:                    U2MODEbits.PDSEL = 0b00;
003026  801184     MOV U2MODE, W4
003028  A11004     BCLR W4, #1
00302A  A12004     BCLR W4, #2
00302C  881184     MOV W4, U2MODE
46:                    U2MODEbits.STSEL = 0b0;
00302E  A90230     BCLR U2MODE, #0
47:                
48:                    U2STAbits.UTXISEL0 = 0b0;
003030  A9A233     BCLR 0x233, #5
49:                    U2STAbits.UTXISEL1 = 0b0;
003032  A9E233     BCLR 0x233, #7
50:                    U2STAbits.UTXINV = 0b0;
003034  A9C233     BCLR 0x233, #6
51:                    U2STAbits.UTXBRK = 0b0;
003036  A96233     BCLR 0x233, #3
52:                    U2STAbits.URXISEL1 = 0b0; // interrupt after one RX character is received
003038  A9E232     BCLR U2STA, #7
53:                    U2STAbits.ADDEN = 0;
00303A  A9A232     BCLR U2STA, #5
54:                
55:                    //interrupts
56:                    _U2RXIP = 1;     // set RX interrupt priority (1-7, default 4)
00303C  800594     MOV IPC7, W4
00303E  A08004     BSET W4, #8
003040  A19004     BCLR W4, #9
003042  A1A004     BCLR W4, #10
003044  880594     MOV W4, IPC7
57:                    _U2ERIF = 0;     // clear Error Flag
003046  A9408C     BCLR IFS4, #2
58:                    _U2ERIE = 1;     // enable Error Interrupt
003048  A8409C     BSET IEC4, #2
59:                    _U2TXIF = 0;     // clear TX Flag
00304A  A9E087     BCLR 0x87, #7
60:                    _U2TXIE = 0;     // disable TX Interrupt
00304C  A9E097     BCLR 0x97, #7
61:                    _U2RXIF = 0;     // clear RX interrupt flag
00304E  A9C087     BCLR 0x87, #6
62:                    _U2RXIE = 1;     // enable RX interrupt
003050  A8C097     BSET 0x97, #6
63:                
64:                    U2MODEbits.UARTEN = 0b1; // turn it on
003052  A8E231     BSET 0x231, #7
65:                    U2STAbits.UTXEN   = 0b1; // enable transmit
003054  A84233     BSET 0x233, #2
66:                
67:                }
003056  FA8000     ULNK
68:                
69:                void initUART1(void) {
00305A  FA0000     LNK #0x0
70:                  // FCY = 2 MHz;
71:                  // BAUD = FCY / 16 / (U1BRG + 1)
72:                  // Ok to be slightly off
73:                  // U1BRG = 1;  // baud rate is 62500
74:                  // U1BRG = 3;  // baud rate is 31250
75:                  // U1BRG = 6;  // baud rate is 17829
76:                   U1BRG = 12; // baud rate is 9615
00305C  2000C4     MOV #0xC, W4
00305E  881144     MOV W4, U1BRG
77:                  // U1BRG = 25; // baud rate is 4800
78:                  // U1BRG = 50; // baud rate is 2447
79:                
80:                
81:                    U1MODEbits.USIDL = 0b0;
003060  A9A221     BCLR 0x221, #5
82:                    U1MODEbits.IREN = 0b0;
003062  A98221     BCLR 0x221, #4
83:                    U1MODEbits.RTSMD = 0b1;
003064  A86221     BSET 0x221, #3
84:                    U1MODEbits.UEN = 0b00;
003066  801104     MOV U1MODE, W4
003068  A18004     BCLR W4, #8
00306A  A19004     BCLR W4, #9
00306C  881104     MOV W4, U1MODE
85:                    U1MODEbits.WAKE = 0b0;
00306E  A9E220     BCLR U1MODE, #7
86:                    U1MODEbits.LPBACK = 0b0;
003070  A9C220     BCLR U1MODE, #6
87:                    U1MODEbits.ABAUD = 0b0;
003072  A9A220     BCLR U1MODE, #5
88:                    U1MODEbits.RXINV = 0b0;
003074  A98220     BCLR U1MODE, #4
89:                    U1MODEbits.BRGH = 0b0;
003076  A96220     BCLR U1MODE, #3
90:                    U1MODEbits.PDSEL = 0b00;
003078  801104     MOV U1MODE, W4
00307A  A11004     BCLR W4, #1
00307C  A12004     BCLR W4, #2
00307E  881104     MOV W4, U1MODE
91:                    U1MODEbits.STSEL = 0b0;
003080  A90220     BCLR U1MODE, #0
92:                
93:                    U1STAbits.UTXISEL0 = 0b0;
003082  A9A223     BCLR 0x223, #5
94:                    U1STAbits.UTXISEL1 = 0b0;
003084  A9E223     BCLR 0x223, #7
95:                    U1STAbits.UTXINV = 0b0;
003086  A9C223     BCLR 0x223, #6
96:                    U1STAbits.UTXBRK = 0b0;
003088  A96223     BCLR 0x223, #3
97:                    U1STAbits.URXISEL1 = 0b0; // interrupt after one RX character is received
00308A  A9E222     BCLR U1STA, #7
98:                    U1STAbits.ADDEN = 0;
00308C  A9A222     BCLR U1STA, #5
99:                
100:                   //interrupts
101:                   _U1RXIP = 1;     // set RX interrupt priority (1-7, default 4)
00308E  800544     MOV IPC2, W4
003090  A0C004     BSET W4, #12
003092  A1D004     BCLR W4, #13
003094  A1E004     BCLR W4, #14
003096  880544     MOV W4, IPC2
102:                   _U1ERIF = 0;     // clear Error Flag
003098  A9208C     BCLR IFS4, #1
103:                   _U1ERIE = 1;     // enable Error Interrupt
00309A  A8209C     BSET IEC4, #1
104:                   _U1TXIF = 0;     // clear TX Flag
00309C  A98085     BCLR 0x85, #4
105:                   _U1TXIE = 0;     // disable TX Interrupt
00309E  A98095     BCLR 0x95, #4
106:                   _U1RXIF = 0;     // clear RX interrupt flag
0030A0  A96085     BCLR 0x85, #3
107:                   _U1RXIE = 1;     // enable RX interrupt
0030A2  A86095     BSET 0x95, #3
108:               
109:                   U1MODEbits.UARTEN = 0b1; // turn it on
0030A4  A8E221     BSET 0x221, #7
110:                   U1STAbits.UTXEN   = 0b1; // enable transmit
0030A6  A84223     BSET 0x223, #2
111:               
112:               }
0030A8  FA8000     ULNK
113:               
114:               void __attribute__((__interrupt__,__no_auto_psv__)) _U2RXInterrupt(void) {
0030AC  F80036     PUSH RCOUNT
0030AE  BE9F80     MOV.D W0, [W15++]
0030B0  BE9F82     MOV.D W2, [W15++]
0030B2  BE9F84     MOV.D W4, [W15++]
0030B4  BE9F86     MOV.D W6, [W15++]
0030B6  FA0002     LNK #0x2
115:               
116:                   unsigned char tempChar;
117:               
118:                   _U2RXIF = 0; // clear interrupt flag
0030B8  A9C087     BCLR 0x87, #6
119:               
120:                   U2STAbits.OERR = 0;
0030BA  A92232     BCLR U2STA, #1
121:               
122:                   while (U2STAbits.URXDA == 1) { // something to receive
0030BC  370040     BRA 0x313E
00313E  801194     MOV U2STA, W4
003140  620261     AND W4, #0x1, W4
003142  520FE0     SUB W4, #0x0, [W15]
003144  3AFFBC     BRA NZ, 0x30BE
123:               
124:                       tempChar = U2RXREG;
0030BE  8011B4     MOV U2RXREG, W4
0030C0  784F04     MOV.B W4, [W14]
125:               
126:                       if (tempChar > 31 && tempChar < 127) { // ignore junk characters
0030C2  78421E     MOV.B [W14], W4
0030C4  524FFF     SUB.B W4, #0x1F, [W15]
0030C6  360015     BRA LEU, 0x30F2
0030C8  B3C7E4     MOV.B #0x7E, W4
0030CA  78429E     MOV.B [W14], W5
0030CC  52CF84     SUB.B W5, W4, [W15]
0030CE  3E0011     BRA GTU, 0x30F2
127:                           if (tempChar > 64 && tempChar < 91)
0030D0  B3C404     MOV.B #0x40, W4
0030D2  78429E     MOV.B [W14], W5
0030D4  52CF84     SUB.B W5, W4, [W15]
0030D6  360006     BRA LEU, 0x30E4
0030D8  B3C5A4     MOV.B #0x5A, W4
0030DA  78429E     MOV.B [W14], W5
0030DC  52CF84     SUB.B W5, W4, [W15]
0030DE  3E0002     BRA GTU, 0x30E4
128:                               tempChar += 32;
0030E0  B3C204     MOV.B #0x20, W4
0030E2  424F1E     ADD.B W4, [W14], [W14]
129:                           receiveBufferU2[receiveIndexU2++] = tempChar;
0030E4  8055A5     MOV receiveIndexU2, W5
0030E6  78421E     MOV.B [W14], W4
0030E8  20ADE6     MOV #0xADE, W6
0030EA  428306     ADD W5, W6, W6
0030EC  784B04     MOV.B W4, [W6]
0030EE  E80205     INC W5, W4
0030F0  8855A4     MOV W4, receiveIndexU2
130:                       }
131:               
132:                       if ((receiveIndexU2 > RECEIVE_STRING_LENGTH - 1) || (tempChar == '.') || (tempChar == 0)) {
0030F2  8055A5     MOV receiveIndexU2, W5
0030F4  200284     MOV #0x28, W4
0030F6  528F84     SUB W5, W4, [W15]
0030F8  3C0010     BRA GT, 0x311A
0030FA  B3C2E4     MOV.B #0x2E, W4
0030FC  78429E     MOV.B [W14], W5
0030FE  52CF84     SUB.B W5, W4, [W15]
003100  32000E     BRA Z, 0x311E
003102  78421E     MOV.B [W14], W4
003104  524FE0     SUB.B W4, #0x0, [W15]
003106  3A001B     BRA NZ, 0x313E
133:                           while (receiveIndexU2 < RECEIVE_STRING_LENGTH)
003108  37000B     BRA 0x3120
00311A  000000     NOP
00311C  370001     BRA 0x3120
00311E  000000     NOP
003120  8055A5     MOV receiveIndexU2, W5
003122  200284     MOV #0x28, W4
003124  528F84     SUB W5, W4, [W15]
003126  34FFF1     BRA LE, 0x310A
134:                               receiveBufferU2[receiveIndexU2++] = 0;
00310A  8055A5     MOV receiveIndexU2, W5
00310C  20ADE4     MOV #0xADE, W4
00310E  428304     ADD W5, W4, W6
003110  EB4200     CLR.B W4
003112  784B04     MOV.B W4, [W6]
003114  E80205     INC W5, W4
003116  8855A4     MOV W4, receiveIndexU2
003118  370003     BRA 0x3120
135:                           receiveIndexU2 = 0;
003128  EB0200     CLR W4
00312A  8855A4     MOV W4, receiveIndexU2
136:               
137:                           stringCopy(receiveBufferU2, receiveBuffer());
00312C  07EC3F     RCALL receiveBuffer
00312E  780200     MOV W0, W4
003130  780084     MOV W4, W1
003132  20ADE0     MOV #0xADE, W0
003134  07EC84     RCALL stringCopy
138:                           newReceiveData = 1;
003136  B3C014     MOV.B #0x1, W4
003138  FD0200     EXCH W0, W4
00313A  B7EA90     MOV.B WREG, newReceiveData
00313C  FD0200     EXCH W0, W4
139:                       }
140:                   }
141:               }
003146  FA8000     ULNK
142:               
143:               void __attribute__((__interrupt__,__no_auto_psv__)) _U2ErrInterrupt(void) {
003154  781F80     MOV W0, [W15++]
003156  781F84     MOV W4, [W15++]
003158  FA0000     LNK #0x0
144:               //    U2MODEbits.UARTEN = 0b0;
145:               //    delayMS(1);
146:               //    U2MODEbits.UARTEN = 0b1;
147:                   U2STAbits.PERR;
00315A  801194     MOV U2STA, W4
148:                   U2STAbits.FERR;
00315C  801194     MOV U2STA, W4
149:                   U2STAbits.OERR = 0;
00315E  A92232     BCLR U2STA, #1
150:               
151:                   _U2ERIF = 0; // clear error interrupt flag
003160  A9408C     BCLR IFS4, #2
152:               }
003162  FA8000     ULNK
153:               
154:               void __attribute__((__interrupt__,__no_auto_psv__)) _U1RXInterrupt(void) {
00316A  F80036     PUSH RCOUNT
00316C  BE9F80     MOV.D W0, [W15++]
00316E  BE9F82     MOV.D W2, [W15++]
003170  BE9F84     MOV.D W4, [W15++]
003172  BE9F86     MOV.D W6, [W15++]
003174  FA0002     LNK #0x2
155:               
156:                   unsigned char tempChar;
157:               
158:                   U1STAbits.OERR = 0;
003176  A92222     BCLR U1STA, #1
159:               
160:                   while (U1STAbits.URXDA == 1) { // something to receive
003178  370040     BRA 0x31FA
0031FA  801114     MOV U1STA, W4
0031FC  620261     AND W4, #0x1, W4
0031FE  520FE0     SUB W4, #0x0, [W15]
003200  3AFFBC     BRA NZ, 0x317A
161:               
162:                       tempChar = U1RXREG;
00317A  801134     MOV U1RXREG, W4
00317C  784F04     MOV.B W4, [W14]
163:               
164:                       if (tempChar > 31 && tempChar < 127) { // ignore junk characters
00317E  78421E     MOV.B [W14], W4
003180  524FFF     SUB.B W4, #0x1F, [W15]
003182  360015     BRA LEU, 0x31AE
003184  B3C7E4     MOV.B #0x7E, W4
003186  78429E     MOV.B [W14], W5
003188  52CF84     SUB.B W5, W4, [W15]
00318A  3E0011     BRA GTU, 0x31AE
165:                           if (tempChar > 64 && tempChar < 91)
00318C  B3C404     MOV.B #0x40, W4
00318E  78429E     MOV.B [W14], W5
003190  52CF84     SUB.B W5, W4, [W15]
003192  360006     BRA LEU, 0x31A0
003194  B3C5A4     MOV.B #0x5A, W4
003196  78429E     MOV.B [W14], W5
003198  52CF84     SUB.B W5, W4, [W15]
00319A  3E0002     BRA GTU, 0x31A0
166:                               tempChar += 32;
00319C  B3C204     MOV.B #0x20, W4
00319E  424F1E     ADD.B W4, [W14], [W14]
167:                           receiveBufferU1[receiveIndexU1++] = tempChar;
0031A0  805855     MOV receiveIndexU1, W5
0031A2  78421E     MOV.B [W14], W4
0031A4  20B346     MOV #0xB34, W6
0031A6  428306     ADD W5, W6, W6
0031A8  784B04     MOV.B W4, [W6]
0031AA  E80205     INC W5, W4
0031AC  885854     MOV W4, receiveIndexU1
168:                       }
169:               
170:                       if (receiveIndexU1 > RECEIVE_STRING_LENGTH - 1 || tempChar == '.' || tempChar == 0) {
0031AE  805855     MOV receiveIndexU1, W5
0031B0  200284     MOV #0x28, W4
0031B2  528F84     SUB W5, W4, [W15]
0031B4  3C0010     BRA GT, 0x31D6
0031B6  B3C2E4     MOV.B #0x2E, W4
0031B8  78429E     MOV.B [W14], W5
0031BA  52CF84     SUB.B W5, W4, [W15]
0031BC  32000E     BRA Z, 0x31DA
0031BE  78421E     MOV.B [W14], W4
0031C0  524FE0     SUB.B W4, #0x0, [W15]
0031C2  3A001B     BRA NZ, 0x31FA
171:                           while (receiveIndexU1 < RECEIVE_STRING_LENGTH)
0031C4  37000B     BRA 0x31DC
0031D6  000000     NOP
0031D8  370001     BRA 0x31DC
0031DA  000000     NOP
0031DC  805855     MOV receiveIndexU1, W5
0031DE  200284     MOV #0x28, W4
0031E0  528F84     SUB W5, W4, [W15]
0031E2  34FFF1     BRA LE, 0x31C6
172:                               receiveBufferU1[receiveIndexU1++] = 0;
0031C6  805855     MOV receiveIndexU1, W5
0031C8  20B344     MOV #0xB34, W4
0031CA  428304     ADD W5, W4, W6
0031CC  EB4200     CLR.B W4
0031CE  784B04     MOV.B W4, [W6]
0031D0  E80205     INC W5, W4
0031D2  885854     MOV W4, receiveIndexU1
0031D4  370003     BRA 0x31DC
173:                           receiveIndexU1 = 0;
0031E4  EB0200     CLR W4
0031E6  885854     MOV W4, receiveIndexU1
174:               
175:                           stringCopy(receiveBufferU1, receiveBuffer());
0031E8  07EBE1     RCALL receiveBuffer
0031EA  780200     MOV W0, W4
0031EC  780084     MOV W4, W1
0031EE  20B340     MOV #0xB34, W0
0031F0  07EC26     RCALL stringCopy
176:                           newReceiveData = 1;
0031F2  B3C014     MOV.B #0x1, W4
0031F4  FD0200     EXCH W0, W4
0031F6  B7EA90     MOV.B WREG, newReceiveData
0031F8  FD0200     EXCH W0, W4
177:                       }
178:                   }
179:               
180:                   _U1RXIF = 0; // clear interrupt flag
003202  A96085     BCLR 0x85, #3
181:               }
003204  FA8000     ULNK
182:               
183:               void __attribute__((__interrupt__,__no_auto_psv__)) _U1ErrInterrupt(void) {
003212  781F80     MOV W0, [W15++]
003214  781F84     MOV W4, [W15++]
003216  FA0000     LNK #0x0
184:               //    U1MODEbits.UARTEN = 0b0;
185:               //    delayMS(1);
186:               //    U1MODEbits.UARTEN = 0b1;
187:                   U1STAbits.PERR;
003218  801114     MOV U1STA, W4
188:                   U1STAbits.FERR;
00321A  801114     MOV U1STA, W4
189:                   U1STAbits.OERR = 0;
00321C  A92222     BCLR U1STA, #1
190:               
191:                   _U1ERIF = 0; // clear error interrupt flag
00321E  A9208C     BCLR IFS4, #1
192:               }
003220  FA8000     ULNK
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/PowerSurvive.c
1:                 /* File:    Delays.c
2:                  * Authors: Nathan Chaney
3:                  *          Tommy Martin
4:                  */
5:                 
6:                 /* Includes *******************************************************************/
7:                 
8:                 #include <p24FV32KA302.h>
9:                 #include "PowerPinDefinitions.h"
10:                #include "ExternPowerDefinitions.h"
11:                #include "ExternSharedDefinitions.h"
12:                
13:                
14:                /* Functions ******************************************************************/
15:                
16:                void initPowerLossDetection(void) {
003536  FA0000     LNK #0x0
17:                    _TRISB3 = 1;// make pin 7 an input
003538  A862C8     BSET TRISB, #3
18:                    _CN7IE = 1;// pin 7 on the 28-pin PIC
00353A  A8E062     BSET CNEN1, #7
19:                    _CNIE = 1;// turn on CN interrupts
00353C  A86096     BSET IEC1, #3
20:                }
00353E  FA8000     ULNK
21:                
22:                void goToSleep ( )
23:                {
003542  FA0000     LNK #0x0
24:                    // go to sleep
25:                
26:                    // make all I/O inputs to keep from burning power
27:                    // these should be set to keep any power from being used by external devices
28:                    // if an output lights an LED, the LED will suck down the super cap
29:                    TRISA = 0b1111111111111111;
003544  EB8200     SETM W4
003546  881604     MOV W4, TRISA
30:                    TRISB = 0b1111111111111111;
003548  EB8200     SETM W4
00354A  881644     MOV W4, TRISB
31:                
32:                
33:                    // reset INT0 and set to trigger on rising edge
34:                    IFS0bits.INT0IF = 0b0;
00354C  A90084     BCLR IFS0, #0
35:                    IEC0bits.INT0IE = 0b0;
00354E  A90094     BCLR IEC0, #0
36:                    INTCON2bits.INT0EP = 0b0;
003550  A90082     BCLR INTCON2, #0
37:                    IEC0bits.INT0IE = 0b1;
003552  A80094     BSET IEC0, #0
38:                
39:                
40:                    // enter sleep mode
41:                    DSCONbits.DSEN = 0b1;
003554  A8E759     BSET 0x759, #7
42:                    Sleep();
003556  FE4000     PWRSAV #0
43:                }
003558  FA8000     ULNK
44:                
45:                
46:                /* Interrupts *****************************************************************/
47:                
48:                void __attribute__((__interrupt__,__no_auto_psv__)) _CNInterrupt(void) {
00355C  F80036     PUSH RCOUNT
00355E  BE9F80     MOV.D W0, [W15++]
003560  BE9F82     MOV.D W2, [W15++]
003562  BE9F84     MOV.D W4, [W15++]
003564  BE9F86     MOV.D W6, [W15++]
003566  FA0000     LNK #0x0
49:                    if(_RB3 == 0) {
003568  801654     MOV PORTB, W4
00356A  620268     AND W4, #0x8, W4
00356C  520FE0     SUB W4, #0x0, [W15]
00356E  3A0005     BRA NZ, 0x357A
50:                        commandBuilder1("Lost", "Power", "0");
003570  284122     MOV #0x8412, W2
003572  284141     MOV #0x8414, W1
003574  2841A0     MOV #0x841A, W0
003576  07EAD8     RCALL commandBuilder1
003578  370004     BRA 0x3582
51:                    } else {
52:                        commandBuilder1("Got", "Power", "0");
00357A  284122     MOV #0x8412, W2
00357C  284141     MOV #0x8414, W1
00357E  2841F0     MOV #0x841F, W0
003580  07EAD3     RCALL commandBuilder1
53:                    }
54:                
55:                    _CNIF = 0;
003582  A96086     BCLR IFS1, #3
56:                }
003584  FA8000     ULNK
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/PowerMain.c
1:                 /* File:    PowerMain.c
2:                  * Authors: Dan Baker
3:                  *          Nathan Chaney
4:                  *          Greg Talamo
5:                  */
6:                 
7:                 
8:                 /* Includes *******************************************************************/
9:                 
10:                #include <xc.h>
11:                #include <stdio.h>
12:                #include <stdlib.h>
13:                #include <p24FV32KA302.h>
14:                
15:                #include "PowerDefinitions.h"
16:                #include "PowerPinDefinitions.h"
17:                #include "SharedDefinitions.h"
18:                
19:                /* Ensure that SharedCommunication.c is excluded from the source build path!
20:                 * SharedCommunication.c must be included LAST in your main source file
21:                 * like this to ensure the compiler builds the correct variant. */
22:                #define COMM_INCLUDED
23:                #include "SharedCommunication.c"
24:                
25:                #define LED1_DIR TRISAbits.TRISA2
26:                #define LED2_DIR TRISAbits.TRISA3
27:                #define LED3_DIR TRISBbits.TRISB4
28:                #define LED4_DIR TRISAbits.TRISA4
29:                
30:                #define LED1 LATAbits.LATA2
31:                #define LED2 LATAbits.LATA3
32:                #define LED3 LATBbits.LATB4
33:                #define LED4 LATAbits.LATA4
34:                
35:                #define LEDS_FOR_DEBUG  // comment this line for normal operation (LEDS show power remaining)
36:                // uncomment for using the LEDS for debugging
37:                
38:                
39:                /* Main ***********************************************************************/
40:                
41:                /* main
42:                 * Initializes and runs through the main code that is repetitively called
43:                 */
44:                int main(void) {
00164C  FA0002     LNK #0x2
45:                
46:                    LED1_DIR = 0;
00164E  A942C0     BCLR TRISA, #2
47:                    LED2_DIR = 0;
001650  A962C0     BCLR TRISA, #3
48:                    LED3_DIR = 0;
001652  A982C8     BCLR TRISB, #4
49:                    LED4_DIR = 0;
001654  A982C0     BCLR TRISA, #4
50:                
51:                    int inx;
52:                    for( inx = 0; inx < 5; inx++)
001656  EB0200     CLR W4
001658  780F04     MOV W4, [W14]
00165A  37000D     BRA 0x1676
001674  E80F1E     INC [W14], [W14]
001676  78021E     MOV [W14], W4
001678  520FE4     SUB W4, #0x4, [W15]
00167A  34FFF0     BRA LE, 0x165C
53:                    {
54:                        LED1 = 1;
00165C  A842C4     BSET LATA, #2
55:                        LED2 = 1;
00165E  A862C4     BSET LATA, #3
56:                        LED3 = 1;
001660  A882CC     BSET LATB, #4
57:                        LED4 = 1;
001662  A882C4     BSET LATA, #4
58:                        delayMS(100);
001664  200640     MOV #0x64, W0
001666  070F44     RCALL delayMS
59:                        LED1 = 0;
001668  A942C4     BCLR LATA, #2
60:                        LED2 = 0;
00166A  A962C4     BCLR LATA, #3
61:                        LED3 = 0;
00166C  A982CC     BCLR LATB, #4
62:                        LED4 = 0;
00166E  A982C4     BCLR LATA, #4
63:                        delayMS(100);
001670  200640     MOV #0x64, W0
001672  070F3E     RCALL delayMS
64:                    }
65:                    delayMS(1000);
00167C  203E80     MOV #0x3E8, W0
00167E  070F38     RCALL delayMS
66:                
67:                    init();
001680  07002E     RCALL init
68:                    
69:                    LED1_DIR = 0;
001682  A942C0     BCLR TRISA, #2
70:                    LED2_DIR = 0;
001684  A962C0     BCLR TRISA, #3
71:                    LED3_DIR = 0;
001686  A982C8     BCLR TRISB, #4
72:                    LED4_DIR = 0;
001688  A982C0     BCLR TRISA, #4
73:                
74:                    for( inx = 0; inx < 5; inx++)
00168A  EB0200     CLR W4
00168C  780F04     MOV W4, [W14]
00168E  37000D     BRA 0x16AA
0016A8  E80F1E     INC [W14], [W14]
0016AA  78021E     MOV [W14], W4
0016AC  520FE4     SUB W4, #0x4, [W15]
0016AE  34FFF0     BRA LE, 0x1690
75:                    {
76:                        LED1 = 1;
001690  A842C4     BSET LATA, #2
77:                        LED2 = 1;
001692  A862C4     BSET LATA, #3
78:                        LED3 = 1;
001694  A882CC     BSET LATB, #4
79:                        LED4 = 1;
001696  A882C4     BSET LATA, #4
80:                        delayMS(100);
001698  200640     MOV #0x64, W0
00169A  070F2A     RCALL delayMS
81:                        LED1 = 0;
00169C  A942C4     BCLR LATA, #2
82:                        LED2 = 0;
00169E  A962C4     BCLR LATA, #3
83:                        LED3 = 0;
0016A0  A982CC     BCLR LATB, #4
84:                        LED4 = 0;
0016A2  A982C4     BCLR LATA, #4
85:                        delayMS(100);
0016A4  200640     MOV #0x64, W0
0016A6  070F24     RCALL delayMS
86:                    }
87:                    delayMS(1000);
0016B0  203E80     MOV #0x3E8, W0
0016B2  070F1E     RCALL delayMS
88:                    
89:                    
90:                    //int hb = 0;
91:                
92:                
93:                    static unsigned char lowPriorityCounter = 0;
94:                
95:                    for (;;) {
96:                    // Only do these tasks every 100 - 150 ms
97:                        if (!lowPriorityCounter++) {
0016B4  20C0A4     MOV #0xC0A, W4
0016B6  784214     MOV.B [W4], W4
0016B8  FB8284     ZE W4, W5
0016BA  E90285     DEC W5, W5
0016BC  DE2ACF     LSR W5, #15, W5
0016BE  784285     MOV.B W5, W5
0016C0  E84204     INC.B W4, W4
0016C2  FD0200     EXCH W0, W4
0016C4  B7EC0A     MOV.B WREG, lowPriorityCounter
0016C6  FD0200     EXCH W0, W4
0016C8  52CFE0     SUB.B W5, #0x0, [W15]
0016CA  320005     BRA Z, 0x16D6
98:                            readTime();
0016CC  070A6C     RCALL readTime
99:                            updateLEDs();
0016CE  070EC2     RCALL updateLEDs
100:                           dailyReset();
0016D0  0701B5     RCALL dailyReset
101:                           zeroPower();
0016D2  070DDF     RCALL zeroPower
102:                           relayControl();
0016D4  070E2D     RCALL relayControl
103:               
104:               //            if (hb == 0) {
105:               //                hb = 1;
106:               //                LED1 = 1;
107:               //            } else {
108:               //                hb = 0;
109:               //                LED1 = 0;
110:               //            }
111:                       }
112:               
113:                       commFunctions();
0016D6  07F6E6     RCALL commFunctions
114:               
115:                       readButton();
0016D8  070229     RCALL readButton
116:                       storeToEE();
0016DA  070266     RCALL storeToEE
117:                   }
0016DC  37FFEB     BRA 0x16B4
118:               
119:               }
120:               
121:               
122:               /* Functions ******************************************************************/
123:               
124:               /* init
125:                * Calls each individual initialization method
126:                */
127:               void init(void) {
0016DE  FA0000     LNK #0x0
128:               
129:               
130:                   initI2C();
0016E0  070C32     RCALL initI2C
131:                   //            LED1 = 1;
132:                   //            LED2 = 1;
133:               
134:                   startClock();
0016E2  070B0C     RCALL startClock
135:                   setClock();
0016E4  070046     RCALL setClock
136:                   LED3 = 1;
0016E6  A882CC     BSET LATB, #4
137:                   initPorts();
0016E8  0701F3     RCALL initPorts
138:                   //            LED4 = 1;
139:                   initVars();
0016EA  07000F     RCALL initVars
140:                   readI2CPowerTimes();
0016EC  070B68     RCALL readI2CPowerTimes
141:                   initPWMeasurement();
0016EE  070D9C     RCALL initPWMeasurement
142:                   initUART();
0016F0  070C86     RCALL initUART
143:                   initOC_PWM();
0016F2  070E94     RCALL initOC_PWM
144:                   enableInterrupts();
0016F4  07020D     RCALL enableInterrupts
145:                   commandBuilder1("Reboot", "Now", "0");
0016F6  283F12     MOV #0x83F1, W2
0016F8  284071     MOV #0x8407, W1
0016FA  2840B0     MOV #0x840B, W0
0016FC  07FA15     RCALL commandBuilder1
146:                   commandBuilder1("Reboot", "Now", "0");
0016FE  283F12     MOV #0x83F1, W2
001700  284071     MOV #0x8407, W1
001702  2840B0     MOV #0x840B, W0
001704  07FA11     RCALL commandBuilder1
147:               }
001706  FA8000     ULNK
148:               
149:               /* initVars
150:                * Initializes variables to their starting values (usually 0)
151:                */
152:               void initVars(void) {
00170A  FA0000     LNK #0x0
153:                   resetTime = 59;
00170C  B3C3B4     MOV.B #0x3B, W4
00170E  FD0200     EXCH W0, W4
001710  B7E802     MOV.B WREG, resetTime
001712  FD0200     EXCH W0, W4
154:                   currentLoad = 0;
001714  B82260     MUL.UU W4, #0, W4
001716  885CB4     MOV W4, currentLoad
001718  885CC5     MOV W5, 0xB98
155:                   powerUsedMW = 0;
00171A  B82260     MUL.UU W4, #0, W4
00171C  8841A4     MOV W4, powerUsedMW
00171E  8841B5     MOV W5, 0x836
156:                   powerUsed = 0;
001720  B82260     MUL.UU W4, #0, W4
001722  885C74     MOV W4, powerUsed
001724  885C85     MOV W5, 0xB90
157:               
158:                   EEreadAll();
001726  070278     RCALL EEreadAll
159:               
160:                   // set up highAlloc and lowAlloc
161:                   if ((highAlloc == lowAlloc) && (powerAllocated != 0)) {
001728  804036     MOV highAlloc, W6
00172A  804047     MOV 0x808, W7
00172C  804054     MOV lowAlloc, W4
00172E  804065     MOV 0x80C, W5
001730  530F84     SUB W6, W4, [W15]
001732  5B8F85     SUBB W7, W5, [W15]
001734  3A001B     BRA NZ, 0x176C
001736  805C94     MOV powerAllocated, W4
001738  805CA5     MOV 0xB94, W5
00173A  520FE0     SUB W4, #0x0, [W15]
00173C  5A8FE0     SUBB W5, #0x0, [W15]
00173E  320016     BRA Z, 0x176C
162:                       highAlloc = powerAllocated;
001740  805C94     MOV powerAllocated, W4
001742  805CA5     MOV 0xB94, W5
001744  884034     MOV W4, highAlloc
001746  884045     MOV W5, 0x808
163:                       lowAlloc = (powerAllocated * 3) / 4;
001748  805C94     MOV powerAllocated, W4
00174A  805CA5     MOV 0xB94, W5
00174C  B92B63     MUL.SU W5, #3, W6
00174E  780306     MOV W6, W6
001750  B92060     MUL.SU W4, #0, W0
001752  780380     MOV W0, W7
001754  430307     ADD W6, W7, W6
001756  780284     MOV W4, W5
001758  200034     MOV #0x3, W4
00175A  B82A04     MUL.UU W5, W4, W4
00175C  430305     ADD W6, W5, W6
00175E  780286     MOV W6, W5
001760  DD2B4E     SL W5, #14, W6
001762  DE2242     LSR W4, #2, W4
001764  730204     IOR W6, W4, W4
001766  DE2AC2     LSR W5, #2, W5
001768  884054     MOV W4, lowAlloc
00176A  884065     MOV W5, 0x80C
164:                   }
165:               
166:                   setHighLow();
00176C  070245     RCALL setHighLow
167:               }
00176E  FA8000     ULNK
168:               
169:               /* setClocks()
170:                * At boot time, check which RTCC has the most recent time and synchronize them.
171:                * If this is a new build of the code, use the build time to set both RTCCs.
172:                */
173:               void setClock(void) {
001772  FA000E     LNK #0xE
174:                   unsigned char year, month, day, hour, minute, second;
175:                   readI2CTime(&year, &month, &day, &hour, &minute, &second);
001774  4702ED     ADD W14, #0xD, W5
001776  47026C     ADD W14, #0xC, W4
001778  4700EB     ADD W14, #0xB, W1
00177A  47006A     ADD W14, #0xA, W0
00177C  4703E9     ADD W14, #0x9, W7
00177E  470368     ADD W14, #0x8, W6
001780  780181     MOV W1, W3
001782  780100     MOV W0, W2
001784  780087     MOV W7, W1
001786  780006     MOV W6, W0
001788  070A18     RCALL readI2CTime
176:               
177:                   // Minute  6 bits // << 0
178:                   // Hour    5 bits // << 6
179:                   // Day     5 bits // << 11
180:                   // Month   4 bits // << 16
181:                   // Year    7 bits // << 20
182:                   // The entire date and time fits in a 32-bit long for comparison
183:                   unsigned long
184:                   buildDate = ((unsigned long) BUILD_YEAR << 20) +
00178A  B3C314     MOV.B #0x31, W4
00178C  FB0204     SE W4, W4
00178E  B9226A     MUL.SU W4, #10, W4
001790  780204     MOV W4, W4
001792  2FE205     MOV #0xFE20, W5
001794  428284     ADD W5, W4, W5
001796  B3C374     MOV.B #0x37, W4
001798  FB0204     SE W4, W4
00179A  B10304     SUB #0x30, W4
00179C  428204     ADD W5, W4, W4
00179E  DEA2CF     ASR W4, #15, W5
0017A0  DD23C4     SL W4, #4, W7
0017A2  200006     MOV #0x0, W6
001842  420306     ADD W4, W6, W6
001844  4A8387     ADDC W5, W7, W7
0018B0  431F04     ADD W6, W4, [W14++]
0018B2  4B9705     ADDC W7, W5, [W14--]
185:                           ((unsigned long) BUILD_MONTH << 16) +
0017A4  B3C625     MOV.B #0x62, W5
0017A6  B3C6E4     MOV.B #0x6E, W4
0017A8  52CF84     SUB.B W5, W4, [W15]
0017AA  3A000A     BRA NZ, 0x17C0
0017AC  B3C655     MOV.B #0x65, W5
0017AE  B3C614     MOV.B #0x61, W4
0017B0  52CF84     SUB.B W5, W4, [W15]
0017B2  3A0003     BRA NZ, 0x17BA
0017B4  200004     MOV #0x0, W4
0017B6  200015     MOV #0x1, W5
0017B8  370002     BRA 0x17BE
0017BA  200004     MOV #0x0, W4
0017BC  200065     MOV #0x6, W5
0017BE  370041     BRA 0x1842
0017C0  B3C625     MOV.B #0x62, W5
0017C2  B3C624     MOV.B #0x62, W4
0017C4  52CF84     SUB.B W5, W4, [W15]
0017C6  32003B     BRA Z, 0x183E
0017C8  B3C625     MOV.B #0x62, W5
0017CA  B3C724     MOV.B #0x72, W4
0017CC  52CF84     SUB.B W5, W4, [W15]
0017CE  3A000A     BRA NZ, 0x17E4
0017D0  B3C465     MOV.B #0x46, W5
0017D2  B3C4D4     MOV.B #0x4D, W4
0017D4  52CF84     SUB.B W5, W4, [W15]
0017D6  3A0003     BRA NZ, 0x17DE
0017D8  200004     MOV #0x0, W4
0017DA  200035     MOV #0x3, W5
0017DC  370002     BRA 0x17E2
0017DE  200004     MOV #0x0, W4
0017E0  200045     MOV #0x4, W5
0017E2  37002C     BRA 0x183C
0017E4  B3C625     MOV.B #0x62, W5
0017E6  B3C794     MOV.B #0x79, W4
0017E8  52CF84     SUB.B W5, W4, [W15]
0017EA  320026     BRA Z, 0x1838
0017EC  B3C625     MOV.B #0x62, W5
0017EE  B3C6C4     MOV.B #0x6C, W4
0017F0  52CF84     SUB.B W5, W4, [W15]
0017F2  32001F     BRA Z, 0x1832
0017F4  B3C625     MOV.B #0x62, W5
0017F6  B3C674     MOV.B #0x67, W4
0017F8  52CF84     SUB.B W5, W4, [W15]
0017FA  320018     BRA Z, 0x182C
0017FC  B3C625     MOV.B #0x62, W5
0017FE  B3C704     MOV.B #0x70, W4
001800  52CF84     SUB.B W5, W4, [W15]
001802  320011     BRA Z, 0x1826
001804  B3C625     MOV.B #0x62, W5
001806  B3C744     MOV.B #0x74, W4
001808  52CF84     SUB.B W5, W4, [W15]
00180A  32000A     BRA Z, 0x1820
00180C  B3C625     MOV.B #0x62, W5
00180E  B3C764     MOV.B #0x76, W4
001810  52CF84     SUB.B W5, W4, [W15]
001812  3A0003     BRA NZ, 0x181A
001814  200004     MOV #0x0, W4
001816  2000B5     MOV #0xB, W5
001818  370002     BRA 0x181E
00181A  200004     MOV #0x0, W4
00181C  2000C5     MOV #0xC, W5
00181E  370002     BRA 0x1824
001820  200004     MOV #0x0, W4
001822  2000A5     MOV #0xA, W5
001824  370002     BRA 0x182A
001826  200004     MOV #0x0, W4
001828  200095     MOV #0x9, W5
00182A  370002     BRA 0x1830
00182C  200004     MOV #0x0, W4
00182E  200085     MOV #0x8, W5
001830  370002     BRA 0x1836
001832  200004     MOV #0x0, W4
001834  200075     MOV #0x7, W5
001836  370002     BRA 0x183C
001838  200004     MOV #0x0, W4
00183A  200055     MOV #0x5, W5
00183C  370002     BRA 0x1842
00183E  200004     MOV #0x0, W4
001840  200025     MOV #0x2, W5
001874  420306     ADD W4, W6, W6
001876  4A8387     ADDC W5, W7, W7
186:                           ((unsigned long) BUILD_DAY << 11) +
001846  B3C205     MOV.B #0x20, W5
001848  B3C204     MOV.B #0x20, W4
00184A  52CF84     SUB.B W5, W4, [W15]
00184C  3A0004     BRA NZ, 0x1856
00184E  B3C344     MOV.B #0x34, W4
001850  FB0204     SE W4, W4
001852  B10304     SUB #0x30, W4
001854  37000A     BRA 0x186A
001856  B3C204     MOV.B #0x20, W4
001858  FB0204     SE W4, W4
00185A  B9226A     MUL.SU W4, #10, W4
00185C  780204     MOV W4, W4
00185E  2FE205     MOV #0xFE20, W5
001860  428284     ADD W5, W4, W5
001862  B3C344     MOV.B #0x34, W4
001864  FB0204     SE W4, W4
001866  B10304     SUB #0x30, W4
001868  428204     ADD W5, W4, W4
00186A  B92061     MUL.SU W4, #1, W0
00186C  DD0A4B     SL W1, #11, W4
00186E  DE02C5     LSR W0, #5, W5
001870  720285     IOR W4, W5, W5
001872  DD024B     SL W0, #11, W4
001896  420306     ADD W4, W6, W6
001898  4A8387     ADDC W5, W7, W7
187:                           ((unsigned long) BUILD_HOUR << 6) + BUILD_MINUTE,
001878  B3C314     MOV.B #0x31, W4
00187A  FB0204     SE W4, W4
00187C  B9226A     MUL.SU W4, #10, W4
00187E  780204     MOV W4, W4
001880  2FE205     MOV #0xFE20, W5
001882  428284     ADD W5, W4, W5
001884  B3C334     MOV.B #0x33, W4
001886  FB0204     SE W4, W4
001888  B10304     SUB #0x30, W4
00188A  428204     ADD W5, W4, W4
00188C  B92061     MUL.SU W4, #1, W0
00188E  DD0A46     SL W1, #6, W4
001890  DE02CA     LSR W0, #10, W5
001892  720285     IOR W4, W5, W5
001894  DD0246     SL W0, #6, W4
00189A  B3C334     MOV.B #0x33, W4
00189C  FB0204     SE W4, W4
00189E  B9226A     MUL.SU W4, #10, W4
0018A0  780204     MOV W4, W4
0018A2  2FE205     MOV #0xFE20, W5
0018A4  428284     ADD W5, W4, W5
0018A6  B3C314     MOV.B #0x31, W4
0018A8  FB0204     SE W4, W4
0018AA  B10304     SUB #0x30, W4
0018AC  428204     ADD W5, W4, W4
0018AE  DEA2CF     ASR W4, #15, W5
188:               
189:                           I2CDate = ((unsigned long) year << 20) +
0018B4  904A0E     MOV.B [W14+8], W4
0018B6  FB8204     ZE W4, W4
0018B8  200005     MOV #0x0, W5
0018BA  DD23C4     SL W4, #4, W7
0018BC  200006     MOV #0x0, W6
0018C8  420306     ADD W4, W6, W6
0018CA  4A8387     ADDC W5, W7, W7
0018F6  420206     ADD W4, W6, W4
0018F8  4A8287     ADDC W5, W7, W5
0018FA  980724     MOV W4, [W14+4]
0018FC  980735     MOV W5, [W14+6]
190:                           ((unsigned long) month << 16) +
0018BE  904A1E     MOV.B [W14+9], W4
0018C0  FB8204     ZE W4, W4
0018C2  200005     MOV #0x0, W5
0018C4  DD22C0     SL W4, #0, W5
0018C6  200004     MOV #0x0, W4
0018DA  420306     ADD W4, W6, W6
0018DC  4A8387     ADDC W5, W7, W7
191:                           ((unsigned long) day << 11) +
0018CC  904A2E     MOV.B [W14+10], W4
0018CE  FB8004     ZE W4, W0
0018D0  200001     MOV #0x0, W1
0018D2  DD0A4B     SL W1, #11, W4
0018D4  DE02C5     LSR W0, #5, W5
0018D6  720285     IOR W4, W5, W5
0018D8  DD024B     SL W0, #11, W4
0018EC  420306     ADD W4, W6, W6
0018EE  4A8387     ADDC W5, W7, W7
192:                           ((unsigned long) hour << 6) + minute;
0018DE  904A3E     MOV.B [W14+11], W4
0018E0  FB8004     ZE W4, W0
0018E2  200001     MOV #0x0, W1
0018E4  DD0A46     SL W1, #6, W4
0018E6  DE02CA     LSR W0, #10, W5
0018E8  720285     IOR W4, W5, W5
0018EA  DD0246     SL W0, #6, W4
0018F0  904A4E     MOV.B [W14+12], W4
0018F2  FB8204     ZE W4, W4
0018F4  200005     MOV #0x0, W5
193:               
194:                   // Find most recent date/time
195:                   if (buildDate > I2CDate) {
0018FE  90022E     MOV [W14+4], W4
001900  9002BE     MOV [W14+6], W5
001902  BE031E     MOV.D [W14], W6
001904  530F84     SUB W6, W4, [W15]
001906  5B8F85     SUBB W7, W5, [W15]
001908  360097     BRA LEU, 0x1A38
196:                       // Correct for the 17 seconds it takes to program the PIC
197:                       second = BUILD_SECOND + 17;
00190A  B3C334     MOV.B #0x33, W4
00190C  B9226A     MUL.SU W4, #10, W4
00190E  780204     MOV W4, W4
001910  784284     MOV.B W4, W5
001912  B3C354     MOV.B #0x35, W4
001914  42C204     ADD.B W5, W4, W4
001916  E84204     INC.B W4, W4
001918  984F54     MOV.B W4, [W14+13]
198:                       minute = BUILD_MINUTE;
00191A  B3C334     MOV.B #0x33, W4
00191C  B9226A     MUL.SU W4, #10, W4
00191E  780204     MOV W4, W4
001920  784284     MOV.B W4, W5
001922  B3C314     MOV.B #0x31, W4
001924  42C204     ADD.B W5, W4, W4
001926  524270     SUB.B W4, #0x10, W4
001928  984F44     MOV.B W4, [W14+12]
199:                       hour = BUILD_HOUR;
00192A  B3C314     MOV.B #0x31, W4
00192C  B9226A     MUL.SU W4, #10, W4
00192E  780204     MOV W4, W4
001930  784284     MOV.B W4, W5
001932  B3C334     MOV.B #0x33, W4
001934  42C204     ADD.B W5, W4, W4
001936  524270     SUB.B W4, #0x10, W4
001938  984F34     MOV.B W4, [W14+11]
200:                       if (second > 59) {
00193A  904ADE     MOV.B [W14+13], W5
00193C  B3C3B4     MOV.B #0x3B, W4
00193E  52CF84     SUB.B W5, W4, [W15]
001940  36000A     BRA LEU, 0x1956
201:                           minute++;
001942  904A4E     MOV.B [W14+12], W4
001944  E84204     INC.B W4, W4
001946  984F44     MOV.B W4, [W14+12]
202:                           if (minute > 59)
001948  904ACE     MOV.B [W14+12], W5
00194A  B3C3B4     MOV.B #0x3B, W4
00194C  52CF84     SUB.B W5, W4, [W15]
00194E  360003     BRA LEU, 0x1956
203:                               hour++;
001950  904A3E     MOV.B [W14+11], W4
001952  E84204     INC.B W4, W4
001954  984F34     MOV.B W4, [W14+11]
204:                       }
205:               
206:                       setI2CTime(BUILD_YEAR, BUILD_MONTH, BUILD_DAY, hour, minute % 60, second % 60);
001956  904A5E     MOV.B [W14+13], W4
001958  FB8284     ZE W4, W5
00195A  2003C4     MOV #0x3C, W4
00195C  090011     REPEAT #0x11
00195E  D88284     DIV.UW W5, W4
001960  780201     MOV W1, W4
001962  784184     MOV.B W4, W3
001964  904A4E     MOV.B [W14+12], W4
001966  FB8284     ZE W4, W5
001968  2003C4     MOV #0x3C, W4
00196A  090011     REPEAT #0x11
00196C  D88284     DIV.UW W5, W4
00196E  780201     MOV W1, W4
001970  784104     MOV.B W4, W2
001972  9048BE     MOV.B [W14+11], W1
001974  B3C205     MOV.B #0x20, W5
001976  B3C204     MOV.B #0x20, W4
001978  52CF84     SUB.B W5, W4, [W15]
00197A  3A0005     BRA NZ, 0x1986
00197C  B3C344     MOV.B #0x34, W4
00197E  784284     MOV.B W4, W5
001980  B3CD04     MOV.B #0xD0, W4
001982  42C384     ADD.B W5, W4, W7
001984  370007     BRA 0x1994
001986  B3C204     MOV.B #0x20, W4
001988  B9226A     MUL.SU W4, #10, W4
00198A  780204     MOV W4, W4
00198C  784284     MOV.B W4, W5
00198E  B3C344     MOV.B #0x34, W4
001990  42C204     ADD.B W5, W4, W4
001992  5243F0     SUB.B W4, #0x10, W7
001994  B3C625     MOV.B #0x62, W5
001996  B3C6E4     MOV.B #0x6E, W4
001998  52CF84     SUB.B W5, W4, [W15]
00199A  3A0009     BRA NZ, 0x19AE
00199C  B3C655     MOV.B #0x65, W5
00199E  B3C614     MOV.B #0x61, W4
0019A0  52CF84     SUB.B W5, W4, [W15]
0019A2  3A0002     BRA NZ, 0x19A8
0019A4  B3C014     MOV.B #0x1, W4
0019A6  370001     BRA 0x19AA
0019A8  B3C064     MOV.B #0x6, W4
0019AA  784304     MOV.B W4, W6
0019AC  370038     BRA 0x1A1E
0019AE  B3C625     MOV.B #0x62, W5
0019B0  B3C624     MOV.B #0x62, W4
0019B2  52CF84     SUB.B W5, W4, [W15]
0019B4  320032     BRA Z, 0x1A1A
0019B6  B3C625     MOV.B #0x62, W5
0019B8  B3C724     MOV.B #0x72, W4
0019BA  52CF84     SUB.B W5, W4, [W15]
0019BC  3A0008     BRA NZ, 0x19CE
0019BE  B3C465     MOV.B #0x46, W5
0019C0  B3C4D4     MOV.B #0x4D, W4
0019C2  52CF84     SUB.B W5, W4, [W15]
0019C4  3A0002     BRA NZ, 0x19CA
0019C6  B3C034     MOV.B #0x3, W4
0019C8  370001     BRA 0x19CC
0019CA  B3C044     MOV.B #0x4, W4
0019CC  370025     BRA 0x1A18
0019CE  B3C625     MOV.B #0x62, W5
0019D0  B3C794     MOV.B #0x79, W4
0019D2  52CF84     SUB.B W5, W4, [W15]
0019D4  320020     BRA Z, 0x1A16
0019D6  B3C625     MOV.B #0x62, W5
0019D8  B3C6C4     MOV.B #0x6C, W4
0019DA  52CF84     SUB.B W5, W4, [W15]
0019DC  32001A     BRA Z, 0x1A12
0019DE  B3C625     MOV.B #0x62, W5
0019E0  B3C674     MOV.B #0x67, W4
0019E2  52CF84     SUB.B W5, W4, [W15]
0019E4  320014     BRA Z, 0x1A0E
0019E6  B3C625     MOV.B #0x62, W5
0019E8  B3C704     MOV.B #0x70, W4
0019EA  52CF84     SUB.B W5, W4, [W15]
0019EC  32000E     BRA Z, 0x1A0A
0019EE  B3C625     MOV.B #0x62, W5
0019F0  B3C744     MOV.B #0x74, W4
0019F2  52CF84     SUB.B W5, W4, [W15]
0019F4  320008     BRA Z, 0x1A06
0019F6  B3C625     MOV.B #0x62, W5
0019F8  B3C764     MOV.B #0x76, W4
0019FA  52CF84     SUB.B W5, W4, [W15]
0019FC  3A0002     BRA NZ, 0x1A02
0019FE  B3C0B4     MOV.B #0xB, W4
001A00  370001     BRA 0x1A04
001A02  B3C0C4     MOV.B #0xC, W4
001A04  370001     BRA 0x1A08
001A06  B3C0A4     MOV.B #0xA, W4
001A08  370001     BRA 0x1A0C
001A0A  B3C094     MOV.B #0x9, W4
001A0C  370001     BRA 0x1A10
001A0E  B3C084     MOV.B #0x8, W4
001A10  370001     BRA 0x1A14
001A12  B3C074     MOV.B #0x7, W4
001A14  370001     BRA 0x1A18
001A16  B3C054     MOV.B #0x5, W4
001A18  370001     BRA 0x1A1C
001A1A  B3C024     MOV.B #0x2, W4
001A1C  784304     MOV.B W4, W6
001A1E  B3C314     MOV.B #0x31, W4
001A20  B9226A     MUL.SU W4, #10, W4
001A22  780204     MOV W4, W4
001A24  784284     MOV.B W4, W5
001A26  B3C374     MOV.B #0x37, W4
001A28  42C204     ADD.B W5, W4, W4
001A2A  524070     SUB.B W4, #0x10, W0
001A2C  784283     MOV.B W3, W5
001A2E  784202     MOV.B W2, W4
001A30  784181     MOV.B W1, W3
001A32  784107     MOV.B W7, W2
001A34  784086     MOV.B W6, W1
001A36  070904     RCALL setI2CTime
207:                   }
208:               }
001A38  FA8000     ULNK
209:               
210:               void dailyReset(void) {
001A3C  FA0000     LNK #0x0
211:                   if (((timeHour == resetHour) && (timeMinute == resetMinute) && (timeSecond == 0) && resetFlag)) {
001A3E  20B6D5     MOV #0xB6D, W5
001A40  784295     MOV.B [W5], W5
001A42  208034     MOV #0x803, W4
001A44  784214     MOV.B [W4], W4
001A46  52CF84     SUB.B W5, W4, [W15]
001A48  3A0036     BRA NZ, 0x1AB6
001A4A  20B6E5     MOV #0xB6E, W5
001A4C  784295     MOV.B [W5], W5
001A4E  208044     MOV #0x804, W4
001A50  784214     MOV.B [W4], W4
001A52  52CF84     SUB.B W5, W4, [W15]
001A54  3A0030     BRA NZ, 0x1AB6
001A56  208054     MOV #0x805, W4
001A58  784214     MOV.B [W4], W4
001A5A  524FE0     SUB.B W4, #0x0, [W15]
001A5C  3A002C     BRA NZ, 0x1AB6
001A5E  208184     MOV #0x818, W4
001A60  784214     MOV.B [W4], W4
001A62  524FE0     SUB.B W4, #0x0, [W15]
001A64  320028     BRA Z, 0x1AB6
212:                       resetFlag = 0;
001A66  EB4200     CLR.B W4
001A68  FD0200     EXCH W0, W4
001A6A  B7E818     MOV.B WREG, resetFlag
001A6C  FD0200     EXCH W0, W4
213:                       reset = 0;
001A6E  EB4200     CLR.B W4
001A70  FD0200     EXCH W0, W4
001A72  B7EC08     MOV.B WREG, reset
001A74  FD0200     EXCH W0, W4
214:                       totalUsed += powerUsed + extraPower;
001A76  805C76     MOV powerUsed, W6
001A78  805C87     MOV 0xB90, W7
001A7A  806024     MOV extraPower, W4
001A7C  806035     MOV 0xC06, W5
001A7E  420306     ADD W4, W6, W6
001A80  4A8387     ADDC W5, W7, W7
001A82  804084     MOV totalUsed, W4
001A84  804095     MOV 0x812, W5
001A86  420206     ADD W4, W6, W4
001A88  4A8287     ADDC W5, W7, W5
001A8A  884084     MOV W4, totalUsed
001A8C  884095     MOV W5, 0x812
215:                       previousDayUsed = powerUsed + extraPower;
001A8E  805C76     MOV powerUsed, W6
001A90  805C87     MOV 0xB90, W7
001A92  806024     MOV extraPower, W4
001A94  806035     MOV 0xC06, W5
001A96  420206     ADD W4, W6, W4
001A98  4A8287     ADDC W5, W7, W5
001A9A  8840A4     MOV W4, previousDayUsed
001A9C  8840B5     MOV W5, 0x816
216:                       powerUsedMW = 0;
001A9E  B82260     MUL.UU W4, #0, W4
001AA0  8841A4     MOV W4, powerUsedMW
001AA2  8841B5     MOV W5, 0x836
217:                       powerUsed = 0;
001AA4  B82260     MUL.UU W4, #0, W4
001AA6  885C74     MOV W4, powerUsed
001AA8  885C85     MOV W5, 0xB90
218:                       extraPower = 0;
001AAA  B82260     MUL.UU W4, #0, W4
001AAC  886024     MOV W4, extraPower
001AAE  886035     MOV W5, 0xC06
219:                       setRemoteStats();
001AB0  07FD3F     RCALL setRemoteStats
220:                       EEwriteTotals();
001AB2  070370     RCALL EEwriteTotals
001AB4  37000B     BRA 0x1ACC
221:                   } else if (!resetFlag && timeSecond) {
001AB6  208184     MOV #0x818, W4
001AB8  784214     MOV.B [W4], W4
001ABA  524FE0     SUB.B W4, #0x0, [W15]
001ABC  3A0007     BRA NZ, 0x1ACC
001ABE  208054     MOV #0x805, W4
001AC0  784214     MOV.B [W4], W4
001AC2  524FE0     SUB.B W4, #0x0, [W15]
001AC4  320003     BRA Z, 0x1ACC
222:                       resetFlag = 0xFF;
001AC6  EBC200     SETM.B W4
001AC8  780004     MOV W4, W0
001ACA  B7E818     MOV.B WREG, resetFlag
223:                   }
224:               }
001ACC  FA8000     ULNK
225:               
226:               /* initPorts
227:                * initializes ports for I/O
228:                * disables Int0 interrupt
229:                */
230:               void initPorts(void) {
001AD0  FA0000     LNK #0x0
231:               
232:                   // Pin 1:  RA5
233:                   // Pin 2:  RA0
234:                   // Pin 3:  RA1
235:                   // Pin 4:  RB0
236:                   // Pin 5:  RB1
237:                   // Pin 6:  RB2
238:                   // Pin 7:  RA2
239:                   // Pin 8:  RA3
240:                   // Pin 9:  RB4
241:                   // Pin 10: RA4
242:                   // Pin 11: RB7
243:                   // Pin 12: RB8
244:                   // Pin 13: RB9
245:                   // Pin 14: Vcap
246:                   // Pin 15: RB12
247:                   // Pin 16: RB13
248:                   // Pin 17: RB14
249:                   // Pin 18: RB15
250:                   // Pin 19: Vss
251:                   // Pin 20: Vdd
252:               
253:                   //Everything starts as an output, make input if needed
254:                   //OSCCON = 0b0000000010100101;
255:                   ANSA = 0x0000;
001AD2  EB0200     CLR W4
001AD4  882704     MOV W4, ANSA
256:                   ANSB = 0x0000;
001AD6  EB0200     CLR W4
001AD8  882714     MOV W4, ANSB
257:                   //PORTA = 0b1111111111111111;
258:                   PORTA = 0x0000;
001ADA  EB0200     CLR W4
001ADC  881614     MOV W4, PORTA
259:                   PORTB = 0x0000;
001ADE  EB0200     CLR W4
001AE0  881654     MOV W4, PORTB
260:               
261:                   // 1 for input, 0 for output
262:                   // initialize all to input (for safety - don't launch the missile)
263:                   TRISA = 0xFFFF;
001AE2  EB8200     SETM W4
001AE4  881604     MOV W4, TRISA
264:                   TRISB = 0xFFFF;
001AE6  EB8200     SETM W4
001AE8  881644     MOV W4, TRISB
265:               
266:                   /* TRIS setup for 20 pin PIC
267:                   _TRISB1 = 1;  // UART
268:                   _TRISB7 = 1;  // power sense
269:                   _TRISB12 = 1; // power sense
270:                   _TRISA1 = 0;  // RS485 send/recieve toggle
271:               
272:                   _TRISA3 = 1;  // no connection
273:                   _TRISA0 = 1;  // emergency button
274:                   _TRISB8 = 0;  // relay
275:                   _TRISB14 = 0; // relay
276:                   _TRISA4 = 1;  // oscillator
277:                   _TRISB4 = 1;  // oscillator
278:                    */
279:               
280:                   _TRISA0 = 1; // emergency button
001AEA  A802C0     BSET TRISA, #0
281:                   _TRISB0 = 0; // U2TX
001AEC  A902C8     BCLR TRISB, #0
282:                   _TRISB1 = 1; // U2RX
001AEE  A822C8     BSET TRISB, #1
283:                   _TRISB2 = 1; // U1RX
001AF0  A842C8     BSET TRISB, #2
284:                   _TRISA3 = 0; // buzzer
001AF2  A962C0     BCLR TRISA, #3
285:                   _TRISB7 = 0; // U1TX
001AF4  A9E2C8     BCLR TRISB, #7
286:                   _TRISB8 = 1; // I2C clock
001AF6  A802C9     BSET 0x2C9, #0
287:                   _TRISB9 = 1; // I2C data
001AF8  A822C9     BSET 0x2C9, #1
288:                   _TRISA7 = 1; // IC1 from MCP3909
001AFA  A8E2C0     BSET TRISA, #7
289:                   _TRISB11 = 0; // bar graph
001AFC  A962C9     BCLR 0x2C9, #3
290:                   _TRISB6 = 0; // relay control
001AFE  A9C2C8     BCLR TRISB, #6
291:                   _TRISB15 = 0; // MCP3909 !MCLR
001B00  A9E2C9     BCLR 0x2C9, #7
292:                   // 9 pins still available for GPIO
293:               
294:               
295:                   // disable int0 interrupt, just in case it initializes enabled
296:                   _INT0IE = 0;
001B02  A90094     BCLR IEC0, #0
297:               }
001B04  FA8000     ULNK
298:               
299:               void enablePullDownResistors(void) {
001B08  FA0000     LNK #0x0
300:               
301:                   _CN2PDE = 1; // pin 2 for emergency button
001B0A  A84056     BSET CNPD1, #2
302:               
303:               }
001B0C  FA8000     ULNK
304:               
305:               void enableInterrupts(void) {
001B10  FA0000     LNK #0x0
306:                   INTCON1 |= 0b1000000000000000;
001B12  800405     MOV INTCON1, W5
001B14  280004     MOV #0x8000, W4
001B16  720205     IOR W4, W5, W4
001B18  880404     MOV W4, INTCON1
307:               }
001B1A  FA8000     ULNK
308:               
309:               void disableInterrupts(void) {
001B1E  FA0000     LNK #0x0
310:                   INTCON1 &= 0b0111111111111111;
001B20  800405     MOV INTCON1, W5
001B22  27FFF4     MOV #0x7FFF, W4
001B24  628204     AND W5, W4, W4
001B26  880404     MOV W4, INTCON1
311:               }
001B28  FA8000     ULNK
312:               
313:               void readButton(void) {
001B2C  FA0000     LNK #0x0
314:                   static unsigned char lastSecond = 0;
315:               
316:                   if (BTN_EMER && emerButtonEnable && (lastSecond != timeSecond)) {
001B2E  801614     MOV PORTA, W4
001B30  620261     AND W4, #0x1, W4
001B32  520FE0     SUB W4, #0x0, [W15]
001B34  320037     BRA Z, 0x1BA4
001B36  208234     MOV #0x823, W4
001B38  784214     MOV.B [W4], W4
001B3A  524FE0     SUB.B W4, #0x0, [W15]
001B3C  320033     BRA Z, 0x1BA4
001B3E  20C095     MOV #0xC09, W5
001B40  784295     MOV.B [W5], W5
001B42  208054     MOV #0x805, W4
001B44  784214     MOV.B [W4], W4
001B46  52CF84     SUB.B W5, W4, [W15]
001B48  32002D     BRA Z, 0x1BA4
317:               
318:                       if ((powerUsedMW / 1000) > emerButtonAlloc) {
001B4A  8041A4     MOV powerUsedMW, W4
001B4C  8041B5     MOV 0x836, W5
001B4E  203E82     MOV #0x3E8, W2
001B50  200003     MOV #0x0, W3
001B52  BE0004     MOV.D W4, W0
001B54  07F3A4     RCALL ___udivsi3
001B56  BE0200     MOV.D W0, W4
001B58  BE0304     MOV.D W4, W6
001B5A  804124     MOV emerButtonAlloc, W4
001B5C  DEA2CF     ASR W4, #15, W5
001B5E  530F84     SUB W6, W4, [W15]
001B60  5B8F85     SUBB W7, W5, [W15]
001B62  360016     BRA LEU, 0x1B90
319:                           powerUsedMW = powerUsedMW - (((long) emerButtonAlloc) * 1000);
001B64  804124     MOV emerButtonAlloc, W4
001B66  DEA2CF     ASR W4, #15, W5
001B68  2FC186     MOV #0xFC18, W6
001B6A  B9AB06     MUL.SS W5, W6, W6
001B6C  780306     MOV W6, W6
001B6E  EB8380     SETM W7
001B70  B9A007     MUL.SS W4, W7, W0
001B72  780380     MOV W0, W7
001B74  430307     ADD W6, W7, W6
001B76  780284     MOV W4, W5
001B78  2FC184     MOV #0xFC18, W4
001B7A  B82A04     MUL.UU W5, W4, W4
001B7C  430305     ADD W6, W5, W6
001B7E  780286     MOV W6, W5
001B80  BE0304     MOV.D W4, W6
001B82  8041A4     MOV powerUsedMW, W4
001B84  8041B5     MOV 0x836, W5
001B86  420206     ADD W4, W6, W4
001B88  4A8287     ADDC W5, W7, W5
001B8A  8841A4     MOV W4, powerUsedMW
001B8C  8841B5     MOV W5, 0x836
001B8E  370006     BRA 0x1B9C
320:               
321:               
322:                       } else {
323:                           powerUsedMW = 0;
001B90  B82260     MUL.UU W4, #0, W4
001B92  8841A4     MOV W4, powerUsedMW
001B94  8841B5     MOV W5, 0x836
324:                           powerUsed = 0;
001B96  B82260     MUL.UU W4, #0, W4
001B98  885C74     MOV W4, powerUsed
001B9A  885C85     MOV W5, 0xB90
325:                       }
326:                       lastSecond = timeSecond;
001B9C  208054     MOV #0x805, W4
001B9E  784214     MOV.B [W4], W4
001BA0  780004     MOV W4, W0
001BA2  B7EC09     MOV.B WREG, lastSecond
327:                   }
328:               
329:               }
001BA4  FA8000     ULNK
330:               
331:               void storeToEE(void) {
001BA8  FA0000     LNK #0x0
332:                   if ((timeSecond == 30) && EEflag) {
001BAA  208054     MOV #0x805, W4
001BAC  784214     MOV.B [W4], W4
001BAE  524FFE     SUB.B W4, #0x1E, [W15]
001BB0  3A001B     BRA NZ, 0x1BE8
001BB2  208194     MOV #0x819, W4
001BB4  784214     MOV.B [W4], W4
001BB6  524FE0     SUB.B W4, #0x0, [W15]
001BB8  320017     BRA Z, 0x1BE8
333:                       //        if ((timeHour == 0) && (timeMinute == 0)) {
334:                       //            EEwriteDate();
335:                       //            EEflag = 0;
336:                       //        }
337:                       //
338:                       if ((timeMinute % 15) == 1 || (powerUsed >= powerAllocated)) {
001BBA  20B6E4     MOV #0xB6E, W4
001BBC  784214     MOV.B [W4], W4
001BBE  FB8284     ZE W4, W5
001BC0  2000F4     MOV #0xF, W4
001BC2  090011     REPEAT #0x11
001BC4  D88284     DIV.UW W5, W4
001BC6  780201     MOV W1, W4
001BC8  784204     MOV.B W4, W4
001BCA  524FE1     SUB.B W4, #0x1, [W15]
001BCC  320007     BRA Z, 0x1BDC
001BCE  805C76     MOV powerUsed, W6
001BD0  805C87     MOV 0xB90, W7
001BD2  805C94     MOV powerAllocated, W4
001BD4  805CA5     MOV 0xB94, W5
001BD6  530F84     SUB W6, W4, [W15]
001BD8  5B8F85     SUBB W7, W5, [W15]
001BDA  39000B     BRA NC, 0x1BF2
001BE6  370006     BRA 0x1BF4
001BF2  000000     NOP
339:                           EEwritePowerUsed();
001BDC  070426     RCALL EEwritePowerUsed
340:                           EEflag = 0;
001BDE  EB4200     CLR.B W4
001BE0  FD0200     EXCH W0, W4
001BE2  B7E819     MOV.B WREG, EEflag
001BE4  FD0200     EXCH W0, W4
341:                       }
342:                   } else {
343:                       EEflag = 1;
001BE8  B3C014     MOV.B #0x1, W4
001BEA  FD0200     EXCH W0, W4
001BEC  B7E819     MOV.B WREG, EEflag
001BEE  FD0200     EXCH W0, W4
001BF0  370001     BRA 0x1BF4
344:                   }
345:               }
001BF4  FA8000     ULNK
346:               
347:               void setHighLow() {
001BF8  FA0000     LNK #0x0
348:                   if (isHigh) {
001BFA  2080E4     MOV #0x80E, W4
001BFC  784214     MOV.B [W4], W4
001BFE  524FE0     SUB.B W4, #0x0, [W15]
001C00  320005     BRA Z, 0x1C0C
349:                       powerAllocated = highAlloc;
001C02  804034     MOV highAlloc, W4
001C04  804045     MOV 0x808, W5
001C06  885C94     MOV W4, powerAllocated
001C08  885CA5     MOV W5, 0xB94
001C0A  370004     BRA 0x1C14
350:                   } else {
351:                       powerAllocated = lowAlloc;
001C0C  804054     MOV lowAlloc, W4
001C0E  804065     MOV 0x80C, W5
001C10  885C94     MOV W4, powerAllocated
001C12  885CA5     MOV W5, 0xB94
352:                   }
353:               }
001C14  FA8000     ULNK
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/Power.c
1:                 /* File:    Power.c
2:                  * Authors: Dan Baker
3:                  *          Nathan Chaney
4:                  */
5:                 
6:                 /* Includes *******************************************************************/
7:                 
8:                 #include <p24FV32KA302.h>
9:                 #include "ExternPowerDefinitions.h"
10:                #include "ExternSharedDefinitions.h"
11:                #include "PowerPinDefinitions.h"
12:                
13:                // Must be less than   4294967296
14:                //#define SCALING_FACTOR 3785065107 // about 1044W. Should be 1050W
15:                //#define SCALING_FACTOR 1766363717 // about 1063W. Should be 1050W
16:                //#define SCALING_FACTOR 1852829074 // about 1063W. Should be 1050W
17:                #define SCALING_FACTOR 1930534614 // about 1063W. Should be 1050W
18:                #define INCREMENT_MWH  858
19:                
20:                
21:                static char interruptOccurred = 0;
22:                
23:                /* Functions ******************************************************************/
24:                
25:                void initPWMeasurement(void) {
003228  FA0000     LNK #0x0
26:                    // Two input capture modules set up for 32 bit cascaded operation.
27:                    // This will allow the timer to run for about 2048 seconds.
28:                
29:                    // I found help on this at Microchip forums
30:                    // http://www.microchip.com/forums/m747137-print.aspx
31:                
32:                    while (IC1CON1bits.ICBNE) IC1BUF;
00322A  370001     BRA 0x322E
00322C  800A24     MOV IC1BUF, W4
00322E  800A04     MOV IC1CON1, W4
003230  620268     AND W4, #0x8, W4
003232  520FE0     SUB W4, #0x0, [W15]
003234  3AFFFB     BRA NZ, 0x322C
33:                    while (IC2CON1bits.ICBNE) IC2BUF;
003236  370001     BRA 0x323A
003238  800A64     MOV IC2BUF, W4
00323A  800A44     MOV IC2CON1, W4
00323C  620268     AND W4, #0x8, W4
00323E  520FE0     SUB W4, #0x0, [W15]
003240  3AFFFB     BRA NZ, 0x3238
34:                
35:                    IC1CON1 = 0x0000; // Initialize IC modules
003242  EB0200     CLR W4
003244  880A04     MOV W4, IC1CON1
36:                    IC2CON1 = 0x0000;
003246  EB0200     CLR W4
003248  880A44     MOV W4, IC2CON1
37:                    IC1CON2 = 0x0000;
00324A  EB0200     CLR W4
00324C  880A14     MOV W4, IC1CON2
38:                    IC2CON2 = 0x0000;
00324E  EB0200     CLR W4
003250  880A54     MOV W4, IC2CON2
39:                
40:                    IC1CON2bits.IC32 = 0b1; // 32-bit timer mode
003252  A80143     BSET 0x143, #0
41:                    IC2CON2bits.IC32 = 0b1;
003254  A8014B     BSET 0x14B, #0
42:                
43:                    IC1CON1bits.IC1TSEL = 0b111; // Sync with Fosc / 2
003256  800A04     MOV IC1CON1, W4
003258  A0A004     BSET W4, #10
00325A  A0B004     BSET W4, #11
00325C  A0C004     BSET W4, #12
00325E  880A04     MOV W4, IC1CON1
44:                    IC2CON1bits.IC2TSEL = 0b111;
003260  800A44     MOV IC2CON1, W4
003262  A0A004     BSET W4, #10
003264  A0B004     BSET W4, #11
003266  A0C004     BSET W4, #12
003268  880A44     MOV W4, IC2CON1
45:                
46:                    IC2CON1bits.ICM = 0b011; // Enable IC2, capture on falling edge
00326A  800A44     MOV IC2CON1, W4
00326C  A00004     BSET W4, #0
00326E  A01004     BSET W4, #1
003270  A12004     BCLR W4, #2
003272  880A44     MOV W4, IC2CON1
47:                    IC1CON1bits.ICM = 0b011; // Enable IC1, capture on falling edge
003274  800A04     MOV IC1CON1, W4
003276  A00004     BSET W4, #0
003278  A01004     BSET W4, #1
00327A  A12004     BCLR W4, #2
00327C  880A04     MOV W4, IC1CON1
48:                
49:                    IPC0bits.IC1IP = 2; // Set interrupt priority
00327E  800524     MOV IPC0, W4
003280  A14004     BCLR W4, #4
003282  A05004     BSET W4, #5
003284  A16004     BCLR W4, #6
003286  880524     MOV W4, IPC0
50:                    IFS0bits.IC1IF = 0; // Clear interrupt flag
003288  A92084     BCLR IFS0, #1
51:                    IEC0bits.IC1IE = 1; // Enable IC1 interrupt
00328A  A82094     BSET IEC0, #1
52:                
53:                    MCP_RESET = 1; // Turn on the MCP3909 by setting the !RESET pin
00328C  A8E2CB     BSET 0x2CB, #7
54:                
55:                }
00328E  FA8000     ULNK
56:                
57:                void zeroPower(void) {
003292  FA0004     LNK #0x4
58:                
59:                    DWORD_VAL newPulseWidth;
60:                
61:                    // No reason to zero if power is already zero.
62:                    if (!currentLoad) return;
003294  805CB4     MOV currentLoad, W4
003296  805CC5     MOV 0xB98, W5
003298  520FE0     SUB W4, #0x0, [W15]
00329A  5A8FE0     SUBB W5, #0x0, [W15]
00329C  320046     BRA Z, 0x332A
00332A  000000     NOP
63:                
64:                    // If this changes to a 1 before the end of zeroing,
65:                    // a pulse occurred during the zeroing routine
66:                    // and we need to skip zeroing this time.
67:                    interruptOccurred = 0;
00329E  EB4200     CLR.B W4
0032A0  780004     MOV W4, W0
0032A2  B7EC20     MOV.B WREG, interruptOccurred
68:                
69:                    // Use ICxTMR here to get immediate values without resetting
70:                    // Using ICxBUF won't work
71:                    // As if interrupt would fire right now
72:                    newPulseWidth.word.LW = IC1TMR;
0032A4  800A34     MOV IC1TMR, W4
0032A6  780F04     MOV W4, [W14]
73:                    newPulseWidth.word.HW = IC2TMR;
0032A8  800A74     MOV IC2TMR, W4
0032AA  980714     MOV W4, [W14+2]
74:                    newPulseWidth.Val -= prevCapTime.Val;
0032AC  BE031E     MOV.D [W14], W6
0032AE  804184     MOV prevCapTime, W4
0032B0  804195     MOV 0x832, W5
0032B2  530204     SUB W6, W4, W4
0032B4  5B8285     SUBB W7, W5, W5
0032B6  BE8F04     MOV.D W4, [W14]
75:                
76:                    // If the interrupt fired right now, it would read a pulse 15% longer
77:                    // than the previous pulse, meaning a 15% decrease in load. Since the
78:                    // interrupt did not fire yet, the load has decreased more than 15%,
79:                    // so we can safely deduct 15%. If no power is being consumed, we will
80:                    // get a zero load eventually.
81:                    if ((newPulseWidth.Val * 7) / 8 > pulseWidth.Val) {
0032B8  BE021E     MOV.D [W14], W4
0032BA  B92B67     MUL.SU W5, #7, W6
0032BC  780306     MOV W6, W6
0032BE  B92060     MUL.SU W4, #0, W0
0032C0  780380     MOV W0, W7
0032C2  430307     ADD W6, W7, W6
0032C4  780284     MOV W4, W5
0032C6  200074     MOV #0x7, W4
0032C8  B82A04     MUL.UU W5, W4, W4
0032CA  430305     ADD W6, W5, W6
0032CC  780286     MOV W6, W5
0032CE  DE2BC3     LSR W5, #3, W7
0032D0  DD28CD     SL W5, #13, W1
0032D2  DE2343     LSR W4, #3, W6
0032D4  708306     IOR W1, W6, W6
0032D6  804164     MOV pulseWidth, W4
0032D8  804175     MOV 0x82E, W5
0032DA  530F84     SUB W6, W4, [W15]
0032DC  5B8F85     SUBB W7, W5, [W15]
0032DE  360026     BRA LEU, 0x332C
82:                        // If an interrupt occurred since we
83:                        // calculated newPulseWidth, don't zero.
84:                        if (!interruptOccurred) {
0032E0  20C204     MOV #0xC20, W4
0032E2  784214     MOV.B [W4], W4
0032E4  524FE0     SUB.B W4, #0x0, [W15]
0032E6  3A0022     BRA NZ, 0x332C
85:                            currentLoad = (currentLoad * 7) / 8;
0032E8  805CB4     MOV currentLoad, W4
0032EA  805CC5     MOV 0xB98, W5
0032EC  B92B67     MUL.SU W5, #7, W6
0032EE  780306     MOV W6, W6
0032F0  B92060     MUL.SU W4, #0, W0
0032F2  780380     MOV W0, W7
0032F4  430307     ADD W6, W7, W6
0032F6  780284     MOV W4, W5
0032F8  200074     MOV #0x7, W4
0032FA  B82A04     MUL.UU W5, W4, W4
0032FC  430305     ADD W6, W5, W6
0032FE  780286     MOV W6, W5
003300  DD2B4D     SL W5, #13, W6
003302  DE2243     LSR W4, #3, W4
003304  730204     IOR W6, W4, W4
003306  DE2AC3     LSR W5, #3, W5
003308  885CB4     MOV W4, currentLoad
00330A  885CC5     MOV W5, 0xB98
86:                            pulseWidth.Val = (pulseWidth.Val / 7) * 8;
00330C  804164     MOV pulseWidth, W4
00330E  804175     MOV 0x82E, W5
003310  200072     MOV #0x7, W2
003312  200003     MOV #0x0, W3
003314  BE0004     MOV.D W4, W0
003316  07E7C3     RCALL ___udivsi3
003318  BE0200     MOV.D W0, W4
00331A  BE0304     MOV.D W4, W6
00331C  DD3A43     SL W7, #3, W4
00331E  DE32CD     LSR W6, #13, W5
003320  720285     IOR W4, W5, W5
003322  DD3243     SL W6, #3, W4
003324  884164     MOV W4, pulseWidth
003326  884175     MOV W5, 0x82E
003328  370001     BRA 0x332C
87:                        }
88:                    }
89:                }
00332C  FA8000     ULNK
90:                
91:                void relayControl(void) {
003330  FA0000     LNK #0x0
92:                    static unsigned char lastSecond;
93:                
94:                    // turn it off
95:                    if ((timeSecond != lastSecond) && (powerAllocated <= powerUsed) && (relayActive)) {
003332  208055     MOV #0x805, W5
003334  784295     MOV.B [W5], W5
003336  20C214     MOV #0xC21, W4
003338  784214     MOV.B [W4], W4
00333A  52CF84     SUB.B W5, W4, [W15]
00333C  320015     BRA Z, 0x3368
00333E  805C96     MOV powerAllocated, W6
003340  805CA7     MOV 0xB94, W7
003342  805C74     MOV powerUsed, W4
003344  805C85     MOV 0xB90, W5
003346  530F84     SUB W6, W4, [W15]
003348  5B8F85     SUBB W7, W5, [W15]
00334A  3E000E     BRA GTU, 0x3368
00334C  2080F4     MOV #0x80F, W4
00334E  784214     MOV.B [W4], W4
003350  524FE0     SUB.B W4, #0x0, [W15]
003352  32000A     BRA Z, 0x3368
96:                        RELAY = 0;
003354  A9C2CA     BCLR PORTB, #6
97:                        // no reason to wait for zeroing if relay is off
98:                        currentLoad = 0;
003356  B82260     MUL.UU W4, #0, W4
003358  885CB4     MOV W4, currentLoad
00335A  885CC5     MOV W5, 0xB98
99:                        lastSecond = timeSecond;
00335C  208054     MOV #0x805, W4
00335E  784214     MOV.B [W4], W4
003360  FD0200     EXCH W0, W4
003362  B7EC21     MOV.B WREG, lastSecond
003364  FD0200     EXCH W0, W4
003366  370012     BRA 0x338C
100:                   }
101:                       // turn it on
102:                   else if ((timeSecond != lastSecond) && (powerAllocated > powerUsed)) {
003368  208055     MOV #0x805, W5
00336A  784295     MOV.B [W5], W5
00336C  20C214     MOV #0xC21, W4
00336E  784214     MOV.B [W4], W4
003370  52CF84     SUB.B W5, W4, [W15]
003372  32000C     BRA Z, 0x338C
003374  805C96     MOV powerAllocated, W6
003376  805CA7     MOV 0xB94, W7
003378  805C74     MOV powerUsed, W4
00337A  805C85     MOV 0xB90, W5
00337C  530F84     SUB W6, W4, [W15]
00337E  5B8F85     SUBB W7, W5, [W15]
003380  360005     BRA LEU, 0x338C
103:                       RELAY = 1;
003382  A8C2CA     BSET PORTB, #6
104:                       lastSecond = timeSecond;
003384  208054     MOV #0x805, W4
003386  784214     MOV.B [W4], W4
003388  780004     MOV W4, W0
00338A  B7EC21     MOV.B WREG, lastSecond
105:                   }
106:               }
00338C  FA8000     ULNK
107:               
108:               
109:               /* Interrupts *****************************************************************/
110:               
111:               /**
112:                * Input Capture Interrupt
113:                * Interrupt generated on for every period of logic input
114:                * signal. Read timer at the end of every period and calculate
115:                * period time.
116:                */
117:               void __attribute__((interrupt, no_auto_psv)) _IC1Interrupt(void) {
003390  F80036     PUSH RCOUNT
003392  BE9F80     MOV.D W0, [W15++]
003394  BE9F82     MOV.D W2, [W15++]
003396  BE9F84     MOV.D W4, [W15++]
003398  BE9F86     MOV.D W6, [W15++]
00339A  FA0004     LNK #0x4
118:               
119:                   DWORD_VAL newCapTime;
120:               
121:                   // Read input capture buffers
122:                   // Use ICxBUF here, not ICxTMR
123:                   while (IC1CON1bits.ICBNE) newCapTime.word.LW = IC1BUF;
00339C  370002     BRA 0x33A2
00339E  800A24     MOV IC1BUF, W4
0033A0  780F04     MOV W4, [W14]
0033A2  800A04     MOV IC1CON1, W4
0033A4  620268     AND W4, #0x8, W4
0033A6  520FE0     SUB W4, #0x0, [W15]
0033A8  3AFFFA     BRA NZ, 0x339E
124:                   while (IC2CON1bits.ICBNE) newCapTime.word.HW = IC2BUF;
0033AA  370002     BRA 0x33B0
0033AC  800A64     MOV IC2BUF, W4
0033AE  980714     MOV W4, [W14+2]
0033B0  800A44     MOV IC2CON1, W4
0033B2  620268     AND W4, #0x8, W4
0033B4  520FE0     SUB W4, #0x0, [W15]
0033B6  3AFFFA     BRA NZ, 0x33AC
125:               
126:                   // Calculate latest pulse width
127:                   pulseWidth.Val = newCapTime.Val - prevCapTime.Val;
0033B8  BE031E     MOV.D [W14], W6
0033BA  804184     MOV prevCapTime, W4
0033BC  804195     MOV 0x832, W5
0033BE  530204     SUB W6, W4, W4
0033C0  5B8285     SUBB W7, W5, W5
0033C2  884164     MOV W4, pulseWidth
0033C4  884175     MOV W5, 0x82E
128:                   prevCapTime.Val = newCapTime.Val;
0033C6  BE021E     MOV.D [W14], W4
0033C8  884184     MOV W4, prevCapTime
0033CA  884195     MOV W5, 0x832
129:               
130:                   // Calculate current load from pulse width
131:                   currentLoad = SCALING_FACTOR / (pulseWidth.Val / 10);
0033CC  804164     MOV pulseWidth, W4
0033CE  804175     MOV 0x82E, W5
0033D0  2000A2     MOV #0xA, W2
0033D2  200003     MOV #0x0, W3
0033D4  BE0004     MOV.D W4, W0
0033D6  07E763     RCALL ___udivsi3
0033D8  BE0200     MOV.D W0, W4
0033DA  BE0104     MOV.D W4, W2
0033DC  29ED60     MOV #0x9ED6, W0
0033DE  273111     MOV #0x7311, W1
0033E0  07E75E     RCALL ___udivsi3
0033E2  BE0200     MOV.D W0, W4
0033E4  885CB4     MOV W4, currentLoad
0033E6  885CC5     MOV W5, 0xB98
132:               
133:                   // Account energy used by last pulse
134:                   powerUsedMW += INCREMENT_MWH;
0033E8  8041A4     MOV powerUsedMW, W4
0033EA  8041B5     MOV 0x836, W5
0033EC  B035A4     ADD #0x35A, W4
0033EE  B08005     ADDC #0x0, W5
0033F0  8841A4     MOV W4, powerUsedMW
0033F2  8841B5     MOV W5, 0x836
135:                   powerUsed = powerUsedMW / 1000;
0033F4  8041A4     MOV powerUsedMW, W4
0033F6  8041B5     MOV 0x836, W5
0033F8  203E82     MOV #0x3E8, W2
0033FA  200003     MOV #0x0, W3
0033FC  BE0004     MOV.D W4, W0
0033FE  07E74F     RCALL ___udivsi3
003400  BE0200     MOV.D W0, W4
003402  885C74     MOV W4, powerUsed
003404  885C85     MOV W5, 0xB90
136:               
137:                   // Set a flag so we don't zero at the wrong time
138:                   interruptOccurred = 1;
003406  B3C014     MOV.B #0x1, W4
003408  780004     MOV W4, W0
00340A  B7EC20     MOV.B WREG, interruptOccurred
139:               
140:                   IFS0bits.IC1IF = 0; // Clear interrupt flag
00340C  A92084     BCLR IFS0, #1
141:               }
00340E  FA8000     ULNK
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/OC_PWM.c
1:                 #include <xc.h>
2:                 #include <p24FV32KA302.h>
3:                 #include "ExternSharedDefinitions.h"
4:                 #include "ExternPowerDefinitions.h"
5:                 
6:                 #define LED1_DIR TRISAbits.TRISA2
7:                 #define LED2_DIR TRISAbits.TRISA3
8:                 #define LED3_DIR TRISBbits.TRISB4
9:                 #define LED4_DIR TRISAbits.TRISA4
10:                
11:                #define LED1 LATAbits.LATA2
12:                #define LED2 LATAbits.LATA3
13:                #define LED3 LATBbits.LATB4
14:                #define LED4 LATAbits.LATA4
15:                
16:                void initOC_PWM(void) {
00341C  FA0000     LNK #0x0
17:                    OC2CON1 = 0; // Clear OC2 control registers
00341E  EB0200     CLR W4
003420  880CD4     MOV W4, OC2CON1
18:                    OC2CON2 = 0; // Clear OC2 control registers
003422  EB0200     CLR W4
003424  880CE4     MOV W4, OC2CON2
19:                
20:                    // Duty cycle = On-time / Period
21:                    OC2R  = 0;   // On-time
003426  EB0200     CLR W4
003428  880D04     MOV W4, OC2R
22:                    OC2RS = 110; // Period
00342A  2006E4     MOV #0x6E, W4
00342C  880CF4     MOV W4, OC2RS
23:                
24:                    OC2CON2bits.SYNCSEL = 0b11111; // Self-synchronize
00342E  800CE4     MOV OC2CON2, W4
003430  B301F4     IOR #0x1F, W4
003432  880CE4     MOV W4, OC2CON2
25:                    OC2CON1bits.OCTSEL  = 0b111;   // Clock source: system clock
003434  800CD4     MOV OC2CON1, W4
003436  A0A004     BSET W4, #10
003438  A0B004     BSET W4, #11
00343A  A0C004     BSET W4, #12
00343C  880CD4     MOV W4, OC2CON1
26:                    OC2CON1bits.OCM     = 0b110;   // Edge-aligned mode
00343E  800CD4     MOV OC2CON1, W4
003440  A10004     BCLR W4, #0
003442  A01004     BSET W4, #1
003444  A02004     BSET W4, #2
003446  880CD4     MOV W4, OC2CON1
27:                
28:                
29:                    LED1_DIR = 0;
003448  A942C0     BCLR TRISA, #2
30:                    LED2_DIR = 0;
00344A  A962C0     BCLR TRISA, #3
31:                    LED3_DIR = 0;
00344C  A982C8     BCLR TRISB, #4
32:                    LED4_DIR = 0;
00344E  A982C0     BCLR TRISA, #4
33:                
34:                }
003450  FA8000     ULNK
35:                // Set OC2R to any percent value 0 to 100
36:                void updateLEDs(void) {
003454  FA0000     LNK #0x0
37:                //    OC2R = (timeSecond % 11) * 10;
38:                    OC2R = (100 * (powerAllocated - powerUsed)) / powerAllocated;
003456  805C96     MOV powerAllocated, W6
003458  805CA7     MOV 0xB94, W7
00345A  805C74     MOV powerUsed, W4
00345C  805C85     MOV 0xB90, W5
00345E  530204     SUB W6, W4, W4
003460  5B8285     SUBB W7, W5, W5
003462  200646     MOV #0x64, W6
003464  B9AB06     MUL.SS W5, W6, W6
003466  780306     MOV W6, W6
003468  B92060     MUL.SU W4, #0, W0
00346A  780380     MOV W0, W7
00346C  430307     ADD W6, W7, W6
00346E  780284     MOV W4, W5
003470  200644     MOV #0x64, W4
003472  B82A04     MUL.UU W5, W4, W4
003474  430305     ADD W6, W5, W6
003476  780286     MOV W6, W5
003478  805C96     MOV powerAllocated, W6
00347A  805CA7     MOV 0xB94, W7
00347C  BE0106     MOV.D W6, W2
00347E  BE0004     MOV.D W4, W0
003480  07E70E     RCALL ___udivsi3
003482  BE0200     MOV.D W0, W4
003484  780204     MOV W4, W4
003486  880D04     MOV W4, OC2R
39:                
40:                #ifndef LEDS_FOR_DEBUG
41:                
42:                    // Update the 4 LEDs to show power remaining
43:                    if (OC2R > 75) {
003488  800D05     MOV OC2R, W5
00348A  2004B4     MOV #0x4B, W4
00348C  528F84     SUB W5, W4, [W15]
00348E  360005     BRA LEU, 0x349A
44:                        LED1 = 1;
003490  A842C4     BSET LATA, #2
45:                        LED2 = 1;
003492  A862C4     BSET LATA, #3
46:                        LED3 = 1;
003494  A882CC     BSET LATB, #4
47:                        LED4 = 1;
003496  A882C4     BSET LATA, #4
003498  37001D     BRA 0x34D4
48:                    } else if (OC2R > 50) {
00349A  800D05     MOV OC2R, W5
00349C  200324     MOV #0x32, W4
00349E  528F84     SUB W5, W4, [W15]
0034A0  360005     BRA LEU, 0x34AC
49:                        LED1 = 1;
0034A2  A842C4     BSET LATA, #2
50:                        LED2 = 1;
0034A4  A862C4     BSET LATA, #3
51:                        LED3 = 1;
0034A6  A882CC     BSET LATB, #4
52:                        LED4 = 0;
0034A8  A982C4     BCLR LATA, #4
0034AA  370014     BRA 0x34D4
53:                    } else if (OC2R > 25) {
0034AC  800D04     MOV OC2R, W4
0034AE  520FF9     SUB W4, #0x19, [W15]
0034B0  360005     BRA LEU, 0x34BC
54:                        LED1 = 1;
0034B2  A842C4     BSET LATA, #2
55:                        LED2 = 1;
0034B4  A862C4     BSET LATA, #3
56:                        LED3 = 0;
0034B6  A982CC     BCLR LATB, #4
57:                        LED4 = 0;
0034B8  A982C4     BCLR LATA, #4
0034BA  37000C     BRA 0x34D4
58:                    } else if (OC2R > 0) {
0034BC  800D04     MOV OC2R, W4
0034BE  520FE0     SUB W4, #0x0, [W15]
0034C0  320005     BRA Z, 0x34CC
59:                        LED1 = 1;
0034C2  A842C4     BSET LATA, #2
60:                        LED2 = 0;
0034C4  A962C4     BCLR LATA, #3
61:                        LED3 = 0;
0034C6  A982CC     BCLR LATB, #4
62:                        LED4 = 0;
0034C8  A982C4     BCLR LATA, #4
0034CA  370004     BRA 0x34D4
63:                    } else {
64:                        LED1 = 0;
0034CC  A942C4     BCLR LATA, #2
65:                        LED2 = 0;
0034CE  A962C4     BCLR LATA, #3
66:                        LED3 = 0;
0034D0  A982CC     BCLR LATB, #4
67:                        LED4 = 0;
0034D2  A982C4     BCLR LATA, #4
68:                    }
69:                
70:                #endif
71:                
72:                }
0034D4  FA8000     ULNK
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/I2C_RTCC.c
1:                 #include <xc.h>
2:                 #include <p24FV32KA302.h>
3:                 #include "ExternSharedDefinitions.h"
4:                 #include "ExternPowerDefinitions.h"
5:                 
6:                 #define RTCC_WRITE     0xDE
7:                 #define RTCC_READ      0xDF
8:                 #define RTCC_SECOND    0x00
9:                 #define RTCC_MINUTE    0x01
10:                #define RTCC_HOUR      0x02
11:                #define RTCC_WEEKDAY   0x03
12:                #define RTCC_DAY       0x04
13:                #define RTCC_MONTH     0x05
14:                #define RTCC_YEAR      0x06
15:                #define RTCC_PWRDNMIN  0x18
16:                #define RTCC_PWRDNHOUR 0x19
17:                #define RTCC_PWRDNDATE 0x1A
18:                #define RTCC_PWRDNMTH  0x1B
19:                #define RTCC_PWRUPMIN  0x1C
20:                #define RTCC_PWRUPHOUR 0x1D
21:                #define RTCC_PWRUPDATE 0x1E
22:                #define RTCC_PWRUPMTH  0x1F
23:                
24:                void readTime(void);
25:                void BeginSequentialReadI2C(char address);
26:                char SequentialReadI2C(void);
27:                void IdleI2C(void);
28:                void StartI2C(void);
29:                void StopI2C(void);
30:                void RestartI2C(void);
31:                void NackI2C(void);
32:                void AckI2C(void);
33:                void WriteI2C(unsigned char byte);
34:                unsigned int ReadI2C (void);
35:                char ReadI2CRegister(char address);
36:                
37:                // Set global time variables from RTCC registers
38:                void readTime(void) {
002BA6  FA0000     LNK #0x0
39:                    readI2CTime(&timeYear, &timeMonth, &timeDay, &timeHour, &timeMinute, &timeSecond);
002BA8  208055     MOV #0x805, W5
002BAA  20B6E4     MOV #0xB6E, W4
002BAC  20B6D3     MOV #0xB6D, W3
002BAE  208222     MOV #0x822, W2
002BB0  208211     MOV #0x821, W1
002BB2  208200     MOV #0x820, W0
002BB4  070002     RCALL readI2CTime
40:                }
002BB6  FA8000     ULNK
41:                
42:                // Read RTCC registers sequentially (fast)
43:                void readI2CTime(unsigned char* year, unsigned char* month, unsigned char* day,
44:                        unsigned char* hour, unsigned char* minute, unsigned char* second) {
002BBA  FA0012     LNK #0x12
002BBC  980730     MOV W0, [W14+6]
002BBE  980741     MOV W1, [W14+8]
002BC0  980752     MOV W2, [W14+10]
002BC2  980763     MOV W3, [W14+12]
002BC4  980774     MOV W4, [W14+14]
002BC6  980F05     MOV W5, [W14+16]
45:                
46:                    BeginSequentialReadI2C(RTCC_SECOND);
002BC8  EB4000     CLR.B W0
002BCA  0700BE     RCALL BeginSequentialReadI2C
47:                
48:                    char BCDSecond = SequentialReadI2C() & 0x7F; // Get Second
002BCC  0700D1     RCALL SequentialReadI2C
002BCE  784200     MOV.B W0, W4
002BD0  784284     MOV.B W4, W5
002BD2  A17405     BCLR.B W5, #7
002BD4  784F05     MOV.B W5, [W14]
49:                    char BCDMinute = SequentialReadI2C() & 0x7F; // Get Minute
002BD6  0700CC     RCALL SequentialReadI2C
002BD8  784200     MOV.B W0, W4
002BDA  A17404     BCLR.B W4, #7
002BDC  984714     MOV.B W4, [W14+1]
50:                    char BCDHour   = SequentialReadI2C() & 0x3F; // Get Hour
002BDE  0700C8     RCALL SequentialReadI2C
002BE0  784200     MOV.B W0, W4
002BE2  B243F4     AND.B #0x3F, W4
002BE4  984724     MOV.B W4, [W14+2]
51:                                     SequentialReadI2C();        // Discard Weekday
002BE6  0700C4     RCALL SequentialReadI2C
52:                    char BCDDay    = SequentialReadI2C() & 0x3F; // Get Day
002BE8  0700C3     RCALL SequentialReadI2C
002BEA  784200     MOV.B W0, W4
002BEC  B243F4     AND.B #0x3F, W4
002BEE  984734     MOV.B W4, [W14+3]
53:                    char BCDMonth  = SequentialReadI2C() & 0x1F; // Get Month
002BF0  0700BF     RCALL SequentialReadI2C
002BF2  784200     MOV.B W0, W4
002BF4  62427F     AND.B W4, #0x1F, W4
002BF6  984744     MOV.B W4, [W14+4]
54:                    char BCDYear   = SequentialReadI2C();        // Get Year
002BF8  0700BB     RCALL SequentialReadI2C
002BFA  784200     MOV.B W0, W4
002BFC  984754     MOV.B W4, [W14+5]
55:                
56:                    StopI2C();
002BFE  07017D     RCALL StopI2C
57:                
58:                    *year   = BcdToDec(BCDYear);
002C00  90405E     MOV.B [W14+5], W0
002C02  0701D4     RCALL BcdToDec
002C04  784200     MOV.B W0, W4
002C06  9002BE     MOV [W14+6], W5
002C08  784A84     MOV.B W4, [W5]
59:                    *month  = BcdToDec(BCDMonth);
002C0A  90404E     MOV.B [W14+4], W0
002C0C  0701CF     RCALL BcdToDec
002C0E  784200     MOV.B W0, W4
002C10  9002CE     MOV [W14+8], W5
002C12  784A84     MOV.B W4, [W5]
60:                    *day    = BcdToDec(BCDDay);
002C14  90403E     MOV.B [W14+3], W0
002C16  0701CA     RCALL BcdToDec
002C18  784200     MOV.B W0, W4
002C1A  9002DE     MOV [W14+10], W5
002C1C  784A84     MOV.B W4, [W5]
61:                    *hour   = BcdToDec(BCDHour);
002C1E  90402E     MOV.B [W14+2], W0
002C20  0701C5     RCALL BcdToDec
002C22  784200     MOV.B W0, W4
002C24  9002EE     MOV [W14+12], W5
002C26  784A84     MOV.B W4, [W5]
62:                    *minute = BcdToDec(BCDMinute);
002C28  90401E     MOV.B [W14+1], W0
002C2A  0701C0     RCALL BcdToDec
002C2C  784200     MOV.B W0, W4
002C2E  9002FE     MOV [W14+14], W5
002C30  784A84     MOV.B W4, [W5]
63:                    *second = BcdToDec(BCDSecond);
002C32  78401E     MOV.B [W14], W0
002C34  0701BB     RCALL BcdToDec
002C36  784200     MOV.B W0, W4
002C38  900A8E     MOV [W14+16], W5
002C3A  784A84     MOV.B W4, [W5]
64:                
65:                }
002C3C  FA8000     ULNK
66:                
67:                // Set time in RTCC registers
68:                void setI2CTime(unsigned char year, unsigned char month, unsigned char day,
69:                        unsigned char hour, unsigned char minute, unsigned char second) {
002C40  FA000C     LNK #0xC
002C42  984760     MOV.B W0, [W14+6]
002C44  984771     MOV.B W1, [W14+7]
002C46  984F02     MOV.B W2, [W14+8]
002C48  984F13     MOV.B W3, [W14+9]
002C4A  984F24     MOV.B W4, [W14+10]
002C4C  984F35     MOV.B W5, [W14+11]
70:                
71:                    char BCDSecond = DecToBcd(second),
002C4E  904A3E     MOV.B [W14+11], W4
002C50  784004     MOV.B W4, W0
002C52  0701C1     RCALL DecToBcd
002C54  784200     MOV.B W0, W4
002C56  984714     MOV.B W4, [W14+1]
72:                         BCDMinute = DecToBcd(minute),
002C58  904A2E     MOV.B [W14+10], W4
002C5A  784004     MOV.B W4, W0
002C5C  0701BC     RCALL DecToBcd
002C5E  784200     MOV.B W0, W4
002C60  984724     MOV.B W4, [W14+2]
73:                         BCDHour   = DecToBcd(hour) & 0x3F, // 24-hour time
002C62  904A1E     MOV.B [W14+9], W4
002C64  784004     MOV.B W4, W0
002C66  0701B7     RCALL DecToBcd
002C68  784200     MOV.B W0, W4
002C6A  B243F4     AND.B #0x3F, W4
002C6C  984734     MOV.B W4, [W14+3]
74:                         BCDDay    = DecToBcd(day),
002C6E  904A0E     MOV.B [W14+8], W4
002C70  784004     MOV.B W4, W0
002C72  0701B1     RCALL DecToBcd
002C74  784200     MOV.B W0, W4
002C76  984744     MOV.B W4, [W14+4]
75:                         BCDMonth  = DecToBcd(month),
002C78  90427E     MOV.B [W14+7], W4
002C7A  784004     MOV.B W4, W0
002C7C  0701AC     RCALL DecToBcd
002C7E  784200     MOV.B W0, W4
002C80  784F04     MOV.B W4, [W14]
76:                         BCDYear   = DecToBcd(year);
002C82  90426E     MOV.B [W14+6], W4
002C84  784004     MOV.B W4, W0
002C86  0701A7     RCALL DecToBcd
002C88  784200     MOV.B W0, W4
002C8A  984754     MOV.B W4, [W14+5]
77:                
78:                    if (year % 4)
002C8C  90426E     MOV.B [W14+6], W4
002C8E  624263     AND.B W4, #0x3, W4
002C90  524FE0     SUB.B W4, #0x0, [W15]
002C92  320003     BRA Z, 0x2C9A
79:                        BCDMonth &= 0x1F;     // Is not leap year
002C94  78421E     MOV.B [W14], W4
002C96  624F7F     AND.B W4, #0x1F, [W14]
002C98  370002     BRA 0x2C9E
80:                    else
81:                        BCDMonth |= 0x20;     // Is leap year
002C9A  B3C204     MOV.B #0x20, W4
002C9C  724F1E     IOR.B W4, [W14], [W14]
82:                
83:                    // Disable Oscillator
84:                    StartI2C();
002C9E  070124     RCALL StartI2C
85:                    WriteI2C(RTCC_WRITE);     // Device Address (RTCC) + Write Command
002CA0  B3CDE0     MOV.B #0xDE, W0
002CA2  07015A     RCALL WriteI2C
86:                    WriteI2C(RTCC_SECOND);    // Set address to seconds
002CA4  EB4000     CLR.B W0
002CA6  070158     RCALL WriteI2C
87:                    WriteI2C(0x00);           // Disable oscillator and set seconds to 0
002CA8  EB4000     CLR.B W0
002CAA  070156     RCALL WriteI2C
88:                    IdleI2C();
002CAC  070114     RCALL IdleI2C
89:                    StopI2C();
002CAE  070125     RCALL StopI2C
90:                    
91:                    // Set Time
92:                    StartI2C();
002CB0  07011B     RCALL StartI2C
93:                    WriteI2C(RTCC_WRITE);     // Device Address (RTCC) + Write Command
002CB2  B3CDE0     MOV.B #0xDE, W0
002CB4  070151     RCALL WriteI2C
94:                    WriteI2C(RTCC_MINUTE);    // Set address to minutes
002CB6  B3C010     MOV.B #0x1, W0
002CB8  07014F     RCALL WriteI2C
95:                    WriteI2C(BCDMinute);      // Send Minute
002CBA  90422E     MOV.B [W14+2], W4
002CBC  784004     MOV.B W4, W0
002CBE  07014C     RCALL WriteI2C
96:                    WriteI2C(BCDHour);        // Send Hour
002CC0  90423E     MOV.B [W14+3], W4
002CC2  784004     MOV.B W4, W0
002CC4  070149     RCALL WriteI2C
97:                    WriteI2C(0x08);           // Enable battery operation and set weekday to zero
002CC6  B3C080     MOV.B #0x8, W0
002CC8  070147     RCALL WriteI2C
98:                    WriteI2C(BCDDay);         // Send Date
002CCA  90424E     MOV.B [W14+4], W4
002CCC  784004     MOV.B W4, W0
002CCE  070144     RCALL WriteI2C
99:                    WriteI2C(BCDMonth);       // Send Month
002CD0  78421E     MOV.B [W14], W4
002CD2  784004     MOV.B W4, W0
002CD4  070141     RCALL WriteI2C
100:                   WriteI2C(BCDYear);        // Send Year
002CD6  90425E     MOV.B [W14+5], W4
002CD8  784004     MOV.B W4, W0
002CDA  07013E     RCALL WriteI2C
101:                   IdleI2C();
002CDC  0700FC     RCALL IdleI2C
102:                   StopI2C();
002CDE  07010D     RCALL StopI2C
103:               
104:                   // Enable Oscillator
105:                   StartI2C();
002CE0  070103     RCALL StartI2C
106:                   WriteI2C(RTCC_WRITE);     // Device Address (RTCC) + Write Command
002CE2  B3CDE0     MOV.B #0xDE, W0
002CE4  070139     RCALL WriteI2C
107:                   WriteI2C(RTCC_SECOND);    // Set address to seconds
002CE6  EB4000     CLR.B W0
002CE8  070137     RCALL WriteI2C
108:                   WriteI2C(0x80|BCDSecond); // Enable oscillator and set seconds
002CEA  90429E     MOV.B [W14+1], W5
002CEC  B3C804     MOV.B #0x80, W4
002CEE  72C204     IOR.B W5, W4, W4
002CF0  784004     MOV.B W4, W0
002CF2  070132     RCALL WriteI2C
109:                   IdleI2C();
002CF4  0700F0     RCALL IdleI2C
110:                   StopI2C();
002CF6  070101     RCALL StopI2C
111:               
112:               }
002CF8  FA8000     ULNK
113:               
114:               // Start RTCC in case it was stopped (dead or missing battery)
115:               void startClock(void) {
002CFC  FA0002     LNK #0x2
116:                   // Preserve seconds value in case RTCC was already running
117:                   char BCDSecond = ReadI2CRegister(RTCC_SECOND) & 0x7F;
002CFE  EB4000     CLR.B W0
002D00  07004A     RCALL ReadI2CRegister
002D02  784200     MOV.B W0, W4
002D04  784284     MOV.B W4, W5
002D06  A17405     BCLR.B W5, #7
002D08  784F05     MOV.B W5, [W14]
118:               
119:                   // Disable Oscillator
120:                   StartI2C();
002D0A  0700EE     RCALL StartI2C
121:                   WriteI2C(RTCC_WRITE);     // Device Address (RTCC) + Write Command
002D0C  B3CDE0     MOV.B #0xDE, W0
002D0E  070124     RCALL WriteI2C
122:                   WriteI2C(RTCC_SECOND);    // Set address to seconds
002D10  EB4000     CLR.B W0
002D12  070122     RCALL WriteI2C
123:                   WriteI2C(0x00);           // Disable oscillator and set seconds to 0
002D14  EB4000     CLR.B W0
002D16  070120     RCALL WriteI2C
124:                   IdleI2C();
002D18  0700DE     RCALL IdleI2C
125:                   StopI2C();
002D1A  0700EF     RCALL StopI2C
126:               
127:                   // Set Time
128:                   StartI2C();
002D1C  0700E5     RCALL StartI2C
129:                   WriteI2C(RTCC_WRITE);     // Device Address (RTCC) + Write Command
002D1E  B3CDE0     MOV.B #0xDE, W0
002D20  07011B     RCALL WriteI2C
130:                   WriteI2C(RTCC_WEEKDAY);   // Set address to weekday
002D22  B3C030     MOV.B #0x3, W0
002D24  070119     RCALL WriteI2C
131:                   WriteI2C(0x08);           // Enable battery operation and set weekday to zero
002D26  B3C080     MOV.B #0x8, W0
002D28  070117     RCALL WriteI2C
132:                   IdleI2C();
002D2A  0700D5     RCALL IdleI2C
133:                   StopI2C();
002D2C  0700E6     RCALL StopI2C
134:               
135:                   // Enable Oscillator
136:                   StartI2C();
002D2E  0700DC     RCALL StartI2C
137:                   WriteI2C(RTCC_WRITE);     // Device Address (RTCC) + Write Command
002D30  B3CDE0     MOV.B #0xDE, W0
002D32  070112     RCALL WriteI2C
138:                   WriteI2C(RTCC_SECOND);    // Set address to seconds
002D34  EB4000     CLR.B W0
002D36  070110     RCALL WriteI2C
139:                   WriteI2C(0x80|BCDSecond); // Enable oscillator and restore seconds
002D38  B3C804     MOV.B #0x80, W4
002D3A  72421E     IOR.B W4, [W14], W4
002D3C  784004     MOV.B W4, W0
002D3E  07010C     RCALL WriteI2C
140:                   IdleI2C();
002D40  0700CA     RCALL IdleI2C
141:                   StopI2C();
002D42  0700DB     RCALL StopI2C
142:               }
002D44  FA8000     ULNK
143:               
144:               // Set up sequential read from MCP7940, starting at given address
145:               void BeginSequentialReadI2C(char address) {
002D48  FA0002     LNK #0x2
002D4A  784F00     MOV.B W0, [W14]
146:                   StartI2C();
002D4C  0700CD     RCALL StartI2C
147:                   WriteI2C(RTCC_WRITE);        // Enter Write Mode
002D4E  B3CDE0     MOV.B #0xDE, W0
002D50  070103     RCALL WriteI2C
148:                   WriteI2C(address);           // Beginning address for reading
002D52  78421E     MOV.B [W14], W4
002D54  784004     MOV.B W4, W0
002D56  070100     RCALL WriteI2C
149:                   IdleI2C();
002D58  0700BE     RCALL IdleI2C
150:                   RestartI2C();
002D5A  0700D8     RCALL RestartI2C
151:                   WriteI2C(RTCC_READ);         // Enter Read Mode
002D5C  B3CDF0     MOV.B #0xDF, W0
002D5E  0700FC     RCALL WriteI2C
152:                   while(I2C1STATbits.ACKSTAT); // Wait for ACK from slave
002D60  000000     NOP
002D62  801045     MOV I2C1STAT, W5
002D64  280004     MOV #0x8000, W4
002D66  628204     AND W5, W4, W4
002D68  520FE0     SUB W4, #0x0, [W15]
002D6A  3AFFFB     BRA NZ, 0x2D62
153:               }
002D6C  FA8000     ULNK
154:               
155:               // Read next register
156:               char SequentialReadI2C(void) {
002D70  FA0000     LNK #0x0
157:                   while (I2C1STATbits.TRSTAT); // Wait for bus to be idle
002D72  000000     NOP
002D74  801045     MOV I2C1STAT, W5
002D76  240004     MOV #0x4000, W4
002D78  628204     AND W5, W4, W4
002D7A  520FE0     SUB W4, #0x0, [W15]
002D7C  3AFFFB     BRA NZ, 0x2D74
158:                   I2C1CONbits.RCEN = 1;        // Gives control of clock to Slave device
002D7E  A86206     BSET I2C1CON, #3
159:                   while(!I2C1STATbits.RBF);    // Waits for register to fill up
002D80  000000     NOP
002D82  801044     MOV I2C1STAT, W4
002D84  620262     AND W4, #0x2, W4
002D86  520FE0     SUB W4, #0x0, [W15]
002D88  32FFFC     BRA Z, 0x2D82
160:                   AckI2C();                    // Ask for next byte
002D8A  0700D3     RCALL AckI2C
161:                   return I2C1RCV;              // Returns data
002D8C  801004     MOV I2C1RCV, W4
002D8E  784204     MOV.B W4, W4
162:               }
002D90  784004     MOV.B W4, W0
163:               
164:               // Read one byte from given memory address
165:               char ReadI2CRegister(char address) {
002D96  FA0004     LNK #0x4
002D98  984720     MOV.B W0, [W14+2]
166:                   StartI2C();
002D9A  0700A6     RCALL StartI2C
167:                   WriteI2C(RTCC_WRITE); // Enter Write Mode
002D9C  B3CDE0     MOV.B #0xDE, W0
002D9E  0700DC     RCALL WriteI2C
168:                   WriteI2C(address);    // Set address for reading
002DA0  90422E     MOV.B [W14+2], W4
002DA2  784004     MOV.B W4, W0
002DA4  0700D9     RCALL WriteI2C
169:                   IdleI2C();
002DA6  070097     RCALL IdleI2C
170:                   RestartI2C();
002DA8  0700B1     RCALL RestartI2C
171:                   WriteI2C(RTCC_READ);  // Enter Read Mode
002DAA  B3CDF0     MOV.B #0xDF, W0
002DAC  0700D5     RCALL WriteI2C
172:                   char returnValue = ReadI2C();
002DAE  0700E6     RCALL ReadI2C
002DB0  780200     MOV W0, W4
002DB2  784F04     MOV.B W4, [W14]
173:                   StopI2C();
002DB4  0700A2     RCALL StopI2C
174:               
175:                   return returnValue;
002DB6  78421E     MOV.B [W14], W4
176:               }
002DB8  784004     MOV.B W4, W0
177:               
178:               // Read PowerDown and PowerUp time from RTCC into global strings
179:               void readI2CPowerTimes(void) {
002DBE  FA0008     LNK #0x8
180:                   unsigned char
181:                           powerDownMinute, powerDownHour, powerDownDay, powerDownMonth,
182:                           powerUpMinute,   powerUpHour,   powerUpDay,   powerUpMonth;
183:               
184:                   BeginSequentialReadI2C(RTCC_PWRDNMIN);
002DC0  B3C180     MOV.B #0x18, W0
002DC2  07FFC2     RCALL BeginSequentialReadI2C
185:               
186:                   powerDownMinute = SequentialReadI2C() & 0x7F;
002DC4  07FFD5     RCALL SequentialReadI2C
002DC6  784200     MOV.B W0, W4
002DC8  784284     MOV.B W4, W5
002DCA  A17405     BCLR.B W5, #7
002DCC  784F05     MOV.B W5, [W14]
187:                   powerDownHour   = SequentialReadI2C() & 0x3F;
002DCE  07FFD0     RCALL SequentialReadI2C
002DD0  784200     MOV.B W0, W4
002DD2  B243F4     AND.B #0x3F, W4
002DD4  984714     MOV.B W4, [W14+1]
188:                   powerDownDay    = SequentialReadI2C() & 0x3F;
002DD6  07FFCC     RCALL SequentialReadI2C
002DD8  784200     MOV.B W0, W4
002DDA  B243F4     AND.B #0x3F, W4
002DDC  984724     MOV.B W4, [W14+2]
189:                   powerDownMonth  = SequentialReadI2C() & 0x1F;
002DDE  07FFC8     RCALL SequentialReadI2C
002DE0  784200     MOV.B W0, W4
002DE2  62427F     AND.B W4, #0x1F, W4
002DE4  984734     MOV.B W4, [W14+3]
190:                   powerUpMinute   = SequentialReadI2C() & 0x7F;
002DE6  07FFC4     RCALL SequentialReadI2C
002DE8  784200     MOV.B W0, W4
002DEA  A17404     BCLR.B W4, #7
002DEC  984744     MOV.B W4, [W14+4]
191:                   powerUpHour     = SequentialReadI2C() & 0x3F;
002DEE  07FFC0     RCALL SequentialReadI2C
002DF0  784200     MOV.B W0, W4
002DF2  B243F4     AND.B #0x3F, W4
002DF4  984754     MOV.B W4, [W14+5]
192:                   powerUpDay      = SequentialReadI2C() & 0x3F;
002DF6  07FFBC     RCALL SequentialReadI2C
002DF8  784200     MOV.B W0, W4
002DFA  B243F4     AND.B #0x3F, W4
002DFC  984764     MOV.B W4, [W14+6]
193:                   powerUpMonth    = SequentialReadI2C() & 0x1F;
002DFE  07FFB8     RCALL SequentialReadI2C
002E00  784200     MOV.B W0, W4
002E02  62427F     AND.B W4, #0x1F, W4
002E04  984774     MOV.B W4, [W14+7]
194:               
195:                   StopI2C();
002E06  070079     RCALL StopI2C
196:               
197:                   stringCopy("HH:MM:DD:MM", powerDownTime);
002E08  20A981     MOV #0xA98, W1
002E0A  284240     MOV #0x8424, W0
002E0C  07EE18     RCALL stringCopy
198:                   stringCopy("HH:MM:DD:MM", powerUpTime);
002E0E  20AA41     MOV #0xAA4, W1
002E10  284240     MOV #0x8424, W0
002E12  07EE15     RCALL stringCopy
199:               
200:                   powerDownTime[ 0] = (powerDownHour   >> 4) + 0x30;
002E14  90421E     MOV.B [W14+1], W4
002E16  FB8204     ZE W4, W4
002E18  DE2244     LSR W4, #4, W4
002E1A  784204     MOV.B W4, W4
002E1C  B04304     ADD.B #0x30, W4
002E1E  780004     MOV W4, W0
002E20  B7EA98     MOV.B WREG, powerDownTime
201:                   powerDownTime[ 1] = (powerDownHour       ) + 0x30;
002E22  90421E     MOV.B [W14+1], W4
002E24  B04304     ADD.B #0x30, W4
002E26  780004     MOV W4, W0
002E28  B7EA99     MOV.B WREG, 0xA99
202:                   powerDownTime[ 3] = (powerDownMinute >> 4) + 0x30;
002E2A  78429E     MOV.B [W14], W5
002E2C  FB8205     ZE W5, W4
002E2E  DE2244     LSR W4, #4, W4
002E30  784204     MOV.B W4, W4
002E32  B04304     ADD.B #0x30, W4
002E34  780004     MOV W4, W0
002E36  B7EA9B     MOV.B WREG, 0xA9B
203:                   powerDownTime[ 4] = (powerDownMinute     ) + 0x30;
002E38  B3C305     MOV.B #0x30, W5
002E3A  42C21E     ADD.B W5, [W14], W4
002E3C  780004     MOV W4, W0
002E3E  B7EA9C     MOV.B WREG, 0xA9C
204:                   powerDownTime[ 6] = (powerDownDay    >> 4) + 0x30;
002E40  90422E     MOV.B [W14+2], W4
002E42  FB8204     ZE W4, W4
002E44  DE2244     LSR W4, #4, W4
002E46  784204     MOV.B W4, W4
002E48  B04304     ADD.B #0x30, W4
002E4A  780004     MOV W4, W0
002E4C  B7EA9E     MOV.B WREG, 0xA9E
205:                   powerDownTime[ 7] = (powerDownDay        ) + 0x30;
002E4E  90422E     MOV.B [W14+2], W4
002E50  B04304     ADD.B #0x30, W4
002E52  780004     MOV W4, W0
002E54  B7EA9F     MOV.B WREG, 0xA9F
206:                   powerDownTime[ 9] = (powerDownMonth  >> 4) + 0x30;
002E56  90423E     MOV.B [W14+3], W4
002E58  FB8204     ZE W4, W4
002E5A  DE2244     LSR W4, #4, W4
002E5C  784204     MOV.B W4, W4
002E5E  B04304     ADD.B #0x30, W4
002E60  780004     MOV W4, W0
002E62  B7EAA1     MOV.B WREG, 0xAA1
207:                   powerDownTime[10] = (powerDownMonth      ) + 0x30;
002E64  90423E     MOV.B [W14+3], W4
002E66  B04304     ADD.B #0x30, W4
002E68  780004     MOV W4, W0
002E6A  B7EAA2     MOV.B WREG, 0xAA2
208:               
209:                   powerUpTime  [ 0] = (powerUpHour     >> 4) + 0x30;
002E6C  90425E     MOV.B [W14+5], W4
002E6E  FB8204     ZE W4, W4
002E70  DE2244     LSR W4, #4, W4
002E72  784204     MOV.B W4, W4
002E74  B04304     ADD.B #0x30, W4
002E76  780004     MOV W4, W0
002E78  B7EAA4     MOV.B WREG, powerUpTime
210:                   powerUpTime  [ 1] = (powerUpHour         ) + 0x30;
002E7A  90425E     MOV.B [W14+5], W4
002E7C  B04304     ADD.B #0x30, W4
002E7E  780004     MOV W4, W0
002E80  B7EAA5     MOV.B WREG, 0xAA5
211:                   powerUpTime  [ 3] = (powerUpMinute   >> 4) + 0x30;
002E82  90424E     MOV.B [W14+4], W4
002E84  FB8204     ZE W4, W4
002E86  DE2244     LSR W4, #4, W4
002E88  784204     MOV.B W4, W4
002E8A  B04304     ADD.B #0x30, W4
002E8C  780004     MOV W4, W0
002E8E  B7EAA7     MOV.B WREG, 0xAA7
212:                   powerUpTime  [ 4] = (powerUpMinute       ) + 0x30;
002E90  90424E     MOV.B [W14+4], W4
002E92  B04304     ADD.B #0x30, W4
002E94  780004     MOV W4, W0
002E96  B7EAA8     MOV.B WREG, 0xAA8
213:                   powerUpTime  [ 6] = (powerUpDay      >> 4) + 0x30;
002E98  90426E     MOV.B [W14+6], W4
002E9A  FB8204     ZE W4, W4
002E9C  DE2244     LSR W4, #4, W4
002E9E  784204     MOV.B W4, W4
002EA0  B04304     ADD.B #0x30, W4
002EA2  780004     MOV W4, W0
002EA4  B7EAAA     MOV.B WREG, 0xAAA
214:                   powerUpTime  [ 7] = (powerUpDay          ) + 0x30;
002EA6  90426E     MOV.B [W14+6], W4
002EA8  B04304     ADD.B #0x30, W4
002EAA  780004     MOV W4, W0
002EAC  B7EAAB     MOV.B WREG, 0xAAB
215:                   powerUpTime  [ 9] = (powerUpMonth    >> 4) + 0x30;
002EAE  90427E     MOV.B [W14+7], W4
002EB0  FB8204     ZE W4, W4
002EB2  DE2244     LSR W4, #4, W4
002EB4  784204     MOV.B W4, W4
002EB6  B04304     ADD.B #0x30, W4
002EB8  780004     MOV W4, W0
002EBA  B7EAAD     MOV.B WREG, 0xAAD
216:                   powerUpTime  [10] = (powerUpMonth        ) + 0x30;
002EBC  90427E     MOV.B [W14+7], W4
002EBE  B04304     ADD.B #0x30, W4
002EC0  780004     MOV W4, W0
002EC2  B7EAAE     MOV.B WREG, 0xAAE
217:                   powerDownTime[11] = powerUpTime[11] = 0;
002EC4  EB4200     CLR.B W4
002EC6  780004     MOV W4, W0
002EC8  B7EAAF     MOV.B WREG, 0xAAF
002ECA  20AAF4     MOV #0xAAF, W4
002ECC  784214     MOV.B [W4], W4
002ECE  780004     MOV W4, W0
002ED0  B7EAA3     MOV.B WREG, 0xAA3
218:               }
002ED2  FA8000     ULNK
219:               
220:               // Wait for bus to be idle
221:               void IdleI2C(void) {
002ED6  FA0000     LNK #0x0
222:                   while (I2C1STATbits.TRSTAT);
002ED8  000000     NOP
002EDA  801045     MOV I2C1STAT, W5
002EDC  240004     MOV #0x4000, W4
002EDE  628204     AND W5, W4, W4
002EE0  520FE0     SUB W4, #0x0, [W15]
002EE2  3AFFFB     BRA NZ, 0x2EDA
223:               }
002EE4  FA8000     ULNK
224:               
225:               // Generate an I2C start condition
226:               void StartI2C(void) {
002EE8  FA0000     LNK #0x0
227:                   I2C1CONbits.SEN = 1;        // Generate start condition
002EEA  A80206     BSET I2C1CON, #0
228:                   while (I2C1CONbits.SEN);    // Wait for start
002EEC  000000     NOP
002EEE  801034     MOV I2C1CON, W4
002EF0  620261     AND W4, #0x1, W4
002EF2  520FE0     SUB W4, #0x0, [W15]
002EF4  3AFFFC     BRA NZ, 0x2EEE
229:                   //return(I2C1STATbits.S);   // Optional - return status
230:               }
002EF6  FA8000     ULNK
231:               
232:               // Generate an I2C stop condition
233:               void StopI2C(void) {
002EFA  FA0000     LNK #0x0
234:                   I2C1CONbits.PEN = 1;        // Generate stop condition
002EFC  A84206     BSET I2C1CON, #2
235:                   while (I2C1CONbits.PEN);    // Wait for stop
002EFE  000000     NOP
002F00  801034     MOV I2C1CON, W4
002F02  620264     AND W4, #0x4, W4
002F04  520FE0     SUB W4, #0x0, [W15]
002F06  3AFFFC     BRA NZ, 0x2F00
236:                   //return(I2C1STATbits.P);   // Optional - return status
237:               }
002F08  FA8000     ULNK
238:               
239:               // Generate an I2C restart condition
240:               void RestartI2C(void) {
002F0C  FA0000     LNK #0x0
241:                   I2C1CONbits.RSEN = 1;       // Generate restart
002F0E  A82206     BSET I2C1CON, #1
242:                   while (I2C1CONbits.RSEN);   // Wait for restart
002F10  000000     NOP
002F12  801034     MOV I2C1CON, W4
002F14  620262     AND W4, #0x2, W4
002F16  520FE0     SUB W4, #0x0, [W15]
002F18  3AFFFC     BRA NZ, 0x2F12
243:                   //return(I2C1STATbits.S);   // Optional - return status
244:               }
002F1A  FA8000     ULNK
245:               
246:               // Generate an I2C not acknowledge condition
247:               void NackI2C(void) {
002F1E  FA0000     LNK #0x0
248:                   I2C1CONbits.ACKDT = 1;
002F20  A8A206     BSET I2C1CON, #5
249:                   I2C1CONbits.ACKEN = 1;
002F22  A88206     BSET I2C1CON, #4
250:                   while(I2C1CONbits.ACKEN);
002F24  000000     NOP
002F26  801034     MOV I2C1CON, W4
002F28  620270     AND W4, #0x10, W4
002F2A  520FE0     SUB W4, #0x0, [W15]
002F2C  3AFFFC     BRA NZ, 0x2F26
251:               }
002F2E  FA8000     ULNK
252:               
253:               // Generate an I2C acknowledge condition
254:               void AckI2C(void) {
002F32  FA0000     LNK #0x0
255:                   I2C1CONbits.ACKDT = 0;
002F34  A9A206     BCLR I2C1CON, #5
256:                   I2C1CONbits.ACKEN = 1;
002F36  A88206     BSET I2C1CON, #4
257:                   while(I2C1CONbits.ACKEN);
002F38  000000     NOP
002F3A  801034     MOV I2C1CON, W4
002F3C  620270     AND W4, #0x10, W4
002F3E  520FE0     SUB W4, #0x0, [W15]
002F40  3AFFFC     BRA NZ, 0x2F3A
258:               }
002F42  FA8000     ULNK
259:               
260:               // Set up I2C module
261:               void initI2C(void) {
002F46  FA0000     LNK #0x0
262:                   I2C1CONbits.A10M = 0;   // Use 7-bit slave addresses
002F48  A94207     BCLR 0x207, #2
263:                   I2C1CONbits.DISSLW = 1; // Disable Slew rate control
002F4A  A82207     BSET 0x207, #1
264:                   I2C1CONbits.IPMIEN = 0; // should be set to 0 when master
002F4C  A96207     BCLR 0x207, #3
265:                   //IFS1bits.MI2C1IF = 0; // Disable Interupt
266:               
267:                   I2C1BRG = 0x4E;         // If Fcy = 8 Mhz this will set the baud to 100 khz
002F4E  2004E4     MOV #0x4E, W4
002F50  881024     MOV W4, I2C1BRG
268:                   I2C1CONbits.I2CEN = 1;  // Configures I2C pins as I2C (on pins 17 an 18)
002F52  A8E207     BSET 0x207, #7
269:               }
002F54  FA8000     ULNK
270:               
271:               // Transmit one byte
272:               void WriteI2C(unsigned char byte) {
002F58  FA0002     LNK #0x2
002F5A  784F00     MOV.B W0, [W14]
273:                   while (I2C1STATbits.TRSTAT); // Wait for bus to be idle
002F5C  000000     NOP
002F5E  801045     MOV I2C1STAT, W5
002F60  240004     MOV #0x4000, W4
002F62  628204     AND W5, W4, W4
002F64  520FE0     SUB W4, #0x0, [W15]
002F66  3AFFFB     BRA NZ, 0x2F5E
274:                   I2C1TRN = byte;              // Load byte to I2C1 Transmit buffer
002F68  78429E     MOV.B [W14], W5
002F6A  FB8205     ZE W5, W4
002F6C  881014     MOV W4, I2C1TRN
275:                   while (I2C1STATbits.TBF);	 // Wait for data transmission
002F6E  000000     NOP
002F70  801044     MOV I2C1STAT, W4
002F72  620261     AND W4, #0x1, W4
002F74  520FE0     SUB W4, #0x0, [W15]
002F76  3AFFFC     BRA NZ, 0x2F70
276:               }
002F78  FA8000     ULNK
277:               
278:               // Read one byte from bus
279:               unsigned int ReadI2C (void) {
002F7C  FA0000     LNK #0x0
280:                   while (I2C1STATbits.TRSTAT); // Wait for bus to be idle
002F7E  000000     NOP
002F80  801045     MOV I2C1STAT, W5
002F82  240004     MOV #0x4000, W4
002F84  628204     AND W5, W4, W4
002F86  520FE0     SUB W4, #0x0, [W15]
002F88  3AFFFB     BRA NZ, 0x2F80
281:                   I2C1CONbits.ACKDT = 1;       // Prepares to send NACK
002F8A  A8A206     BSET I2C1CON, #5
282:                   I2C1CONbits.RCEN = 1;        // Gives control of clock to Slave device
002F8C  A86206     BSET I2C1CON, #3
283:                   while(!I2C1STATbits.RBF);    // Waits for register to fill up
002F8E  000000     NOP
002F90  801044     MOV I2C1STAT, W4
002F92  620262     AND W4, #0x2, W4
002F94  520FE0     SUB W4, #0x0, [W15]
002F96  32FFFC     BRA Z, 0x2F90
284:                   I2C1CONbits.ACKEN = 1;       // Sends NACK or ACK set above
002F98  A88206     BSET I2C1CON, #4
285:                   while(I2C1CONbits.ACKEN);    // Waits till ACK is sent (hardware reset)
002F9A  000000     NOP
002F9C  801034     MOV I2C1CON, W4
002F9E  620270     AND W4, #0x10, W4
002FA0  520FE0     SUB W4, #0x0, [W15]
002FA2  3AFFFC     BRA NZ, 0x2F9C
286:                   return I2C1RCV;              // Returns data
002FA4  801004     MOV I2C1RCV, W4
287:               }
002FA6  780004     MOV W4, W0
288:               
289:               char BcdToDec(char val) {
002FAC  FA0002     LNK #0x2
002FAE  784F00     MOV.B W0, [W14]
290:                   return (val / 16 * 10) + (val % 16);
002FB0  FB029E     SE [W14], W5
002FB2  200104     MOV #0x10, W4
002FB4  090011     REPEAT #0x11
002FB6  D80284     DIV.SW W5, W4
002FB8  780200     MOV W0, W4
002FBA  784204     MOV.B W4, W4
002FBC  B9226A     MUL.SU W4, #10, W4
002FBE  780204     MOV W4, W4
002FC0  784284     MOV.B W4, W5
002FC2  FB031E     SE [W14], W6
002FC4  200104     MOV #0x10, W4
002FC6  090011     REPEAT #0x11
002FC8  D80304     DIV.SW W6, W4
002FCA  780201     MOV W1, W4
002FCC  784204     MOV.B W4, W4
002FCE  42C204     ADD.B W5, W4, W4
291:               }
002FD0  784004     MOV.B W4, W0
292:               
293:               char DecToBcd(char val) {
002FD6  FA0002     LNK #0x2
002FD8  784F00     MOV.B W0, [W14]
294:                   return (val / 10 * 16) + (val % 10);
002FDA  FB029E     SE [W14], W5
002FDC  2000A4     MOV #0xA, W4
002FDE  090011     REPEAT #0x11
002FE0  D80284     DIV.SW W5, W4
002FE2  780200     MOV W0, W4
002FE4  784204     MOV.B W4, W4
002FE6  200045     MOV #0x4, W5
002FE8  DD2285     SL W4, W5, W5
002FEA  FB031E     SE [W14], W6
002FEC  2000A4     MOV #0xA, W4
002FEE  090011     REPEAT #0x11
002FF0  D80304     DIV.SW W6, W4
002FF2  780201     MOV W1, W4
002FF4  784204     MOV.B W4, W4
002FF6  42C204     ADD.B W5, W4, W4
295:               }
002FF8  784004     MOV.B W4, W0
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/EEPROM.c
1:                 /* File:    EEPROM.c
2:                  * Authors: Dan Baker
3:                  *          Nathan Chaney
4:                  */
5:                 
6:                 /* Includes *******************************************************************/
7:                 
8:                 #include <p24FV32KA302.h>
9:                 #include "ExternPowerDefinitions.h"
10:                #include "ExternSharedDefinitions.h"
11:                
12:                
13:                /* Functions ******************************************************************/
14:                
15:                void EEreadAll(void) {
001C18  FA0000     LNK #0x0
16:                    EEreadPassword();
001C1A  07000A     RCALL EEreadPassword
17:                    EEreadPowerAlloc();
001C1C  07010C     RCALL EEreadPowerAlloc
18:                //    EEreadDate();
19:                    EEreadEmerButton();
001C1E  070141     RCALL EEreadEmerButton
20:                    EEreadResetTime();
001C20  070183     RCALL EEreadResetTime
21:                    EEreadAlarm();
001C22  0701CE     RCALL EEreadAlarm
22:                    EEreadTotals();
001C24  070274     RCALL EEreadTotals
23:                    EEreadPowerUsed();
001C26  070335     RCALL EEreadPowerUsed
24:                    EEreadHL();
001C28  0706C0     RCALL EEreadHL
25:                    EEreadRelay();
001C2A  0706F5     RCALL EEreadRelay
26:                }
001C2C  FA8000     ULNK
27:                
28:                void EEreadPassword(void) {
001C30  FA0002     LNK #0x2
29:                    while (_WR) continue;
001C32  000000     NOP
001C34  370001     BRA 0x1C38
001C36  000000     NOP
001C38  803B05     MOV NVMCON, W5
001C3A  280004     MOV #0x8000, W4
001C3C  628204     AND W5, W4, W4
001C3E  520FE0     SUB W4, #0x0, [W15]
001C40  3AFFFA     BRA NZ, 0x1C36
30:                
31:                    TBLPAG = __builtin_tblpage(&EEpassword0);
001C42  2007F4     MOV #0x7F, W4
001C44  784204     MOV.B W4, W4
001C46  780004     MOV W4, W0
001C48  B7E032     MOV.B WREG, TBLPAG
32:                    unsigned int offset = __builtin_tbloffset(&EEpassword0);
001C4A  2FE004     MOV #0xFE00, W4
001C4C  780F04     MOV W4, [W14]
33:                    passwordSet[0] = (char) __builtin_tblrdl(offset);
001C4E  78021E     MOV [W14], W4
001C50  BA0214     TBLRDL [W4], W4
001C52  784204     MOV.B W4, W4
001C54  780004     MOV W4, W0
001C56  B7E81A     MOV.B WREG, passwordSet
34:                
35:                    TBLPAG = __builtin_tblpage(&EEpassword1);
001C58  2007F4     MOV #0x7F, W4
001C5A  784204     MOV.B W4, W4
001C5C  780004     MOV W4, W0
001C5E  B7E032     MOV.B WREG, TBLPAG
36:                    offset = __builtin_tbloffset(&EEpassword1);
001C60  2FE024     MOV #0xFE02, W4
001C62  780F04     MOV W4, [W14]
37:                    passwordSet[1] = (char) __builtin_tblrdl(offset);
001C64  78021E     MOV [W14], W4
001C66  BA0214     TBLRDL [W4], W4
001C68  784204     MOV.B W4, W4
001C6A  780004     MOV W4, W0
001C6C  B7E81B     MOV.B WREG, 0x81B
38:                
39:                    TBLPAG = __builtin_tblpage(&EEpassword2);
001C6E  2007F4     MOV #0x7F, W4
001C70  784204     MOV.B W4, W4
001C72  780004     MOV W4, W0
001C74  B7E032     MOV.B WREG, TBLPAG
40:                    offset = __builtin_tbloffset(&EEpassword2);
001C76  2FE044     MOV #0xFE04, W4
001C78  780F04     MOV W4, [W14]
41:                    passwordSet[2] = (char) __builtin_tblrdl(offset);
001C7A  78021E     MOV [W14], W4
001C7C  BA0214     TBLRDL [W4], W4
001C7E  784204     MOV.B W4, W4
001C80  780004     MOV W4, W0
001C82  B7E81C     MOV.B WREG, 0x81C
42:                
43:                    TBLPAG = __builtin_tblpage(&EEpassword3);
001C84  2007F4     MOV #0x7F, W4
001C86  784204     MOV.B W4, W4
001C88  780004     MOV W4, W0
001C8A  B7E032     MOV.B WREG, TBLPAG
44:                    offset = __builtin_tbloffset(&EEpassword3);
001C8C  2FE064     MOV #0xFE06, W4
001C8E  780F04     MOV W4, [W14]
45:                    passwordSet[3] = (char) __builtin_tblrdl(offset);
001C90  78021E     MOV [W14], W4
001C92  BA0214     TBLRDL [W4], W4
001C94  784204     MOV.B W4, W4
001C96  780004     MOV W4, W0
001C98  B7E81D     MOV.B WREG, 0x81D
46:                
47:                    TBLPAG = __builtin_tblpage(&EEpassword4);
001C9A  2007F4     MOV #0x7F, W4
001C9C  784204     MOV.B W4, W4
001C9E  780004     MOV W4, W0
001CA0  B7E032     MOV.B WREG, TBLPAG
48:                    offset = __builtin_tbloffset(&EEpassword4);
001CA2  2FE084     MOV #0xFE08, W4
001CA4  780F04     MOV W4, [W14]
49:                    passwordSet[4] = (char) __builtin_tblrdl(offset);
001CA6  78021E     MOV [W14], W4
001CA8  BA0214     TBLRDL [W4], W4
001CAA  784204     MOV.B W4, W4
001CAC  780004     MOV W4, W0
001CAE  B7E81E     MOV.B WREG, 0x81E
50:                
51:                    TBLPAG = __builtin_tblpage(&EEpassword5);
001CB0  2007F4     MOV #0x7F, W4
001CB2  784204     MOV.B W4, W4
001CB4  780004     MOV W4, W0
001CB6  B7E032     MOV.B WREG, TBLPAG
52:                    offset = __builtin_tbloffset(&EEpassword5);
001CB8  2FE0A4     MOV #0xFE0A, W4
001CBA  780F04     MOV W4, [W14]
53:                    passwordSet[5] = (char) __builtin_tblrdl(offset);
001CBC  78021E     MOV [W14], W4
001CBE  BA0214     TBLRDL [W4], W4
001CC0  784204     MOV.B W4, W4
001CC2  780004     MOV W4, W0
001CC4  B7E81F     MOV.B WREG, 0x81F
54:                }
001CC6  FA8000     ULNK
55:                
56:                void EEwritePassword(void) {
001CCA  FA0002     LNK #0x2
57:                
58:                    // char 0
59:                    while (_WR) continue;
001CCC  000000     NOP
001CCE  370001     BRA 0x1CD2
001CD0  000000     NOP
001CD2  803B05     MOV NVMCON, W5
001CD4  280004     MOV #0x8000, W4
001CD6  628204     AND W5, W4, W4
001CD8  520FE0     SUB W4, #0x0, [W15]
001CDA  3AFFFA     BRA NZ, 0x1CD0
60:                    NVMCON = 0x4004;
001CDC  240044     MOV #0x4004, W4
001CDE  883B04     MOV W4, NVMCON
61:                
62:                    TBLPAG = __builtin_tblpage(&EEpassword0);
001CE0  2007F4     MOV #0x7F, W4
001CE2  784204     MOV.B W4, W4
001CE4  FD0200     EXCH W0, W4
001CE6  B7E032     MOV.B WREG, TBLPAG
001CE8  FD0200     EXCH W0, W4
63:                    unsigned int offset = __builtin_tbloffset(&EEpassword0);
001CEA  2FE004     MOV #0xFE00, W4
001CEC  780F04     MOV W4, [W14]
64:                    __builtin_tblwtl(offset, passwordSet[0]);
001CEE  2081A4     MOV #0x81A, W4
001CF0  784214     MOV.B [W4], W4
001CF2  FB0284     SE W4, W5
001CF4  78021E     MOV [W14], W4
001CF6  BB0A05     TBLWTL W5, [W4]
65:                
66:                    asm volatile ("disi #5");
001CF8  FC0005     DISI #0x5
67:                    __builtin_write_NVM();
001CFA  200554     MOV #0x55, W4
001CFC  883B34     MOV W4, NVMKEY
001CFE  200AA4     MOV #0xAA, W4
001D00  883B34     MOV W4, NVMKEY
001D02  A8E761     BSET 0x761, #7
001D04  000000     NOP
001D06  000000     NOP
68:                
69:                    // char 1
70:                    while (_WR) continue;
001D08  000000     NOP
001D0A  370001     BRA 0x1D0E
001D0C  000000     NOP
001D0E  803B05     MOV NVMCON, W5
001D10  280004     MOV #0x8000, W4
001D12  628204     AND W5, W4, W4
001D14  520FE0     SUB W4, #0x0, [W15]
001D16  3AFFFA     BRA NZ, 0x1D0C
71:                    NVMCON = 0x4004;
001D18  240044     MOV #0x4004, W4
001D1A  883B04     MOV W4, NVMCON
72:                
73:                    TBLPAG = __builtin_tblpage(&EEpassword1);
001D1C  2007F4     MOV #0x7F, W4
001D1E  784204     MOV.B W4, W4
001D20  FD0200     EXCH W0, W4
001D22  B7E032     MOV.B WREG, TBLPAG
001D24  FD0200     EXCH W0, W4
74:                    offset = __builtin_tbloffset(&EEpassword1);
001D26  2FE024     MOV #0xFE02, W4
001D28  780F04     MOV W4, [W14]
75:                    __builtin_tblwtl(offset, passwordSet[1]);
001D2A  2081B4     MOV #0x81B, W4
001D2C  784214     MOV.B [W4], W4
001D2E  FB0284     SE W4, W5
001D30  78021E     MOV [W14], W4
001D32  BB0A05     TBLWTL W5, [W4]
76:                
77:                    asm volatile ("disi #5");
001D34  FC0005     DISI #0x5
78:                    __builtin_write_NVM();
001D36  200554     MOV #0x55, W4
001D38  883B34     MOV W4, NVMKEY
001D3A  200AA4     MOV #0xAA, W4
001D3C  883B34     MOV W4, NVMKEY
001D3E  A8E761     BSET 0x761, #7
001D40  000000     NOP
001D42  000000     NOP
79:                
80:                    // char 2
81:                    while (_WR) continue;
001D44  000000     NOP
001D46  370001     BRA 0x1D4A
001D48  000000     NOP
001D4A  803B05     MOV NVMCON, W5
001D4C  280004     MOV #0x8000, W4
001D4E  628204     AND W5, W4, W4
001D50  520FE0     SUB W4, #0x0, [W15]
001D52  3AFFFA     BRA NZ, 0x1D48
82:                    NVMCON = 0x4004;
001D54  240044     MOV #0x4004, W4
001D56  883B04     MOV W4, NVMCON
83:                
84:                    TBLPAG = __builtin_tblpage(&EEpassword2);
001D58  2007F4     MOV #0x7F, W4
001D5A  784204     MOV.B W4, W4
001D5C  FD0200     EXCH W0, W4
001D5E  B7E032     MOV.B WREG, TBLPAG
001D60  FD0200     EXCH W0, W4
85:                    offset = __builtin_tbloffset(&EEpassword2);
001D62  2FE044     MOV #0xFE04, W4
001D64  780F04     MOV W4, [W14]
86:                    __builtin_tblwtl(offset, passwordSet[2]);
001D66  2081C4     MOV #0x81C, W4
001D68  784214     MOV.B [W4], W4
001D6A  FB0284     SE W4, W5
001D6C  78021E     MOV [W14], W4
001D6E  BB0A05     TBLWTL W5, [W4]
87:                
88:                    asm volatile ("disi #5");
001D70  FC0005     DISI #0x5
89:                    __builtin_write_NVM();
001D72  200554     MOV #0x55, W4
001D74  883B34     MOV W4, NVMKEY
001D76  200AA4     MOV #0xAA, W4
001D78  883B34     MOV W4, NVMKEY
001D7A  A8E761     BSET 0x761, #7
001D7C  000000     NOP
001D7E  000000     NOP
90:                
91:                    // char 3
92:                    while (_WR) continue;
001D80  000000     NOP
001D82  370001     BRA 0x1D86
001D84  000000     NOP
001D86  803B05     MOV NVMCON, W5
001D88  280004     MOV #0x8000, W4
001D8A  628204     AND W5, W4, W4
001D8C  520FE0     SUB W4, #0x0, [W15]
001D8E  3AFFFA     BRA NZ, 0x1D84
93:                    NVMCON = 0x4004;
001D90  240044     MOV #0x4004, W4
001D92  883B04     MOV W4, NVMCON
94:                
95:                    TBLPAG = __builtin_tblpage(&EEpassword3);
001D94  2007F4     MOV #0x7F, W4
001D96  784204     MOV.B W4, W4
001D98  FD0200     EXCH W0, W4
001D9A  B7E032     MOV.B WREG, TBLPAG
001D9C  FD0200     EXCH W0, W4
96:                    offset = __builtin_tbloffset(&EEpassword3);
001D9E  2FE064     MOV #0xFE06, W4
001DA0  780F04     MOV W4, [W14]
97:                    __builtin_tblwtl(offset, passwordSet[3]);
001DA2  2081D4     MOV #0x81D, W4
001DA4  784214     MOV.B [W4], W4
001DA6  FB0284     SE W4, W5
001DA8  78021E     MOV [W14], W4
001DAA  BB0A05     TBLWTL W5, [W4]
98:                
99:                    asm volatile ("disi #5");
001DAC  FC0005     DISI #0x5
100:                   __builtin_write_NVM();
001DAE  200554     MOV #0x55, W4
001DB0  883B34     MOV W4, NVMKEY
001DB2  200AA4     MOV #0xAA, W4
001DB4  883B34     MOV W4, NVMKEY
001DB6  A8E761     BSET 0x761, #7
001DB8  000000     NOP
001DBA  000000     NOP
101:               
102:                   // char 4
103:                   while (_WR) continue;
001DBC  000000     NOP
001DBE  370001     BRA 0x1DC2
001DC0  000000     NOP
001DC2  803B05     MOV NVMCON, W5
001DC4  280004     MOV #0x8000, W4
001DC6  628204     AND W5, W4, W4
001DC8  520FE0     SUB W4, #0x0, [W15]
001DCA  3AFFFA     BRA NZ, 0x1DC0
104:                   NVMCON = 0x4004;
001DCC  240044     MOV #0x4004, W4
001DCE  883B04     MOV W4, NVMCON
105:               
106:                   TBLPAG = __builtin_tblpage(&EEpassword4);
001DD0  2007F4     MOV #0x7F, W4
001DD2  784204     MOV.B W4, W4
001DD4  FD0200     EXCH W0, W4
001DD6  B7E032     MOV.B WREG, TBLPAG
001DD8  FD0200     EXCH W0, W4
107:                   offset = __builtin_tbloffset(&EEpassword4);
001DDA  2FE084     MOV #0xFE08, W4
001DDC  780F04     MOV W4, [W14]
108:                   __builtin_tblwtl(offset, passwordSet[4]);
001DDE  2081E4     MOV #0x81E, W4
001DE0  784214     MOV.B [W4], W4
001DE2  FB0284     SE W4, W5
001DE4  78021E     MOV [W14], W4
001DE6  BB0A05     TBLWTL W5, [W4]
109:               
110:                   asm volatile ("disi #5");
001DE8  FC0005     DISI #0x5
111:                   __builtin_write_NVM();
001DEA  200554     MOV #0x55, W4
001DEC  883B34     MOV W4, NVMKEY
001DEE  200AA4     MOV #0xAA, W4
001DF0  883B34     MOV W4, NVMKEY
001DF2  A8E761     BSET 0x761, #7
001DF4  000000     NOP
001DF6  000000     NOP
112:               
113:                   // char 5
114:                   while (_WR) continue;
001DF8  000000     NOP
001DFA  370001     BRA 0x1DFE
001DFC  000000     NOP
001DFE  803B05     MOV NVMCON, W5
001E00  280004     MOV #0x8000, W4
001E02  628204     AND W5, W4, W4
001E04  520FE0     SUB W4, #0x0, [W15]
001E06  3AFFFA     BRA NZ, 0x1DFC
115:                   NVMCON = 0x4004;
001E08  240044     MOV #0x4004, W4
001E0A  883B04     MOV W4, NVMCON
116:               
117:                   TBLPAG = __builtin_tblpage(&EEpassword5);
001E0C  2007F4     MOV #0x7F, W4
001E0E  784204     MOV.B W4, W4
001E10  780004     MOV W4, W0
001E12  B7E032     MOV.B WREG, TBLPAG
118:                   offset = __builtin_tbloffset(&EEpassword5);
001E14  2FE0A4     MOV #0xFE0A, W4
001E16  780F04     MOV W4, [W14]
119:                   __builtin_tblwtl(offset, passwordSet[5]);
001E18  2081F4     MOV #0x81F, W4
001E1A  784214     MOV.B [W4], W4
001E1C  FB0284     SE W4, W5
001E1E  78021E     MOV [W14], W4
001E20  BB0A05     TBLWTL W5, [W4]
120:               
121:                   asm volatile ("disi #5");
001E22  FC0005     DISI #0x5
122:                   __builtin_write_NVM();
001E24  200554     MOV #0x55, W4
001E26  883B34     MOV W4, NVMKEY
001E28  200AA4     MOV #0xAA, W4
001E2A  883B34     MOV W4, NVMKEY
001E2C  A8E761     BSET 0x761, #7
001E2E  000000     NOP
001E30  000000     NOP
123:               }
001E32  FA8000     ULNK
124:               
125:               void EEreadPowerAlloc(void){
001E36  FA0002     LNK #0x2
126:                   while (_WR) continue;
001E38  000000     NOP
001E3A  370001     BRA 0x1E3E
001E3C  000000     NOP
001E3E  803B05     MOV NVMCON, W5
001E40  280004     MOV #0x8000, W4
001E42  628204     AND W5, W4, W4
001E44  520FE0     SUB W4, #0x0, [W15]
001E46  3AFFFA     BRA NZ, 0x1E3C
127:               
128:                   TBLPAG = __builtin_tblpage(&EEpowerAlloc);
001E48  2007F4     MOV #0x7F, W4
001E4A  784204     MOV.B W4, W4
001E4C  780004     MOV W4, W0
001E4E  B7E032     MOV.B WREG, TBLPAG
129:                   unsigned int offset = __builtin_tbloffset(&EEpowerAlloc);
001E50  2FE0C4     MOV #0xFE0C, W4
001E52  780F04     MOV W4, [W14]
130:                   powerAllocated = (unsigned long) __builtin_tblrdl(offset);
001E54  78021E     MOV [W14], W4
001E56  BA0214     TBLRDL [W4], W4
001E58  200005     MOV #0x0, W5
001E5A  885C94     MOV W4, powerAllocated
001E5C  885CA5     MOV W5, 0xB94
131:               }
001E5E  FA8000     ULNK
132:               
133:               void EEwritePowerAlloc(void){
001E62  FA0002     LNK #0x2
134:               
135:                   while (_WR) continue;
001E64  000000     NOP
001E66  370001     BRA 0x1E6A
001E68  000000     NOP
001E6A  803B05     MOV NVMCON, W5
001E6C  280004     MOV #0x8000, W4
001E6E  628204     AND W5, W4, W4
001E70  520FE0     SUB W4, #0x0, [W15]
001E72  3AFFFA     BRA NZ, 0x1E68
136:                   NVMCON = 0x4004;
001E74  240044     MOV #0x4004, W4
001E76  883B04     MOV W4, NVMCON
137:               
138:                   TBLPAG = __builtin_tblpage(&EEpowerAlloc);
001E78  2007F4     MOV #0x7F, W4
001E7A  784204     MOV.B W4, W4
001E7C  780004     MOV W4, W0
001E7E  B7E032     MOV.B WREG, TBLPAG
139:                   unsigned int offset = __builtin_tbloffset(&EEpowerAlloc);
001E80  2FE0C4     MOV #0xFE0C, W4
001E82  780F04     MOV W4, [W14]
140:                   __builtin_tblwtl(offset, powerAllocated);
001E84  805C94     MOV powerAllocated, W4
001E86  805CA5     MOV 0xB94, W5
001E88  780284     MOV W4, W5
001E8A  78021E     MOV [W14], W4
001E8C  BB0A05     TBLWTL W5, [W4]
141:               
142:                   asm volatile ("disi #5");
001E8E  FC0005     DISI #0x5
143:                   __builtin_write_NVM();
001E90  200554     MOV #0x55, W4
001E92  883B34     MOV W4, NVMKEY
001E94  200AA4     MOV #0xAA, W4
001E96  883B34     MOV W4, NVMKEY
001E98  A8E761     BSET 0x761, #7
001E9A  000000     NOP
001E9C  000000     NOP
144:               }
001E9E  FA8000     ULNK
145:               
146:               //void EEreadDate(void){
147:               //    while (_WR) continue;
148:               //
149:               //    TBLPAG = __builtin_tblpage(&EEyear);
150:               //    unsigned int offset = __builtin_tbloffset(&EEyear);
151:               //    unsigned char tempYear = (unsigned char) __builtin_tblrdl(offset);
152:               //
153:               //    TBLPAG = __builtin_tblpage(&EEmonth);
154:               //    offset = __builtin_tbloffset(&EEmonth);
155:               //    unsigned char tempMonth = (unsigned char) __builtin_tblrdl(offset);
156:               //
157:               //    TBLPAG = __builtin_tblpage(&EEday);
158:               //    offset = __builtin_tbloffset(&EEday);
159:               //    unsigned char tempDay = (unsigned char) __builtin_tblrdl(offset);
160:               //
161:               //
162:               //    writeTime(tempYear, tempMonth, tempDay, 0, 0, 0);
163:               //}
164:               //void EEwriteDate(void){
165:               //
166:               //    while (_WR) continue;
167:               //    NVMCON = 0x4004;
168:               //
169:               //    TBLPAG = __builtin_tblpage(&EEyear);
170:               //    unsigned int offset = __builtin_tbloffset(&EEyear);
171:               //    __builtin_tblwtl(offset, timeYear);
172:               //
173:               //    asm volatile ("disi #5");
174:               //    __builtin_write_NVM();
175:               //
176:               //    while (_WR) continue;
177:               //    NVMCON = 0x4004;
178:               //
179:               //    TBLPAG = __builtin_tblpage(&EEmonth);
180:               //    offset = __builtin_tbloffset(&EEmonth);
181:               //    __builtin_tblwtl(offset, timeMonth);
182:               //
183:               //    asm volatile ("disi #5");
184:               //    __builtin_write_NVM();
185:               //
186:               //    while (_WR) continue;
187:               //    NVMCON = 0x4004;
188:               //
189:               //    TBLPAG = __builtin_tblpage(&EEday);
190:               //    offset = __builtin_tbloffset(&EEday);
191:               //    __builtin_tblwtl(offset, timeDay);
192:               //
193:               //    asm volatile ("disi #5");
194:               //    __builtin_write_NVM();
195:               //}
196:               
197:               void EEreadEmerButton() {
001EA2  FA0004     LNK #0x4
198:                   while (_WR) continue;
001EA4  000000     NOP
001EA6  370001     BRA 0x1EAA
001EA8  000000     NOP
001EAA  803B05     MOV NVMCON, W5
001EAC  280004     MOV #0x8000, W4
001EAE  628204     AND W5, W4, W4
001EB0  520FE0     SUB W4, #0x0, [W15]
001EB2  3AFFFA     BRA NZ, 0x1EA8
199:               
200:                   TBLPAG = __builtin_tblpage(&EEemerButton);
001EB4  2007F4     MOV #0x7F, W4
001EB6  784204     MOV.B W4, W4
001EB8  FD0200     EXCH W0, W4
001EBA  B7E032     MOV.B WREG, TBLPAG
001EBC  FD0200     EXCH W0, W4
201:                   unsigned int offset = __builtin_tbloffset(&EEemerButton);
001EBE  2FE0E4     MOV #0xFE0E, W4
001EC0  780F04     MOV W4, [W14]
202:                   int tempEmerAlloc = __builtin_tblrdl(offset);
001EC2  78021E     MOV [W14], W4
001EC4  BA0214     TBLRDL [W4], W4
001EC6  980714     MOV W4, [W14+2]
203:               
204:                   if (tempEmerAlloc) {
001EC8  90021E     MOV [W14+2], W4
001ECA  520FE0     SUB W4, #0x0, [W15]
001ECC  320007     BRA Z, 0x1EDC
205:                       emerButtonEnable = 1;
001ECE  B3C014     MOV.B #0x1, W4
001ED0  FD0200     EXCH W0, W4
001ED2  B7E823     MOV.B WREG, emerButtonEnable
001ED4  FD0200     EXCH W0, W4
206:                       emerButtonAlloc = tempEmerAlloc;
001ED6  90021E     MOV [W14+2], W4
001ED8  884124     MOV W4, emerButtonAlloc
001EDA  370005     BRA 0x1EE6
207:                   } else {
208:                       emerButtonEnable = 0;
001EDC  EB4200     CLR.B W4
001EDE  780004     MOV W4, W0
001EE0  B7E823     MOV.B WREG, emerButtonEnable
209:                       emerButtonAlloc = 0;
001EE2  EB0200     CLR W4
001EE4  884124     MOV W4, emerButtonAlloc
210:                   }
211:               }
001EE6  FA8000     ULNK
212:               
213:               void EEwriteEmerButton() {
001EEA  FA0002     LNK #0x2
214:                   while (_WR) continue;
001EEC  000000     NOP
001EEE  370001     BRA 0x1EF2
001EF0  000000     NOP
001EF2  803B05     MOV NVMCON, W5
001EF4  280004     MOV #0x8000, W4
001EF6  628204     AND W5, W4, W4
001EF8  520FE0     SUB W4, #0x0, [W15]
001EFA  3AFFFA     BRA NZ, 0x1EF0
215:                   NVMCON = 0x4004;
001EFC  240044     MOV #0x4004, W4
001EFE  883B04     MOV W4, NVMCON
216:               
217:                   TBLPAG = __builtin_tblpage(&EEemerButton);
001F00  2007F4     MOV #0x7F, W4
001F02  784204     MOV.B W4, W4
001F04  780004     MOV W4, W0
001F06  B7E032     MOV.B WREG, TBLPAG
218:                   unsigned int offset = __builtin_tbloffset(&EEemerButton);
001F08  2FE0E4     MOV #0xFE0E, W4
001F0A  780F04     MOV W4, [W14]
219:                   __builtin_tblwtl(offset, emerButtonAlloc);
001F0C  804124     MOV emerButtonAlloc, W4
001F0E  780284     MOV W4, W5
001F10  78021E     MOV [W14], W4
001F12  BB0A05     TBLWTL W5, [W4]
220:               
221:                   asm volatile ("disi #5");
001F14  FC0005     DISI #0x5
222:                   __builtin_write_NVM();
001F16  200554     MOV #0x55, W4
001F18  883B34     MOV W4, NVMKEY
001F1A  200AA4     MOV #0xAA, W4
001F1C  883B34     MOV W4, NVMKEY
001F1E  A8E761     BSET 0x761, #7
001F20  000000     NOP
001F22  000000     NOP
223:               }
001F24  FA8000     ULNK
224:               
225:               void EEreadResetTime() {
001F28  FA0004     LNK #0x4
226:                   while (_WR) continue;
001F2A  000000     NOP
001F2C  370001     BRA 0x1F30
001F2E  000000     NOP
001F30  803B05     MOV NVMCON, W5
001F32  280004     MOV #0x8000, W4
001F34  628204     AND W5, W4, W4
001F36  520FE0     SUB W4, #0x0, [W15]
001F38  3AFFFA     BRA NZ, 0x1F2E
227:               
228:                   TBLPAG = __builtin_tblpage(&EEresetTime);
001F3A  2007F4     MOV #0x7F, W4
001F3C  784204     MOV.B W4, W4
001F3E  780004     MOV W4, W0
001F40  B7E032     MOV.B WREG, TBLPAG
229:                   unsigned int offset = __builtin_tbloffset(&EEresetTime);
001F42  2FE104     MOV #0xFE10, W4
001F44  780F04     MOV W4, [W14]
230:                   unsigned int tempResetTime = __builtin_tblrdl(offset);
001F46  78021E     MOV [W14], W4
001F48  BA0214     TBLRDL [W4], W4
001F4A  980714     MOV W4, [W14+2]
231:               
232:                   resetMinute = tempResetTime % 100;
001F4C  90029E     MOV [W14+2], W5
001F4E  200644     MOV #0x64, W4
001F50  090011     REPEAT #0x11
001F52  D88284     DIV.UW W5, W4
001F54  780201     MOV W1, W4
001F56  784204     MOV.B W4, W4
001F58  780004     MOV W4, W0
001F5A  B7E804     MOV.B WREG, resetMinute
233:                   resetHour = tempResetTime / 100;
001F5C  90029E     MOV [W14+2], W5
001F5E  200644     MOV #0x64, W4
001F60  090011     REPEAT #0x11
001F62  D88284     DIV.UW W5, W4
001F64  780200     MOV W0, W4
001F66  784204     MOV.B W4, W4
001F68  780004     MOV W4, W0
001F6A  B7E803     MOV.B WREG, resetHour
234:               }
001F6C  FA8000     ULNK
235:               
236:               void EEwriteResetTime() {
001F70  FA0004     LNK #0x4
237:                   while (_WR) continue;
001F72  000000     NOP
001F74  370001     BRA 0x1F78
001F76  000000     NOP
001F78  803B05     MOV NVMCON, W5
001F7A  280004     MOV #0x8000, W4
001F7C  628204     AND W5, W4, W4
001F7E  520FE0     SUB W4, #0x0, [W15]
001F80  3AFFFA     BRA NZ, 0x1F76
238:                   NVMCON = 0x4004;
001F82  240044     MOV #0x4004, W4
001F84  883B04     MOV W4, NVMCON
239:               
240:                   unsigned int tempResetTime = resetMinute + (100 * resetHour);
001F86  208044     MOV #0x804, W4
001F88  784214     MOV.B [W4], W4
001F8A  FB8304     ZE W4, W6
001F8C  208034     MOV #0x803, W4
001F8E  784214     MOV.B [W4], W4
001F90  FB8284     ZE W4, W5
001F92  200644     MOV #0x64, W4
001F94  B9AA04     MUL.SS W5, W4, W4
001F96  780204     MOV W4, W4
001F98  430204     ADD W6, W4, W4
001F9A  780F04     MOV W4, [W14]
241:               
242:                   TBLPAG = __builtin_tblpage(&EEresetTime);
001F9C  2007F4     MOV #0x7F, W4
001F9E  784204     MOV.B W4, W4
001FA0  780004     MOV W4, W0
001FA2  B7E032     MOV.B WREG, TBLPAG
243:                   unsigned int offset = __builtin_tbloffset(&EEresetTime);
001FA4  2FE104     MOV #0xFE10, W4
001FA6  980714     MOV W4, [W14+2]
244:                   __builtin_tblwtl(offset, tempResetTime);
001FA8  90021E     MOV [W14+2], W4
001FAA  BB0A1E     TBLWTL [W14], [W4]
245:               
246:                   asm volatile ("disi #5");
001FAC  FC0005     DISI #0x5
247:                   __builtin_write_NVM();
001FAE  200554     MOV #0x55, W4
001FB0  883B34     MOV W4, NVMKEY
001FB2  200AA4     MOV #0xAA, W4
001FB4  883B34     MOV W4, NVMKEY
001FB6  A8E761     BSET 0x761, #7
001FB8  000000     NOP
001FBA  000000     NOP
248:               }
001FBC  FA8000     ULNK
249:               
250:               void EEreadAlarm() {
001FC0  FA0002     LNK #0x2
251:                   while (_WR) continue;
001FC2  000000     NOP
001FC4  370001     BRA 0x1FC8
001FC6  000000     NOP
001FC8  803B05     MOV NVMCON, W5
001FCA  280004     MOV #0x8000, W4
001FCC  628204     AND W5, W4, W4
001FCE  520FE0     SUB W4, #0x0, [W15]
001FD0  3AFFFA     BRA NZ, 0x1FC6
252:               
253:                   TBLPAG = __builtin_tblpage(&EEaudibleAlarm);
001FD2  2007F4     MOV #0x7F, W4
001FD4  784204     MOV.B W4, W4
001FD6  FD0200     EXCH W0, W4
001FD8  B7E032     MOV.B WREG, TBLPAG
001FDA  FD0200     EXCH W0, W4
254:                   unsigned int offset = __builtin_tbloffset(&EEaudibleAlarm);
001FDC  2FE124     MOV #0xFE12, W4
001FDE  780F04     MOV W4, [W14]
255:                   audibleAlarm = (char) __builtin_tblrdl(offset);
001FE0  78021E     MOV [W14], W4
001FE2  BA0214     TBLRDL [W4], W4
001FE4  784204     MOV.B W4, W4
001FE6  FD0200     EXCH W0, W4
001FE8  B7E826     MOV.B WREG, audibleAlarm
001FEA  FD0200     EXCH W0, W4
256:               
257:                   TBLPAG = __builtin_tblpage(&EEalarmOnePower);
001FEC  2007F4     MOV #0x7F, W4
001FEE  784204     MOV.B W4, W4
001FF0  FD0200     EXCH W0, W4
001FF2  B7E032     MOV.B WREG, TBLPAG
001FF4  FD0200     EXCH W0, W4
258:                   offset = __builtin_tbloffset(&EEalarmOnePower);
001FF6  2FE144     MOV #0xFE14, W4
001FF8  780F04     MOV W4, [W14]
259:                   alarmOnePower = (char) __builtin_tblrdl(offset);
001FFA  78021E     MOV [W14], W4
001FFC  BA0214     TBLRDL [W4], W4
001FFE  784204     MOV.B W4, W4
002000  FD0200     EXCH W0, W4
002002  B7E827     MOV.B WREG, alarmOnePower
002004  FD0200     EXCH W0, W4
260:               
261:                   TBLPAG = __builtin_tblpage(&EEalarmTwoPower);
002006  2007F4     MOV #0x7F, W4
002008  784204     MOV.B W4, W4
00200A  FD0200     EXCH W0, W4
00200C  B7E032     MOV.B WREG, TBLPAG
00200E  FD0200     EXCH W0, W4
262:                   offset = __builtin_tbloffset(&EEalarmTwoPower);
002010  2FE164     MOV #0xFE16, W4
002012  780F04     MOV W4, [W14]
263:                   alarmTwoPower = (char) __builtin_tblrdl(offset);
002014  78021E     MOV [W14], W4
002016  BA0214     TBLRDL [W4], W4
002018  784204     MOV.B W4, W4
00201A  FD0200     EXCH W0, W4
00201C  B7E828     MOV.B WREG, alarmTwoPower
00201E  FD0200     EXCH W0, W4
264:               
265:                   if (alarmOnePower)
002020  208274     MOV #0x827, W4
002022  784214     MOV.B [W4], W4
002024  524FE0     SUB.B W4, #0x0, [W15]
002026  320005     BRA Z, 0x2032
266:                       alarmOneEnabled = 1;
002028  B3C014     MOV.B #0x1, W4
00202A  FD0200     EXCH W0, W4
00202C  B7E829     MOV.B WREG, alarmOneEnabled
00202E  FD0200     EXCH W0, W4
002030  370004     BRA 0x203A
267:                   else
268:                       alarmOneEnabled = 0;
002032  EB4200     CLR.B W4
002034  FD0200     EXCH W0, W4
002036  B7E829     MOV.B WREG, alarmOneEnabled
002038  FD0200     EXCH W0, W4
269:               
270:                   if (alarmTwoPower)
00203A  208284     MOV #0x828, W4
00203C  784214     MOV.B [W4], W4
00203E  524FE0     SUB.B W4, #0x0, [W15]
002040  320005     BRA Z, 0x204C
271:                       alarmTwoEnabled = 1;
002042  B3C014     MOV.B #0x1, W4
002044  FD0200     EXCH W0, W4
002046  B7E82A     MOV.B WREG, alarmTwoEnabled
002048  FD0200     EXCH W0, W4
00204A  370003     BRA 0x2052
272:                   else
273:                       alarmTwoEnabled = 0;
00204C  EB4200     CLR.B W4
00204E  780004     MOV W4, W0
002050  B7E82A     MOV.B WREG, alarmTwoEnabled
274:               }
002052  FA8000     ULNK
275:               
276:               void EEwriteAlarm() {
002056  FA0002     LNK #0x2
277:                   while (_WR) continue;
002058  000000     NOP
00205A  370001     BRA 0x205E
00205C  000000     NOP
00205E  803B05     MOV NVMCON, W5
002060  280004     MOV #0x8000, W4
002062  628204     AND W5, W4, W4
002064  520FE0     SUB W4, #0x0, [W15]
002066  3AFFFA     BRA NZ, 0x205C
278:                   NVMCON = 0x4004;
002068  240044     MOV #0x4004, W4
00206A  883B04     MOV W4, NVMCON
279:               
280:                   TBLPAG = __builtin_tblpage(&EEaudibleAlarm);
00206C  2007F4     MOV #0x7F, W4
00206E  784204     MOV.B W4, W4
002070  FD0200     EXCH W0, W4
002072  B7E032     MOV.B WREG, TBLPAG
002074  FD0200     EXCH W0, W4
281:                   unsigned int offset = __builtin_tbloffset(&EEaudibleAlarm);
002076  2FE124     MOV #0xFE12, W4
002078  780F04     MOV W4, [W14]
282:                   __builtin_tblwtl(offset, audibleAlarm);
00207A  208264     MOV #0x826, W4
00207C  784214     MOV.B [W4], W4
00207E  FB0284     SE W4, W5
002080  78021E     MOV [W14], W4
002082  BB0A05     TBLWTL W5, [W4]
283:               
284:                   asm volatile ("disi #5");
002084  FC0005     DISI #0x5
285:                   __builtin_write_NVM();
002086  200554     MOV #0x55, W4
002088  883B34     MOV W4, NVMKEY
00208A  200AA4     MOV #0xAA, W4
00208C  883B34     MOV W4, NVMKEY
00208E  A8E761     BSET 0x761, #7
002090  000000     NOP
002092  000000     NOP
286:               
287:               
288:                   while (_WR) continue;
002094  000000     NOP
002096  370001     BRA 0x209A
002098  000000     NOP
00209A  803B05     MOV NVMCON, W5
00209C  280004     MOV #0x8000, W4
00209E  628204     AND W5, W4, W4
0020A0  520FE0     SUB W4, #0x0, [W15]
0020A2  3AFFFA     BRA NZ, 0x2098
289:                   NVMCON = 0x4004;
0020A4  240044     MOV #0x4004, W4
0020A6  883B04     MOV W4, NVMCON
290:               
291:                   TBLPAG = __builtin_tblpage(&EEalarmOnePower);
0020A8  2007F4     MOV #0x7F, W4
0020AA  784204     MOV.B W4, W4
0020AC  FD0200     EXCH W0, W4
0020AE  B7E032     MOV.B WREG, TBLPAG
0020B0  FD0200     EXCH W0, W4
292:                   offset = __builtin_tbloffset(&EEalarmOnePower);
0020B2  2FE144     MOV #0xFE14, W4
0020B4  780F04     MOV W4, [W14]
293:                   __builtin_tblwtl(offset, alarmOnePower);
0020B6  208274     MOV #0x827, W4
0020B8  784214     MOV.B [W4], W4
0020BA  FB0284     SE W4, W5
0020BC  78021E     MOV [W14], W4
0020BE  BB0A05     TBLWTL W5, [W4]
294:               
295:                   asm volatile ("disi #5");
0020C0  FC0005     DISI #0x5
296:                   __builtin_write_NVM();
0020C2  200554     MOV #0x55, W4
0020C4  883B34     MOV W4, NVMKEY
0020C6  200AA4     MOV #0xAA, W4
0020C8  883B34     MOV W4, NVMKEY
0020CA  A8E761     BSET 0x761, #7
0020CC  000000     NOP
0020CE  000000     NOP
297:               
298:               
299:                   while (_WR) continue;
0020D0  000000     NOP
0020D2  370001     BRA 0x20D6
0020D4  000000     NOP
0020D6  803B05     MOV NVMCON, W5
0020D8  280004     MOV #0x8000, W4
0020DA  628204     AND W5, W4, W4
0020DC  520FE0     SUB W4, #0x0, [W15]
0020DE  3AFFFA     BRA NZ, 0x20D4
300:                   NVMCON = 0x4004;
0020E0  240044     MOV #0x4004, W4
0020E2  883B04     MOV W4, NVMCON
301:               
302:                   TBLPAG = __builtin_tblpage(&EEalarmTwoPower);
0020E4  2007F4     MOV #0x7F, W4
0020E6  784204     MOV.B W4, W4
0020E8  780004     MOV W4, W0
0020EA  B7E032     MOV.B WREG, TBLPAG
303:                   offset = __builtin_tbloffset(&EEalarmTwoPower);
0020EC  2FE164     MOV #0xFE16, W4
0020EE  780F04     MOV W4, [W14]
304:                   __builtin_tblwtl(offset, alarmTwoPower);
0020F0  208284     MOV #0x828, W4
0020F2  784214     MOV.B [W4], W4
0020F4  FB0284     SE W4, W5
0020F6  78021E     MOV [W14], W4
0020F8  BB0A05     TBLWTL W5, [W4]
305:               
306:                   asm volatile ("disi #5");
0020FA  FC0005     DISI #0x5
307:                   __builtin_write_NVM();
0020FC  200554     MOV #0x55, W4
0020FE  883B34     MOV W4, NVMKEY
002100  200AA4     MOV #0xAA, W4
002102  883B34     MOV W4, NVMKEY
002104  A8E761     BSET 0x761, #7
002106  000000     NOP
002108  000000     NOP
308:               }
00210A  FA8000     ULNK
309:               
310:               void EEreadTotals() {
00210E  FA000A     LNK #0xA
311:               
312:                   unsigned int tempTotalUsedH, tempTotalUsedL, tempPreviousDayUsedH, tempPreviousDayUsedL;
313:               
314:                   while (_WR) continue;
002110  000000     NOP
002112  370001     BRA 0x2116
002114  000000     NOP
002116  803B05     MOV NVMCON, W5
002118  280004     MOV #0x8000, W4
00211A  628204     AND W5, W4, W4
00211C  520FE0     SUB W4, #0x0, [W15]
00211E  3AFFFA     BRA NZ, 0x2114
315:               
316:                   TBLPAG = __builtin_tblpage(&EEtotalUsedH);
002120  2007F4     MOV #0x7F, W4
002122  784204     MOV.B W4, W4
002124  780004     MOV W4, W0
002126  B7E032     MOV.B WREG, TBLPAG
317:                   unsigned int offset = __builtin_tbloffset(&EEtotalUsedH);
002128  2FE184     MOV #0xFE18, W4
00212A  780F04     MOV W4, [W14]
318:                   tempTotalUsedH = __builtin_tblrdl(offset);
00212C  78021E     MOV [W14], W4
00212E  BA0214     TBLRDL [W4], W4
002130  980714     MOV W4, [W14+2]
319:               
320:                   TBLPAG = __builtin_tblpage(&EEtotalUsedL);
002132  2007F4     MOV #0x7F, W4
002134  784204     MOV.B W4, W4
002136  780004     MOV W4, W0
002138  B7E032     MOV.B WREG, TBLPAG
321:                   offset = __builtin_tbloffset(&EEtotalUsedL);
00213A  2FE1A4     MOV #0xFE1A, W4
00213C  780F04     MOV W4, [W14]
322:                   tempTotalUsedL = __builtin_tblrdl(offset);
00213E  78021E     MOV [W14], W4
002140  BA0214     TBLRDL [W4], W4
002142  980724     MOV W4, [W14+4]
323:               
324:                   TBLPAG = __builtin_tblpage(&EEpreviousDayUsedH);
002144  2007F4     MOV #0x7F, W4
002146  784204     MOV.B W4, W4
002148  780004     MOV W4, W0
00214A  B7E032     MOV.B WREG, TBLPAG
325:                   offset = __builtin_tbloffset(&EEpreviousDayUsedH);
00214C  2FE1C4     MOV #0xFE1C, W4
00214E  780F04     MOV W4, [W14]
326:                   tempPreviousDayUsedH = __builtin_tblrdl(offset);
002150  78021E     MOV [W14], W4
002152  BA0214     TBLRDL [W4], W4
002154  980734     MOV W4, [W14+6]
327:               
328:                   TBLPAG = __builtin_tblpage(&EEpreviousDayUsedL);
002156  2007F4     MOV #0x7F, W4
002158  784204     MOV.B W4, W4
00215A  780004     MOV W4, W0
00215C  B7E032     MOV.B WREG, TBLPAG
329:                   offset = __builtin_tbloffset(&EEpreviousDayUsedL);
00215E  2FE1E4     MOV #0xFE1E, W4
002160  780F04     MOV W4, [W14]
330:                   tempPreviousDayUsedL = __builtin_tblrdl(offset);
002162  78021E     MOV [W14], W4
002164  BA0214     TBLRDL [W4], W4
002166  980744     MOV W4, [W14+8]
331:               
332:                   totalUsed = (((unsigned long) tempTotalUsedH) << 16) + tempTotalUsedL;
002168  90021E     MOV [W14+2], W4
00216A  200005     MOV #0x0, W5
00216C  DD23C0     SL W4, #0, W7
00216E  200006     MOV #0x0, W6
002170  90022E     MOV [W14+4], W4
002172  200005     MOV #0x0, W5
002174  420206     ADD W4, W6, W4
002176  4A8287     ADDC W5, W7, W5
002178  884084     MOV W4, totalUsed
00217A  884095     MOV W5, 0x812
333:                   previousDayUsed = (((unsigned long) tempPreviousDayUsedH) << 16) + tempPreviousDayUsedL;
00217C  90023E     MOV [W14+6], W4
00217E  200005     MOV #0x0, W5
002180  DD23C0     SL W4, #0, W7
002182  200006     MOV #0x0, W6
002184  90024E     MOV [W14+8], W4
002186  200005     MOV #0x0, W5
002188  420206     ADD W4, W6, W4
00218A  4A8287     ADDC W5, W7, W5
00218C  8840A4     MOV W4, previousDayUsed
00218E  8840B5     MOV W5, 0x816
334:               }
002190  FA8000     ULNK
335:               
336:               void EEwriteTotals() {
002194  FA000A     LNK #0xA
337:               
338:                   unsigned int tempTotalUsedH, tempTotalUsedL, tempPreviousDayUsedH, tempPreviousDayUsedL;
339:               
340:                   tempTotalUsedH = totalUsed >> 16;
002196  804084     MOV totalUsed, W4
002198  804095     MOV 0x812, W5
00219A  DE2A40     LSR W5, #0, W4
00219C  780F04     MOV W4, [W14]
341:                   tempTotalUsedL = totalUsed & 0xFFFF;
00219E  804084     MOV totalUsed, W4
0021A0  804095     MOV 0x812, W5
0021A2  980714     MOV W4, [W14+2]
342:                   tempPreviousDayUsedH = previousDayUsed >> 16;
0021A4  8040A4     MOV previousDayUsed, W4
0021A6  8040B5     MOV 0x816, W5
0021A8  DE2A40     LSR W5, #0, W4
0021AA  980724     MOV W4, [W14+4]
343:                   tempPreviousDayUsedL = previousDayUsed & 0xFFFF;
0021AC  8040A4     MOV previousDayUsed, W4
0021AE  8040B5     MOV 0x816, W5
0021B0  980734     MOV W4, [W14+6]
344:               
345:               
346:                   while (_WR) continue;
0021B2  000000     NOP
0021B4  370001     BRA 0x21B8
0021B6  000000     NOP
0021B8  803B05     MOV NVMCON, W5
0021BA  280004     MOV #0x8000, W4
0021BC  628204     AND W5, W4, W4
0021BE  520FE0     SUB W4, #0x0, [W15]
0021C0  3AFFFA     BRA NZ, 0x21B6
347:                   NVMCON = 0x4004;
0021C2  240044     MOV #0x4004, W4
0021C4  883B04     MOV W4, NVMCON
348:               
349:                   TBLPAG = __builtin_tblpage(&EEtotalUsedH);
0021C6  2007F4     MOV #0x7F, W4
0021C8  784204     MOV.B W4, W4
0021CA  FD0200     EXCH W0, W4
0021CC  B7E032     MOV.B WREG, TBLPAG
0021CE  FD0200     EXCH W0, W4
350:                   unsigned int offset = __builtin_tbloffset(&EEtotalUsedH);
0021D0  2FE184     MOV #0xFE18, W4
0021D2  980744     MOV W4, [W14+8]
351:                   __builtin_tblwtl(offset, tempTotalUsedH);
0021D4  90024E     MOV [W14+8], W4
0021D6  BB0A1E     TBLWTL [W14], [W4]
352:               
353:                   asm volatile ("disi #5");
0021D8  FC0005     DISI #0x5
354:                   __builtin_write_NVM();
0021DA  200554     MOV #0x55, W4
0021DC  883B34     MOV W4, NVMKEY
0021DE  200AA4     MOV #0xAA, W4
0021E0  883B34     MOV W4, NVMKEY
0021E2  A8E761     BSET 0x761, #7
0021E4  000000     NOP
0021E6  000000     NOP
355:               
356:               
357:               
358:                   while (_WR) continue;
0021E8  000000     NOP
0021EA  370001     BRA 0x21EE
0021EC  000000     NOP
0021EE  803B05     MOV NVMCON, W5
0021F0  280004     MOV #0x8000, W4
0021F2  628204     AND W5, W4, W4
0021F4  520FE0     SUB W4, #0x0, [W15]
0021F6  3AFFFA     BRA NZ, 0x21EC
359:                   NVMCON = 0x4004;
0021F8  240044     MOV #0x4004, W4
0021FA  883B04     MOV W4, NVMCON
360:               
361:                   TBLPAG = __builtin_tblpage(&EEtotalUsedL);
0021FC  2007F4     MOV #0x7F, W4
0021FE  784204     MOV.B W4, W4
002200  FD0200     EXCH W0, W4
002202  B7E032     MOV.B WREG, TBLPAG
002204  FD0200     EXCH W0, W4
362:                   offset = __builtin_tbloffset(&EEtotalUsedL);
002206  2FE1A4     MOV #0xFE1A, W4
002208  980744     MOV W4, [W14+8]
363:                   __builtin_tblwtl(offset, tempTotalUsedL);
00220A  90024E     MOV [W14+8], W4
00220C  90029E     MOV [W14+2], W5
00220E  BB0A05     TBLWTL W5, [W4]
364:               
365:                   asm volatile ("disi #5");
002210  FC0005     DISI #0x5
366:                   __builtin_write_NVM();
002212  200554     MOV #0x55, W4
002214  883B34     MOV W4, NVMKEY
002216  200AA4     MOV #0xAA, W4
002218  883B34     MOV W4, NVMKEY
00221A  A8E761     BSET 0x761, #7
00221C  000000     NOP
00221E  000000     NOP
367:               
368:               
369:                   while (_WR) continue;
002220  000000     NOP
002222  370001     BRA 0x2226
002224  000000     NOP
002226  803B05     MOV NVMCON, W5
002228  280004     MOV #0x8000, W4
00222A  628204     AND W5, W4, W4
00222C  520FE0     SUB W4, #0x0, [W15]
00222E  3AFFFA     BRA NZ, 0x2224
370:                   NVMCON = 0x4004;
002230  240044     MOV #0x4004, W4
002232  883B04     MOV W4, NVMCON
371:               
372:                   TBLPAG = __builtin_tblpage(&EEpreviousDayUsedH);
002234  2007F4     MOV #0x7F, W4
002236  784204     MOV.B W4, W4
002238  FD0200     EXCH W0, W4
00223A  B7E032     MOV.B WREG, TBLPAG
00223C  FD0200     EXCH W0, W4
373:                   offset = __builtin_tbloffset(&EEpreviousDayUsedH);
00223E  2FE1C4     MOV #0xFE1C, W4
002240  980744     MOV W4, [W14+8]
374:                   __builtin_tblwtl(offset, tempPreviousDayUsedH);
002242  90024E     MOV [W14+8], W4
002244  9002AE     MOV [W14+4], W5
002246  BB0A05     TBLWTL W5, [W4]
375:               
376:                   asm volatile ("disi #5");
002248  FC0005     DISI #0x5
377:                   __builtin_write_NVM();
00224A  200554     MOV #0x55, W4
00224C  883B34     MOV W4, NVMKEY
00224E  200AA4     MOV #0xAA, W4
002250  883B34     MOV W4, NVMKEY
002252  A8E761     BSET 0x761, #7
002254  000000     NOP
002256  000000     NOP
378:               
379:               
380:                   while (_WR) continue;
002258  000000     NOP
00225A  370001     BRA 0x225E
00225C  000000     NOP
00225E  803B05     MOV NVMCON, W5
002260  280004     MOV #0x8000, W4
002262  628204     AND W5, W4, W4
002264  520FE0     SUB W4, #0x0, [W15]
002266  3AFFFA     BRA NZ, 0x225C
381:                   NVMCON = 0x4004;
002268  240044     MOV #0x4004, W4
00226A  883B04     MOV W4, NVMCON
382:               
383:                   TBLPAG = __builtin_tblpage(&EEpreviousDayUsedL);
00226C  2007F4     MOV #0x7F, W4
00226E  784204     MOV.B W4, W4
002270  780004     MOV W4, W0
002272  B7E032     MOV.B WREG, TBLPAG
384:                   offset = __builtin_tbloffset(&EEpreviousDayUsedL);
002274  2FE1E4     MOV #0xFE1E, W4
002276  980744     MOV W4, [W14+8]
385:                   __builtin_tblwtl(offset, tempPreviousDayUsedL);
002278  90024E     MOV [W14+8], W4
00227A  9002BE     MOV [W14+6], W5
00227C  BB0A05     TBLWTL W5, [W4]
386:               
387:                   asm volatile ("disi #5");
00227E  FC0005     DISI #0x5
388:                   __builtin_write_NVM();
002280  200554     MOV #0x55, W4
002282  883B34     MOV W4, NVMKEY
002284  200AA4     MOV #0xAA, W4
002286  883B34     MOV W4, NVMKEY
002288  A8E761     BSET 0x761, #7
00228A  000000     NOP
00228C  000000     NOP
389:               }
00228E  FA8000     ULNK
390:               
391:               void EEreadPowerUsed() {
002292  FA0008     LNK #0x8
392:                   unsigned char EEpowerSelect;
393:                   unsigned int tempPowerH, tempPowerL, offset;
394:               
395:                   while (_WR) continue;
002294  000000     NOP
002296  370001     BRA 0x229A
002298  000000     NOP
00229A  803B05     MOV NVMCON, W5
00229C  280004     MOV #0x8000, W4
00229E  628204     AND W5, W4, W4
0022A0  520FE0     SUB W4, #0x0, [W15]
0022A2  3AFFFA     BRA NZ, 0x2298
396:               
397:                   EEpowerSelect = findPowerToRead();
0022A4  0703EE     RCALL findPowerToRead
0022A6  784200     MOV.B W0, W4
0022A8  984744     MOV.B W4, [W14+4]
398:               
399:                   switch (EEpowerSelect) {
0022AA  90424E     MOV.B [W14+4], W4
0022AC  FB8204     ZE W4, W4
0022AE  DEA2CF     ASR W4, #15, W5
0022B0  200086     MOV #0x8, W6
0022B2  200007     MOV #0x0, W7
0022B4  520F86     SUB W4, W6, [W15]
0022B6  5A8F87     SUBB W5, W7, [W15]
0022B8  3E00AC     BRA GTU, 0x2412
0022BA  016004     BRA W4
0022BC  370008     BRA 0x22CE
0022BE  37000C     BRA 0x22D8
0022C0  37001F     BRA 0x2300
0022C2  370032     BRA 0x2328
0022C4  370045     BRA 0x2350
0022C6  370058     BRA 0x2378
0022C8  37006B     BRA 0x23A0
0022CA  37007E     BRA 0x23C8
0022CC  370091     BRA 0x23F0
400:                       case 0:
401:                           tempPowerH = tempPowerL = 0;
0022CE  EB0200     CLR W4
0022D0  980714     MOV W4, [W14+2]
0022D2  90021E     MOV [W14+2], W4
0022D4  780F04     MOV W4, [W14]
402:                           break;
0022D6  37009D     BRA 0x2412
403:               
404:                       case 1:
405:                           TBLPAG = __builtin_tblpage(&EEpowerUsed1H);
0022D8  2007F4     MOV #0x7F, W4
0022DA  784204     MOV.B W4, W4
0022DC  FD0200     EXCH W0, W4
0022DE  B7E032     MOV.B WREG, TBLPAG
0022E0  FD0200     EXCH W0, W4
406:                           offset = __builtin_tbloffset(&EEpowerUsed1H);
0022E2  2FE204     MOV #0xFE20, W4
0022E4  980734     MOV W4, [W14+6]
407:                           tempPowerH = __builtin_tblrdl(offset);
0022E6  90023E     MOV [W14+6], W4
0022E8  BA0F14     TBLRDL [W4], [W14]
408:                           TBLPAG = __builtin_tblpage(&EEpowerUsed1L);
0022EA  2007F4     MOV #0x7F, W4
0022EC  784204     MOV.B W4, W4
0022EE  FD0200     EXCH W0, W4
0022F0  B7E032     MOV.B WREG, TBLPAG
0022F2  FD0200     EXCH W0, W4
409:                           offset = __builtin_tbloffset(&EEpowerUsed1L);
0022F4  2FE224     MOV #0xFE22, W4
0022F6  980734     MOV W4, [W14+6]
410:                           tempPowerL = __builtin_tblrdl(offset);
0022F8  90023E     MOV [W14+6], W4
0022FA  BA0214     TBLRDL [W4], W4
0022FC  980714     MOV W4, [W14+2]
411:                           break;
0022FE  370089     BRA 0x2412
412:               
413:                       case 2:
414:                           TBLPAG = __builtin_tblpage(&EEpowerUsed2H);
002300  2007F4     MOV #0x7F, W4
002302  784204     MOV.B W4, W4
002304  FD0200     EXCH W0, W4
002306  B7E032     MOV.B WREG, TBLPAG
002308  FD0200     EXCH W0, W4
415:                           offset = __builtin_tbloffset(&EEpowerUsed2H);
00230A  2FE244     MOV #0xFE24, W4
00230C  980734     MOV W4, [W14+6]
416:                           tempPowerH = __builtin_tblrdl(offset);
00230E  90023E     MOV [W14+6], W4
002310  BA0F14     TBLRDL [W4], [W14]
417:                           TBLPAG = __builtin_tblpage(&EEpowerUsed2L);
002312  2007F4     MOV #0x7F, W4
002314  784204     MOV.B W4, W4
002316  FD0200     EXCH W0, W4
002318  B7E032     MOV.B WREG, TBLPAG
00231A  FD0200     EXCH W0, W4
418:                           offset = __builtin_tbloffset(&EEpowerUsed2L);
00231C  2FE264     MOV #0xFE26, W4
00231E  980734     MOV W4, [W14+6]
419:                           tempPowerL = __builtin_tblrdl(offset);
002320  90023E     MOV [W14+6], W4
002322  BA0214     TBLRDL [W4], W4
002324  980714     MOV W4, [W14+2]
420:                           break;
002326  370075     BRA 0x2412
421:               
422:                       case 3:
423:                           TBLPAG = __builtin_tblpage(&EEpowerUsed3H);
002328  2007F4     MOV #0x7F, W4
00232A  784204     MOV.B W4, W4
00232C  FD0200     EXCH W0, W4
00232E  B7E032     MOV.B WREG, TBLPAG
002330  FD0200     EXCH W0, W4
424:                           offset = __builtin_tbloffset(&EEpowerUsed3H);
002332  2FE284     MOV #0xFE28, W4
002334  980734     MOV W4, [W14+6]
425:                           tempPowerH = __builtin_tblrdl(offset);
002336  90023E     MOV [W14+6], W4
002338  BA0F14     TBLRDL [W4], [W14]
426:                           TBLPAG = __builtin_tblpage(&EEpowerUsed3L);
00233A  2007F4     MOV #0x7F, W4
00233C  784204     MOV.B W4, W4
00233E  FD0200     EXCH W0, W4
002340  B7E032     MOV.B WREG, TBLPAG
002342  FD0200     EXCH W0, W4
427:                           offset = __builtin_tbloffset(&EEpowerUsed3L);
002344  2FE2A4     MOV #0xFE2A, W4
002346  980734     MOV W4, [W14+6]
428:                           tempPowerL = __builtin_tblrdl(offset);
002348  90023E     MOV [W14+6], W4
00234A  BA0214     TBLRDL [W4], W4
00234C  980714     MOV W4, [W14+2]
429:               
430:                           break;
00234E  370061     BRA 0x2412
431:               
432:                       case 4:
433:                           TBLPAG = __builtin_tblpage(&EEpowerUsed4H);
002350  2007F4     MOV #0x7F, W4
002352  784204     MOV.B W4, W4
002354  FD0200     EXCH W0, W4
002356  B7E032     MOV.B WREG, TBLPAG
002358  FD0200     EXCH W0, W4
434:                           offset = __builtin_tbloffset(&EEpowerUsed4H);
00235A  2FE2C4     MOV #0xFE2C, W4
00235C  980734     MOV W4, [W14+6]
435:                           tempPowerH = __builtin_tblrdl(offset);
00235E  90023E     MOV [W14+6], W4
002360  BA0F14     TBLRDL [W4], [W14]
436:                           TBLPAG = __builtin_tblpage(&EEpowerUsed4L);
002362  2007F4     MOV #0x7F, W4
002364  784204     MOV.B W4, W4
002366  FD0200     EXCH W0, W4
002368  B7E032     MOV.B WREG, TBLPAG
00236A  FD0200     EXCH W0, W4
437:                           offset = __builtin_tbloffset(&EEpowerUsed4L);
00236C  2FE2E4     MOV #0xFE2E, W4
00236E  980734     MOV W4, [W14+6]
438:                           tempPowerL = __builtin_tblrdl(offset);
002370  90023E     MOV [W14+6], W4
002372  BA0214     TBLRDL [W4], W4
002374  980714     MOV W4, [W14+2]
439:                           break;
002376  37004D     BRA 0x2412
440:               
441:                       case 5:
442:                           TBLPAG = __builtin_tblpage(&EEpowerUsed5H);
002378  2007F4     MOV #0x7F, W4
00237A  784204     MOV.B W4, W4
00237C  FD0200     EXCH W0, W4
00237E  B7E032     MOV.B WREG, TBLPAG
002380  FD0200     EXCH W0, W4
443:                           offset = __builtin_tbloffset(&EEpowerUsed5H);
002382  2FE304     MOV #0xFE30, W4
002384  980734     MOV W4, [W14+6]
444:                           tempPowerH = __builtin_tblrdl(offset);
002386  90023E     MOV [W14+6], W4
002388  BA0F14     TBLRDL [W4], [W14]
445:                           TBLPAG = __builtin_tblpage(&EEpowerUsed5L);
00238A  2007F4     MOV #0x7F, W4
00238C  784204     MOV.B W4, W4
00238E  FD0200     EXCH W0, W4
002390  B7E032     MOV.B WREG, TBLPAG
002392  FD0200     EXCH W0, W4
446:                           offset = __builtin_tbloffset(&EEpowerUsed5L);
002394  2FE324     MOV #0xFE32, W4
002396  980734     MOV W4, [W14+6]
447:                           tempPowerL = __builtin_tblrdl(offset);
002398  90023E     MOV [W14+6], W4
00239A  BA0214     TBLRDL [W4], W4
00239C  980714     MOV W4, [W14+2]
448:                           break;
00239E  370039     BRA 0x2412
449:               
450:                       case 6:
451:                           TBLPAG = __builtin_tblpage(&EEpowerUsed6H);
0023A0  2007F4     MOV #0x7F, W4
0023A2  784204     MOV.B W4, W4
0023A4  FD0200     EXCH W0, W4
0023A6  B7E032     MOV.B WREG, TBLPAG
0023A8  FD0200     EXCH W0, W4
452:                           offset = __builtin_tbloffset(&EEpowerUsed6H);
0023AA  2FE344     MOV #0xFE34, W4
0023AC  980734     MOV W4, [W14+6]
453:                           tempPowerH = __builtin_tblrdl(offset);
0023AE  90023E     MOV [W14+6], W4
0023B0  BA0F14     TBLRDL [W4], [W14]
454:                           TBLPAG = __builtin_tblpage(&EEpowerUsed6L);
0023B2  2007F4     MOV #0x7F, W4
0023B4  784204     MOV.B W4, W4
0023B6  FD0200     EXCH W0, W4
0023B8  B7E032     MOV.B WREG, TBLPAG
0023BA  FD0200     EXCH W0, W4
455:                           offset = __builtin_tbloffset(&EEpowerUsed6L);
0023BC  2FE364     MOV #0xFE36, W4
0023BE  980734     MOV W4, [W14+6]
456:                           tempPowerL = __builtin_tblrdl(offset);
0023C0  90023E     MOV [W14+6], W4
0023C2  BA0214     TBLRDL [W4], W4
0023C4  980714     MOV W4, [W14+2]
457:                           break;
0023C6  370025     BRA 0x2412
458:               
459:                       case 7:
460:                           TBLPAG = __builtin_tblpage(&EEpowerUsed7H);
0023C8  2007F4     MOV #0x7F, W4
0023CA  784204     MOV.B W4, W4
0023CC  FD0200     EXCH W0, W4
0023CE  B7E032     MOV.B WREG, TBLPAG
0023D0  FD0200     EXCH W0, W4
461:                           offset = __builtin_tbloffset(&EEpowerUsed7H);
0023D2  2FE384     MOV #0xFE38, W4
0023D4  980734     MOV W4, [W14+6]
462:                           tempPowerH = __builtin_tblrdl(offset);
0023D6  90023E     MOV [W14+6], W4
0023D8  BA0F14     TBLRDL [W4], [W14]
463:                           TBLPAG = __builtin_tblpage(&EEpowerUsed7L);
0023DA  2007F4     MOV #0x7F, W4
0023DC  784204     MOV.B W4, W4
0023DE  FD0200     EXCH W0, W4
0023E0  B7E032     MOV.B WREG, TBLPAG
0023E2  FD0200     EXCH W0, W4
464:                           offset = __builtin_tbloffset(&EEpowerUsed7L);
0023E4  2FE3A4     MOV #0xFE3A, W4
0023E6  980734     MOV W4, [W14+6]
465:                           tempPowerL = __builtin_tblrdl(offset);
0023E8  90023E     MOV [W14+6], W4
0023EA  BA0214     TBLRDL [W4], W4
0023EC  980714     MOV W4, [W14+2]
466:                           break;
0023EE  370011     BRA 0x2412
467:               
468:                       case 8:
469:                           TBLPAG = __builtin_tblpage(&EEpowerUsed8H);
0023F0  2007F4     MOV #0x7F, W4
0023F2  784204     MOV.B W4, W4
0023F4  780004     MOV W4, W0
0023F6  B7E032     MOV.B WREG, TBLPAG
470:                           offset = __builtin_tbloffset(&EEpowerUsed8H);
0023F8  2FE3C4     MOV #0xFE3C, W4
0023FA  980734     MOV W4, [W14+6]
471:                           tempPowerH = __builtin_tblrdl(offset);
0023FC  90023E     MOV [W14+6], W4
0023FE  BA0F14     TBLRDL [W4], [W14]
472:                           TBLPAG = __builtin_tblpage(&EEpowerUsed8L);
002400  2007F4     MOV #0x7F, W4
002402  784204     MOV.B W4, W4
002404  780004     MOV W4, W0
002406  B7E032     MOV.B WREG, TBLPAG
473:                           offset = __builtin_tbloffset(&EEpowerUsed8L);
002408  2FE3E4     MOV #0xFE3E, W4
00240A  980734     MOV W4, [W14+6]
474:                           tempPowerL = __builtin_tblrdl(offset);
00240C  90023E     MOV [W14+6], W4
00240E  BA0214     TBLRDL [W4], W4
002410  980714     MOV W4, [W14+2]
475:                   }
476:               
477:                   powerUsedMW = (((unsigned long) tempPowerH) << 16) + tempPowerL;
002412  78021E     MOV [W14], W4
002414  200005     MOV #0x0, W5
002416  DD23C0     SL W4, #0, W7
002418  200006     MOV #0x0, W6
00241A  90021E     MOV [W14+2], W4
00241C  200005     MOV #0x0, W5
00241E  420206     ADD W4, W6, W4
002420  4A8287     ADDC W5, W7, W5
002422  8841A4     MOV W4, powerUsedMW
002424  8841B5     MOV W5, 0x836
478:               }
002426  FA8000     ULNK
479:               
480:               void EEwritePowerUsed() {
00242A  FA0008     LNK #0x8
481:                   unsigned int offset;
482:                   unsigned int tempPowerH = powerUsedMW >> 16;
00242C  8041A4     MOV powerUsedMW, W4
00242E  8041B5     MOV 0x836, W5
002430  DE2A40     LSR W5, #0, W4
002432  780F04     MOV W4, [W14]
483:                   unsigned int tempPowerL = powerUsedMW & 0xFFFF;
002434  8041A4     MOV powerUsedMW, W4
002436  8041B5     MOV 0x836, W5
002438  980714     MOV W4, [W14+2]
484:                   unsigned char EEpowerSelect = findPowerToWrite();
00243A  0703AA     RCALL findPowerToWrite
00243C  784200     MOV.B W0, W4
00243E  984744     MOV.B W4, [W14+4]
485:               
486:                   switch (EEpowerSelect) {
002440  90424E     MOV.B [W14+4], W4
002442  FB8204     ZE W4, W4
002444  B92361     MUL.SU W4, #1, W6
002446  EB8200     SETM W4
002448  EB8280     SETM W5
00244A  420206     ADD W4, W6, W4
00244C  4A8287     ADDC W5, W7, W5
00244E  200076     MOV #0x7, W6
002450  200007     MOV #0x0, W7
002452  520F86     SUB W4, W6, [W15]
002454  5A8F87     SUBB W5, W7, [W15]
002456  3E02A7     BRA GTU, 0x29A6
002458  016004     BRA W4
00245A  370007     BRA 0x246A
00245C  37005A     BRA 0x2512
00245E  3700AD     BRA 0x25BA
002460  370100     BRA 0x2662
002462  370153     BRA 0x270A
002464  3701A6     BRA 0x27B2
002466  3701F9     BRA 0x285A
002468  37024C     BRA 0x2902
487:                       case 1:
488:                           while (_WR) continue;
00246A  000000     NOP
00246C  370001     BRA 0x2470
00246E  000000     NOP
002470  803B05     MOV NVMCON, W5
002472  280004     MOV #0x8000, W4
002474  628204     AND W5, W4, W4
002476  520FE0     SUB W4, #0x0, [W15]
002478  3AFFFA     BRA NZ, 0x246E
489:                           NVMCON = 0x4004;
00247A  240044     MOV #0x4004, W4
00247C  883B04     MOV W4, NVMCON
490:                           TBLPAG = __builtin_tblpage(&EEpowerUsed1H);
00247E  2007F4     MOV #0x7F, W4
002480  784204     MOV.B W4, W4
002482  FD0200     EXCH W0, W4
002484  B7E032     MOV.B WREG, TBLPAG
002486  FD0200     EXCH W0, W4
491:                           offset = __builtin_tbloffset(&EEpowerUsed1H);
002488  2FE204     MOV #0xFE20, W4
00248A  980734     MOV W4, [W14+6]
492:                           __builtin_tblwtl(offset, tempPowerH);
00248C  90023E     MOV [W14+6], W4
00248E  BB0A1E     TBLWTL [W14], [W4]
493:                           asm volatile ("disi #5");
002490  FC0005     DISI #0x5
494:                           __builtin_write_NVM();
002492  200554     MOV #0x55, W4
002494  883B34     MOV W4, NVMKEY
002496  200AA4     MOV #0xAA, W4
002498  883B34     MOV W4, NVMKEY
00249A  A8E761     BSET 0x761, #7
00249C  000000     NOP
00249E  000000     NOP
495:                           while (_WR) continue;
0024A0  000000     NOP
0024A2  370001     BRA 0x24A6
0024A4  000000     NOP
0024A6  803B05     MOV NVMCON, W5
0024A8  280004     MOV #0x8000, W4
0024AA  628204     AND W5, W4, W4
0024AC  520FE0     SUB W4, #0x0, [W15]
0024AE  3AFFFA     BRA NZ, 0x24A4
496:                           NVMCON = 0x4004;
0024B0  240044     MOV #0x4004, W4
0024B2  883B04     MOV W4, NVMCON
497:                           TBLPAG = __builtin_tblpage(&EEpowerUsed1L);
0024B4  2007F4     MOV #0x7F, W4
0024B6  784204     MOV.B W4, W4
0024B8  FD0200     EXCH W0, W4
0024BA  B7E032     MOV.B WREG, TBLPAG
0024BC  FD0200     EXCH W0, W4
498:                           offset = __builtin_tbloffset(&EEpowerUsed1L);
0024BE  2FE224     MOV #0xFE22, W4
0024C0  980734     MOV W4, [W14+6]
499:                           __builtin_tblwtl(offset, tempPowerL);
0024C2  90023E     MOV [W14+6], W4
0024C4  90029E     MOV [W14+2], W5
0024C6  BB0A05     TBLWTL W5, [W4]
500:                           asm volatile ("disi #5");
0024C8  FC0005     DISI #0x5
501:                           __builtin_write_NVM();
0024CA  200554     MOV #0x55, W4
0024CC  883B34     MOV W4, NVMKEY
0024CE  200AA4     MOV #0xAA, W4
0024D0  883B34     MOV W4, NVMKEY
0024D2  A8E761     BSET 0x761, #7
0024D4  000000     NOP
0024D6  000000     NOP
502:                           while (_WR) continue;
0024D8  000000     NOP
0024DA  370001     BRA 0x24DE
0024DC  000000     NOP
0024DE  803B05     MOV NVMCON, W5
0024E0  280004     MOV #0x8000, W4
0024E2  628204     AND W5, W4, W4
0024E4  520FE0     SUB W4, #0x0, [W15]
0024E6  3AFFFA     BRA NZ, 0x24DC
503:                           NVMCON = 0x4004;
0024E8  240044     MOV #0x4004, W4
0024EA  883B04     MOV W4, NVMCON
504:                           TBLPAG = __builtin_tblpage(&EEpowerUsed2H);
0024EC  2007F4     MOV #0x7F, W4
0024EE  784204     MOV.B W4, W4
0024F0  FD0200     EXCH W0, W4
0024F2  B7E032     MOV.B WREG, TBLPAG
0024F4  FD0200     EXCH W0, W4
505:                           offset = __builtin_tbloffset(&EEpowerUsed2H);
0024F6  2FE244     MOV #0xFE24, W4
0024F8  980734     MOV W4, [W14+6]
506:                           __builtin_tblwtl(offset, 0xFFFF);
0024FA  90023E     MOV [W14+6], W4
0024FC  EB8280     SETM W5
0024FE  BB0A05     TBLWTL W5, [W4]
507:                           asm volatile ("disi #5");
002500  FC0005     DISI #0x5
508:                           __builtin_write_NVM();
002502  200554     MOV #0x55, W4
002504  883B34     MOV W4, NVMKEY
002506  200AA4     MOV #0xAA, W4
002508  883B34     MOV W4, NVMKEY
00250A  A8E761     BSET 0x761, #7
00250C  000000     NOP
00250E  000000     NOP
509:                           break;
002510  37024A     BRA 0x29A6
510:               
511:                       case 2:
512:                           while (_WR) continue;
002512  000000     NOP
002514  370001     BRA 0x2518
002516  000000     NOP
002518  803B05     MOV NVMCON, W5
00251A  280004     MOV #0x8000, W4
00251C  628204     AND W5, W4, W4
00251E  520FE0     SUB W4, #0x0, [W15]
002520  3AFFFA     BRA NZ, 0x2516
513:                           NVMCON = 0x4004;
002522  240044     MOV #0x4004, W4
002524  883B04     MOV W4, NVMCON
514:                           TBLPAG = __builtin_tblpage(&EEpowerUsed2H);
002526  2007F4     MOV #0x7F, W4
002528  784204     MOV.B W4, W4
00252A  FD0200     EXCH W0, W4
00252C  B7E032     MOV.B WREG, TBLPAG
00252E  FD0200     EXCH W0, W4
515:                           offset = __builtin_tbloffset(&EEpowerUsed2H);
002530  2FE244     MOV #0xFE24, W4
002532  980734     MOV W4, [W14+6]
516:                           __builtin_tblwtl(offset, tempPowerH);
002534  90023E     MOV [W14+6], W4
002536  BB0A1E     TBLWTL [W14], [W4]
517:                           asm volatile ("disi #5");
002538  FC0005     DISI #0x5
518:                           __builtin_write_NVM();
00253A  200554     MOV #0x55, W4
00253C  883B34     MOV W4, NVMKEY
00253E  200AA4     MOV #0xAA, W4
002540  883B34     MOV W4, NVMKEY
002542  A8E761     BSET 0x761, #7
002544  000000     NOP
002546  000000     NOP
519:                           while (_WR) continue;
002548  000000     NOP
00254A  370001     BRA 0x254E
00254C  000000     NOP
00254E  803B05     MOV NVMCON, W5
002550  280004     MOV #0x8000, W4
002552  628204     AND W5, W4, W4
002554  520FE0     SUB W4, #0x0, [W15]
002556  3AFFFA     BRA NZ, 0x254C
520:                           NVMCON = 0x4004;
002558  240044     MOV #0x4004, W4
00255A  883B04     MOV W4, NVMCON
521:                           TBLPAG = __builtin_tblpage(&EEpowerUsed2L);
00255C  2007F4     MOV #0x7F, W4
00255E  784204     MOV.B W4, W4
002560  FD0200     EXCH W0, W4
002562  B7E032     MOV.B WREG, TBLPAG
002564  FD0200     EXCH W0, W4
522:                           offset = __builtin_tbloffset(&EEpowerUsed2L);
002566  2FE264     MOV #0xFE26, W4
002568  980734     MOV W4, [W14+6]
523:                           __builtin_tblwtl(offset, tempPowerL);
00256A  90023E     MOV [W14+6], W4
00256C  90029E     MOV [W14+2], W5
00256E  BB0A05     TBLWTL W5, [W4]
524:                           asm volatile ("disi #5");
002570  FC0005     DISI #0x5
525:                           __builtin_write_NVM();
002572  200554     MOV #0x55, W4
002574  883B34     MOV W4, NVMKEY
002576  200AA4     MOV #0xAA, W4
002578  883B34     MOV W4, NVMKEY
00257A  A8E761     BSET 0x761, #7
00257C  000000     NOP
00257E  000000     NOP
526:                           while (_WR) continue;
002580  000000     NOP
002582  370001     BRA 0x2586
002584  000000     NOP
002586  803B05     MOV NVMCON, W5
002588  280004     MOV #0x8000, W4
00258A  628204     AND W5, W4, W4
00258C  520FE0     SUB W4, #0x0, [W15]
00258E  3AFFFA     BRA NZ, 0x2584
527:                           NVMCON = 0x4004;
002590  240044     MOV #0x4004, W4
002592  883B04     MOV W4, NVMCON
528:                           TBLPAG = __builtin_tblpage(&EEpowerUsed3H);
002594  2007F4     MOV #0x7F, W4
002596  784204     MOV.B W4, W4
002598  FD0200     EXCH W0, W4
00259A  B7E032     MOV.B WREG, TBLPAG
00259C  FD0200     EXCH W0, W4
529:                           offset = __builtin_tbloffset(&EEpowerUsed3H);
00259E  2FE284     MOV #0xFE28, W4
0025A0  980734     MOV W4, [W14+6]
530:                           __builtin_tblwtl(offset, 0xFFFF);
0025A2  90023E     MOV [W14+6], W4
0025A4  EB8280     SETM W5
0025A6  BB0A05     TBLWTL W5, [W4]
531:                           asm volatile ("disi #5");
0025A8  FC0005     DISI #0x5
532:                           __builtin_write_NVM();
0025AA  200554     MOV #0x55, W4
0025AC  883B34     MOV W4, NVMKEY
0025AE  200AA4     MOV #0xAA, W4
0025B0  883B34     MOV W4, NVMKEY
0025B2  A8E761     BSET 0x761, #7
0025B4  000000     NOP
0025B6  000000     NOP
533:                           break;
0025B8  3701F6     BRA 0x29A6
534:               
535:                       case 3:
536:                           while (_WR) continue;
0025BA  000000     NOP
0025BC  370001     BRA 0x25C0
0025BE  000000     NOP
0025C0  803B05     MOV NVMCON, W5
0025C2  280004     MOV #0x8000, W4
0025C4  628204     AND W5, W4, W4
0025C6  520FE0     SUB W4, #0x0, [W15]
0025C8  3AFFFA     BRA NZ, 0x25BE
537:                           NVMCON = 0x4004;
0025CA  240044     MOV #0x4004, W4
0025CC  883B04     MOV W4, NVMCON
538:                           TBLPAG = __builtin_tblpage(&EEpowerUsed3H);
0025CE  2007F4     MOV #0x7F, W4
0025D0  784204     MOV.B W4, W4
0025D2  FD0200     EXCH W0, W4
0025D4  B7E032     MOV.B WREG, TBLPAG
0025D6  FD0200     EXCH W0, W4
539:                           offset = __builtin_tbloffset(&EEpowerUsed3H);
0025D8  2FE284     MOV #0xFE28, W4
0025DA  980734     MOV W4, [W14+6]
540:                           __builtin_tblwtl(offset, tempPowerH);
0025DC  90023E     MOV [W14+6], W4
0025DE  BB0A1E     TBLWTL [W14], [W4]
541:                           asm volatile ("disi #5");
0025E0  FC0005     DISI #0x5
542:                           __builtin_write_NVM();
0025E2  200554     MOV #0x55, W4
0025E4  883B34     MOV W4, NVMKEY
0025E6  200AA4     MOV #0xAA, W4
0025E8  883B34     MOV W4, NVMKEY
0025EA  A8E761     BSET 0x761, #7
0025EC  000000     NOP
0025EE  000000     NOP
543:                           while (_WR) continue;
0025F0  000000     NOP
0025F2  370001     BRA 0x25F6
0025F4  000000     NOP
0025F6  803B05     MOV NVMCON, W5
0025F8  280004     MOV #0x8000, W4
0025FA  628204     AND W5, W4, W4
0025FC  520FE0     SUB W4, #0x0, [W15]
0025FE  3AFFFA     BRA NZ, 0x25F4
544:                           NVMCON = 0x4004;
002600  240044     MOV #0x4004, W4
002602  883B04     MOV W4, NVMCON
545:                           TBLPAG = __builtin_tblpage(&EEpowerUsed3L);
002604  2007F4     MOV #0x7F, W4
002606  784204     MOV.B W4, W4
002608  FD0200     EXCH W0, W4
00260A  B7E032     MOV.B WREG, TBLPAG
00260C  FD0200     EXCH W0, W4
546:                           offset = __builtin_tbloffset(&EEpowerUsed3L);
00260E  2FE2A4     MOV #0xFE2A, W4
002610  980734     MOV W4, [W14+6]
547:                           __builtin_tblwtl(offset, tempPowerL);
002612  90023E     MOV [W14+6], W4
002614  90029E     MOV [W14+2], W5
002616  BB0A05     TBLWTL W5, [W4]
548:                           asm volatile ("disi #5");
002618  FC0005     DISI #0x5
549:                           __builtin_write_NVM();
00261A  200554     MOV #0x55, W4
00261C  883B34     MOV W4, NVMKEY
00261E  200AA4     MOV #0xAA, W4
002620  883B34     MOV W4, NVMKEY
002622  A8E761     BSET 0x761, #7
002624  000000     NOP
002626  000000     NOP
550:                           while (_WR) continue;
002628  000000     NOP
00262A  370001     BRA 0x262E
00262C  000000     NOP
00262E  803B05     MOV NVMCON, W5
002630  280004     MOV #0x8000, W4
002632  628204     AND W5, W4, W4
002634  520FE0     SUB W4, #0x0, [W15]
002636  3AFFFA     BRA NZ, 0x262C
551:                           NVMCON = 0x4004;
002638  240044     MOV #0x4004, W4
00263A  883B04     MOV W4, NVMCON
552:                           TBLPAG = __builtin_tblpage(&EEpowerUsed4H);
00263C  2007F4     MOV #0x7F, W4
00263E  784204     MOV.B W4, W4
002640  FD0200     EXCH W0, W4
002642  B7E032     MOV.B WREG, TBLPAG
002644  FD0200     EXCH W0, W4
553:                           offset = __builtin_tbloffset(&EEpowerUsed4H);
002646  2FE2C4     MOV #0xFE2C, W4
002648  980734     MOV W4, [W14+6]
554:                           __builtin_tblwtl(offset, 0xFFFF);
00264A  90023E     MOV [W14+6], W4
00264C  EB8280     SETM W5
00264E  BB0A05     TBLWTL W5, [W4]
555:                           asm volatile ("disi #5");
002650  FC0005     DISI #0x5
556:                           __builtin_write_NVM();
002652  200554     MOV #0x55, W4
002654  883B34     MOV W4, NVMKEY
002656  200AA4     MOV #0xAA, W4
002658  883B34     MOV W4, NVMKEY
00265A  A8E761     BSET 0x761, #7
00265C  000000     NOP
00265E  000000     NOP
557:                           break;
002660  3701A2     BRA 0x29A6
558:               
559:                       case 4:
560:                           while (_WR) continue;
002662  000000     NOP
002664  370001     BRA 0x2668
002666  000000     NOP
002668  803B05     MOV NVMCON, W5
00266A  280004     MOV #0x8000, W4
00266C  628204     AND W5, W4, W4
00266E  520FE0     SUB W4, #0x0, [W15]
002670  3AFFFA     BRA NZ, 0x2666
561:                           NVMCON = 0x4004;
002672  240044     MOV #0x4004, W4
002674  883B04     MOV W4, NVMCON
562:                           TBLPAG = __builtin_tblpage(&EEpowerUsed4H);
002676  2007F4     MOV #0x7F, W4
002678  784204     MOV.B W4, W4
00267A  FD0200     EXCH W0, W4
00267C  B7E032     MOV.B WREG, TBLPAG
00267E  FD0200     EXCH W0, W4
563:                           offset = __builtin_tbloffset(&EEpowerUsed4H);
002680  2FE2C4     MOV #0xFE2C, W4
002682  980734     MOV W4, [W14+6]
564:                           __builtin_tblwtl(offset, tempPowerH);
002684  90023E     MOV [W14+6], W4
002686  BB0A1E     TBLWTL [W14], [W4]
565:                           asm volatile ("disi #5");
002688  FC0005     DISI #0x5
566:                           __builtin_write_NVM();
00268A  200554     MOV #0x55, W4
00268C  883B34     MOV W4, NVMKEY
00268E  200AA4     MOV #0xAA, W4
002690  883B34     MOV W4, NVMKEY
002692  A8E761     BSET 0x761, #7
002694  000000     NOP
002696  000000     NOP
567:                           while (_WR) continue;
002698  000000     NOP
00269A  370001     BRA 0x269E
00269C  000000     NOP
00269E  803B05     MOV NVMCON, W5
0026A0  280004     MOV #0x8000, W4
0026A2  628204     AND W5, W4, W4
0026A4  520FE0     SUB W4, #0x0, [W15]
0026A6  3AFFFA     BRA NZ, 0x269C
568:                           NVMCON = 0x4004;
0026A8  240044     MOV #0x4004, W4
0026AA  883B04     MOV W4, NVMCON
569:                           TBLPAG = __builtin_tblpage(&EEpowerUsed4L);
0026AC  2007F4     MOV #0x7F, W4
0026AE  784204     MOV.B W4, W4
0026B0  FD0200     EXCH W0, W4
0026B2  B7E032     MOV.B WREG, TBLPAG
0026B4  FD0200     EXCH W0, W4
570:                           offset = __builtin_tbloffset(&EEpowerUsed4L);
0026B6  2FE2E4     MOV #0xFE2E, W4
0026B8  980734     MOV W4, [W14+6]
571:                           __builtin_tblwtl(offset, tempPowerL);
0026BA  90023E     MOV [W14+6], W4
0026BC  90029E     MOV [W14+2], W5
0026BE  BB0A05     TBLWTL W5, [W4]
572:                           asm volatile ("disi #5");
0026C0  FC0005     DISI #0x5
573:                           __builtin_write_NVM();
0026C2  200554     MOV #0x55, W4
0026C4  883B34     MOV W4, NVMKEY
0026C6  200AA4     MOV #0xAA, W4
0026C8  883B34     MOV W4, NVMKEY
0026CA  A8E761     BSET 0x761, #7
0026CC  000000     NOP
0026CE  000000     NOP
574:                           while (_WR) continue;
0026D0  000000     NOP
0026D2  370001     BRA 0x26D6
0026D4  000000     NOP
0026D6  803B05     MOV NVMCON, W5
0026D8  280004     MOV #0x8000, W4
0026DA  628204     AND W5, W4, W4
0026DC  520FE0     SUB W4, #0x0, [W15]
0026DE  3AFFFA     BRA NZ, 0x26D4
575:                           NVMCON = 0x4004;
0026E0  240044     MOV #0x4004, W4
0026E2  883B04     MOV W4, NVMCON
576:                           TBLPAG = __builtin_tblpage(&EEpowerUsed5H);
0026E4  2007F4     MOV #0x7F, W4
0026E6  784204     MOV.B W4, W4
0026E8  FD0200     EXCH W0, W4
0026EA  B7E032     MOV.B WREG, TBLPAG
0026EC  FD0200     EXCH W0, W4
577:                           offset = __builtin_tbloffset(&EEpowerUsed5H);
0026EE  2FE304     MOV #0xFE30, W4
0026F0  980734     MOV W4, [W14+6]
578:                           __builtin_tblwtl(offset, 0xFFFF);
0026F2  90023E     MOV [W14+6], W4
0026F4  EB8280     SETM W5
0026F6  BB0A05     TBLWTL W5, [W4]
579:                           asm volatile ("disi #5");
0026F8  FC0005     DISI #0x5
580:                           __builtin_write_NVM();
0026FA  200554     MOV #0x55, W4
0026FC  883B34     MOV W4, NVMKEY
0026FE  200AA4     MOV #0xAA, W4
002700  883B34     MOV W4, NVMKEY
002702  A8E761     BSET 0x761, #7
002704  000000     NOP
002706  000000     NOP
581:                           break;
002708  37014E     BRA 0x29A6
582:               
583:                       case 5:
584:                           while (_WR) continue;
00270A  000000     NOP
00270C  370001     BRA 0x2710
00270E  000000     NOP
002710  803B05     MOV NVMCON, W5
002712  280004     MOV #0x8000, W4
002714  628204     AND W5, W4, W4
002716  520FE0     SUB W4, #0x0, [W15]
002718  3AFFFA     BRA NZ, 0x270E
585:                           NVMCON = 0x4004;
00271A  240044     MOV #0x4004, W4
00271C  883B04     MOV W4, NVMCON
586:                           TBLPAG = __builtin_tblpage(&EEpowerUsed5H);
00271E  2007F4     MOV #0x7F, W4
002720  784204     MOV.B W4, W4
002722  FD0200     EXCH W0, W4
002724  B7E032     MOV.B WREG, TBLPAG
002726  FD0200     EXCH W0, W4
587:                           offset = __builtin_tbloffset(&EEpowerUsed5H);
002728  2FE304     MOV #0xFE30, W4
00272A  980734     MOV W4, [W14+6]
588:                           __builtin_tblwtl(offset, tempPowerH);
00272C  90023E     MOV [W14+6], W4
00272E  BB0A1E     TBLWTL [W14], [W4]
589:                           asm volatile ("disi #5");
002730  FC0005     DISI #0x5
590:                           __builtin_write_NVM();
002732  200554     MOV #0x55, W4
002734  883B34     MOV W4, NVMKEY
002736  200AA4     MOV #0xAA, W4
002738  883B34     MOV W4, NVMKEY
00273A  A8E761     BSET 0x761, #7
00273C  000000     NOP
00273E  000000     NOP
591:                           while (_WR) continue;
002740  000000     NOP
002742  370001     BRA 0x2746
002744  000000     NOP
002746  803B05     MOV NVMCON, W5
002748  280004     MOV #0x8000, W4
00274A  628204     AND W5, W4, W4
00274C  520FE0     SUB W4, #0x0, [W15]
00274E  3AFFFA     BRA NZ, 0x2744
592:                           NVMCON = 0x4004;
002750  240044     MOV #0x4004, W4
002752  883B04     MOV W4, NVMCON
593:                           TBLPAG = __builtin_tblpage(&EEpowerUsed5L);
002754  2007F4     MOV #0x7F, W4
002756  784204     MOV.B W4, W4
002758  FD0200     EXCH W0, W4
00275A  B7E032     MOV.B WREG, TBLPAG
00275C  FD0200     EXCH W0, W4
594:                           offset = __builtin_tbloffset(&EEpowerUsed5L);
00275E  2FE324     MOV #0xFE32, W4
002760  980734     MOV W4, [W14+6]
595:                           __builtin_tblwtl(offset, tempPowerL);
002762  90023E     MOV [W14+6], W4
002764  90029E     MOV [W14+2], W5
002766  BB0A05     TBLWTL W5, [W4]
596:                           asm volatile ("disi #5");
002768  FC0005     DISI #0x5
597:                           __builtin_write_NVM();
00276A  200554     MOV #0x55, W4
00276C  883B34     MOV W4, NVMKEY
00276E  200AA4     MOV #0xAA, W4
002770  883B34     MOV W4, NVMKEY
002772  A8E761     BSET 0x761, #7
002774  000000     NOP
002776  000000     NOP
598:                           while (_WR) continue;
002778  000000     NOP
00277A  370001     BRA 0x277E
00277C  000000     NOP
00277E  803B05     MOV NVMCON, W5
002780  280004     MOV #0x8000, W4
002782  628204     AND W5, W4, W4
002784  520FE0     SUB W4, #0x0, [W15]
002786  3AFFFA     BRA NZ, 0x277C
599:                           NVMCON = 0x4004;
002788  240044     MOV #0x4004, W4
00278A  883B04     MOV W4, NVMCON
600:                           TBLPAG = __builtin_tblpage(&EEpowerUsed6H);
00278C  2007F4     MOV #0x7F, W4
00278E  784204     MOV.B W4, W4
002790  FD0200     EXCH W0, W4
002792  B7E032     MOV.B WREG, TBLPAG
002794  FD0200     EXCH W0, W4
601:                           offset = __builtin_tbloffset(&EEpowerUsed6H);
002796  2FE344     MOV #0xFE34, W4
002798  980734     MOV W4, [W14+6]
602:                           __builtin_tblwtl(offset, 0xFFFF);
00279A  90023E     MOV [W14+6], W4
00279C  EB8280     SETM W5
00279E  BB0A05     TBLWTL W5, [W4]
603:                           asm volatile ("disi #5");
0027A0  FC0005     DISI #0x5
604:                           __builtin_write_NVM();
0027A2  200554     MOV #0x55, W4
0027A4  883B34     MOV W4, NVMKEY
0027A6  200AA4     MOV #0xAA, W4
0027A8  883B34     MOV W4, NVMKEY
0027AA  A8E761     BSET 0x761, #7
0027AC  000000     NOP
0027AE  000000     NOP
605:                           break;
0027B0  3700FA     BRA 0x29A6
606:               
607:                       case 6:
608:                           while (_WR) continue;
0027B2  000000     NOP
0027B4  370001     BRA 0x27B8
0027B6  000000     NOP
0027B8  803B05     MOV NVMCON, W5
0027BA  280004     MOV #0x8000, W4
0027BC  628204     AND W5, W4, W4
0027BE  520FE0     SUB W4, #0x0, [W15]
0027C0  3AFFFA     BRA NZ, 0x27B6
609:                           NVMCON = 0x4004;
0027C2  240044     MOV #0x4004, W4
0027C4  883B04     MOV W4, NVMCON
610:                           TBLPAG = __builtin_tblpage(&EEpowerUsed6H);
0027C6  2007F4     MOV #0x7F, W4
0027C8  784204     MOV.B W4, W4
0027CA  FD0200     EXCH W0, W4
0027CC  B7E032     MOV.B WREG, TBLPAG
0027CE  FD0200     EXCH W0, W4
611:                           offset = __builtin_tbloffset(&EEpowerUsed6H);
0027D0  2FE344     MOV #0xFE34, W4
0027D2  980734     MOV W4, [W14+6]
612:                           __builtin_tblwtl(offset, tempPowerH);
0027D4  90023E     MOV [W14+6], W4
0027D6  BB0A1E     TBLWTL [W14], [W4]
613:                           asm volatile ("disi #5");
0027D8  FC0005     DISI #0x5
614:                           __builtin_write_NVM();
0027DA  200554     MOV #0x55, W4
0027DC  883B34     MOV W4, NVMKEY
0027DE  200AA4     MOV #0xAA, W4
0027E0  883B34     MOV W4, NVMKEY
0027E2  A8E761     BSET 0x761, #7
0027E4  000000     NOP
0027E6  000000     NOP
615:                           while (_WR) continue;
0027E8  000000     NOP
0027EA  370001     BRA 0x27EE
0027EC  000000     NOP
0027EE  803B05     MOV NVMCON, W5
0027F0  280004     MOV #0x8000, W4
0027F2  628204     AND W5, W4, W4
0027F4  520FE0     SUB W4, #0x0, [W15]
0027F6  3AFFFA     BRA NZ, 0x27EC
616:                           NVMCON = 0x4004;
0027F8  240044     MOV #0x4004, W4
0027FA  883B04     MOV W4, NVMCON
617:                           TBLPAG = __builtin_tblpage(&EEpowerUsed6L);
0027FC  2007F4     MOV #0x7F, W4
0027FE  784204     MOV.B W4, W4
002800  FD0200     EXCH W0, W4
002802  B7E032     MOV.B WREG, TBLPAG
002804  FD0200     EXCH W0, W4
618:                           offset = __builtin_tbloffset(&EEpowerUsed6L);
002806  2FE364     MOV #0xFE36, W4
002808  980734     MOV W4, [W14+6]
619:                           __builtin_tblwtl(offset, tempPowerL);
00280A  90023E     MOV [W14+6], W4
00280C  90029E     MOV [W14+2], W5
00280E  BB0A05     TBLWTL W5, [W4]
620:                           asm volatile ("disi #5");
002810  FC0005     DISI #0x5
621:                           __builtin_write_NVM();
002812  200554     MOV #0x55, W4
002814  883B34     MOV W4, NVMKEY
002816  200AA4     MOV #0xAA, W4
002818  883B34     MOV W4, NVMKEY
00281A  A8E761     BSET 0x761, #7
00281C  000000     NOP
00281E  000000     NOP
622:                           while (_WR) continue;
002820  000000     NOP
002822  370001     BRA 0x2826
002824  000000     NOP
002826  803B05     MOV NVMCON, W5
002828  280004     MOV #0x8000, W4
00282A  628204     AND W5, W4, W4
00282C  520FE0     SUB W4, #0x0, [W15]
00282E  3AFFFA     BRA NZ, 0x2824
623:                           NVMCON = 0x4004;
002830  240044     MOV #0x4004, W4
002832  883B04     MOV W4, NVMCON
624:                           TBLPAG = __builtin_tblpage(&EEpowerUsed7H);
002834  2007F4     MOV #0x7F, W4
002836  784204     MOV.B W4, W4
002838  FD0200     EXCH W0, W4
00283A  B7E032     MOV.B WREG, TBLPAG
00283C  FD0200     EXCH W0, W4
625:                           offset = __builtin_tbloffset(&EEpowerUsed7H);
00283E  2FE384     MOV #0xFE38, W4
002840  980734     MOV W4, [W14+6]
626:                           __builtin_tblwtl(offset, 0xFFFF);
002842  90023E     MOV [W14+6], W4
002844  EB8280     SETM W5
002846  BB0A05     TBLWTL W5, [W4]
627:                           asm volatile ("disi #5");
002848  FC0005     DISI #0x5
628:                           __builtin_write_NVM();
00284A  200554     MOV #0x55, W4
00284C  883B34     MOV W4, NVMKEY
00284E  200AA4     MOV #0xAA, W4
002850  883B34     MOV W4, NVMKEY
002852  A8E761     BSET 0x761, #7
002854  000000     NOP
002856  000000     NOP
629:                           break;
002858  3700A6     BRA 0x29A6
630:               
631:                       case 7:
632:                           while (_WR) continue;
00285A  000000     NOP
00285C  370001     BRA 0x2860
00285E  000000     NOP
002860  803B05     MOV NVMCON, W5
002862  280004     MOV #0x8000, W4
002864  628204     AND W5, W4, W4
002866  520FE0     SUB W4, #0x0, [W15]
002868  3AFFFA     BRA NZ, 0x285E
633:                           NVMCON = 0x4004;
00286A  240044     MOV #0x4004, W4
00286C  883B04     MOV W4, NVMCON
634:                           TBLPAG = __builtin_tblpage(&EEpowerUsed7H);
00286E  2007F4     MOV #0x7F, W4
002870  784204     MOV.B W4, W4
002872  FD0200     EXCH W0, W4
002874  B7E032     MOV.B WREG, TBLPAG
002876  FD0200     EXCH W0, W4
635:                           offset = __builtin_tbloffset(&EEpowerUsed7H);
002878  2FE384     MOV #0xFE38, W4
00287A  980734     MOV W4, [W14+6]
636:                           __builtin_tblwtl(offset, tempPowerH);
00287C  90023E     MOV [W14+6], W4
00287E  BB0A1E     TBLWTL [W14], [W4]
637:                           asm volatile ("disi #5");
002880  FC0005     DISI #0x5
638:                           __builtin_write_NVM();
002882  200554     MOV #0x55, W4
002884  883B34     MOV W4, NVMKEY
002886  200AA4     MOV #0xAA, W4
002888  883B34     MOV W4, NVMKEY
00288A  A8E761     BSET 0x761, #7
00288C  000000     NOP
00288E  000000     NOP
639:                           while (_WR) continue;
002890  000000     NOP
002892  370001     BRA 0x2896
002894  000000     NOP
002896  803B05     MOV NVMCON, W5
002898  280004     MOV #0x8000, W4
00289A  628204     AND W5, W4, W4
00289C  520FE0     SUB W4, #0x0, [W15]
00289E  3AFFFA     BRA NZ, 0x2894
640:                           NVMCON = 0x4004;
0028A0  240044     MOV #0x4004, W4
0028A2  883B04     MOV W4, NVMCON
641:                           TBLPAG = __builtin_tblpage(&EEpowerUsed7L);
0028A4  2007F4     MOV #0x7F, W4
0028A6  784204     MOV.B W4, W4
0028A8  FD0200     EXCH W0, W4
0028AA  B7E032     MOV.B WREG, TBLPAG
0028AC  FD0200     EXCH W0, W4
642:                           offset = __builtin_tbloffset(&EEpowerUsed7L);
0028AE  2FE3A4     MOV #0xFE3A, W4
0028B0  980734     MOV W4, [W14+6]
643:                           __builtin_tblwtl(offset, tempPowerL);
0028B2  90023E     MOV [W14+6], W4
0028B4  90029E     MOV [W14+2], W5
0028B6  BB0A05     TBLWTL W5, [W4]
644:                           asm volatile ("disi #5");
0028B8  FC0005     DISI #0x5
645:                           __builtin_write_NVM();
0028BA  200554     MOV #0x55, W4
0028BC  883B34     MOV W4, NVMKEY
0028BE  200AA4     MOV #0xAA, W4
0028C0  883B34     MOV W4, NVMKEY
0028C2  A8E761     BSET 0x761, #7
0028C4  000000     NOP
0028C6  000000     NOP
646:                           while (_WR) continue;
0028C8  000000     NOP
0028CA  370001     BRA 0x28CE
0028CC  000000     NOP
0028CE  803B05     MOV NVMCON, W5
0028D0  280004     MOV #0x8000, W4
0028D2  628204     AND W5, W4, W4
0028D4  520FE0     SUB W4, #0x0, [W15]
0028D6  3AFFFA     BRA NZ, 0x28CC
647:                           NVMCON = 0x4004;
0028D8  240044     MOV #0x4004, W4
0028DA  883B04     MOV W4, NVMCON
648:                           TBLPAG = __builtin_tblpage(&EEpowerUsed8H);
0028DC  2007F4     MOV #0x7F, W4
0028DE  784204     MOV.B W4, W4
0028E0  FD0200     EXCH W0, W4
0028E2  B7E032     MOV.B WREG, TBLPAG
0028E4  FD0200     EXCH W0, W4
649:                           offset = __builtin_tbloffset(&EEpowerUsed8H);
0028E6  2FE3C4     MOV #0xFE3C, W4
0028E8  980734     MOV W4, [W14+6]
650:                           __builtin_tblwtl(offset, 0xFFFF);
0028EA  90023E     MOV [W14+6], W4
0028EC  EB8280     SETM W5
0028EE  BB0A05     TBLWTL W5, [W4]
651:                           asm volatile ("disi #5");
0028F0  FC0005     DISI #0x5
652:                           __builtin_write_NVM();
0028F2  200554     MOV #0x55, W4
0028F4  883B34     MOV W4, NVMKEY
0028F6  200AA4     MOV #0xAA, W4
0028F8  883B34     MOV W4, NVMKEY
0028FA  A8E761     BSET 0x761, #7
0028FC  000000     NOP
0028FE  000000     NOP
653:                           break;
002900  370052     BRA 0x29A6
654:               
655:                       case 8:
656:                           while (_WR) continue;
002902  000000     NOP
002904  370001     BRA 0x2908
002906  000000     NOP
002908  803B05     MOV NVMCON, W5
00290A  280004     MOV #0x8000, W4
00290C  628204     AND W5, W4, W4
00290E  520FE0     SUB W4, #0x0, [W15]
002910  3AFFFA     BRA NZ, 0x2906
657:                           NVMCON = 0x4004;
002912  240044     MOV #0x4004, W4
002914  883B04     MOV W4, NVMCON
658:                           TBLPAG = __builtin_tblpage(&EEpowerUsed8H);
002916  2007F4     MOV #0x7F, W4
002918  784204     MOV.B W4, W4
00291A  FD0200     EXCH W0, W4
00291C  B7E032     MOV.B WREG, TBLPAG
00291E  FD0200     EXCH W0, W4
659:                           offset = __builtin_tbloffset(&EEpowerUsed8H);
002920  2FE3C4     MOV #0xFE3C, W4
002922  980734     MOV W4, [W14+6]
660:                           __builtin_tblwtl(offset, tempPowerH);
002924  90023E     MOV [W14+6], W4
002926  BB0A1E     TBLWTL [W14], [W4]
661:                           asm volatile ("disi #5");
002928  FC0005     DISI #0x5
662:                           __builtin_write_NVM();
00292A  200554     MOV #0x55, W4
00292C  883B34     MOV W4, NVMKEY
00292E  200AA4     MOV #0xAA, W4
002930  883B34     MOV W4, NVMKEY
002932  A8E761     BSET 0x761, #7
002934  000000     NOP
002936  000000     NOP
663:                           while (_WR) continue;
002938  000000     NOP
00293A  370001     BRA 0x293E
00293C  000000     NOP
00293E  803B05     MOV NVMCON, W5
002940  280004     MOV #0x8000, W4
002942  628204     AND W5, W4, W4
002944  520FE0     SUB W4, #0x0, [W15]
002946  3AFFFA     BRA NZ, 0x293C
664:                           NVMCON = 0x4004;
002948  240044     MOV #0x4004, W4
00294A  883B04     MOV W4, NVMCON
665:                           TBLPAG = __builtin_tblpage(&EEpowerUsed8L);
00294C  2007F4     MOV #0x7F, W4
00294E  784204     MOV.B W4, W4
002950  FD0200     EXCH W0, W4
002952  B7E032     MOV.B WREG, TBLPAG
002954  FD0200     EXCH W0, W4
666:                           offset = __builtin_tbloffset(&EEpowerUsed8L);
002956  2FE3E4     MOV #0xFE3E, W4
002958  980734     MOV W4, [W14+6]
667:                           __builtin_tblwtl(offset, tempPowerL);
00295A  90023E     MOV [W14+6], W4
00295C  90029E     MOV [W14+2], W5
00295E  BB0A05     TBLWTL W5, [W4]
668:                           asm volatile ("disi #5");
002960  FC0005     DISI #0x5
669:                           __builtin_write_NVM();
002962  200554     MOV #0x55, W4
002964  883B34     MOV W4, NVMKEY
002966  200AA4     MOV #0xAA, W4
002968  883B34     MOV W4, NVMKEY
00296A  A8E761     BSET 0x761, #7
00296C  000000     NOP
00296E  000000     NOP
670:                           while (_WR) continue;
002970  000000     NOP
002972  370001     BRA 0x2976
002974  000000     NOP
002976  803B05     MOV NVMCON, W5
002978  280004     MOV #0x8000, W4
00297A  628204     AND W5, W4, W4
00297C  520FE0     SUB W4, #0x0, [W15]
00297E  3AFFFA     BRA NZ, 0x2974
671:                           NVMCON = 0x4004;
002980  240044     MOV #0x4004, W4
002982  883B04     MOV W4, NVMCON
672:                           TBLPAG = __builtin_tblpage(&EEpowerUsed1H);
002984  2007F4     MOV #0x7F, W4
002986  784204     MOV.B W4, W4
002988  780004     MOV W4, W0
00298A  B7E032     MOV.B WREG, TBLPAG
673:                           offset = __builtin_tbloffset(&EEpowerUsed1H);
00298C  2FE204     MOV #0xFE20, W4
00298E  980734     MOV W4, [W14+6]
674:                           __builtin_tblwtl(offset, 0xFFFF);
002990  90023E     MOV [W14+6], W4
002992  EB8280     SETM W5
002994  BB0A05     TBLWTL W5, [W4]
675:                           asm volatile ("disi #5");
002996  FC0005     DISI #0x5
676:                           __builtin_write_NVM();
002998  200554     MOV #0x55, W4
00299A  883B34     MOV W4, NVMKEY
00299C  200AA4     MOV #0xAA, W4
00299E  883B34     MOV W4, NVMKEY
0029A0  A8E761     BSET 0x761, #7
0029A2  000000     NOP
0029A4  000000     NOP
677:                   }
678:               }
0029A6  FA8000     ULNK
679:               
680:               void EEreadHL() {
0029AA  FA0002     LNK #0x2
681:                   while (_WR) continue;
0029AC  000000     NOP
0029AE  370001     BRA 0x29B2
0029B0  000000     NOP
0029B2  803B05     MOV NVMCON, W5
0029B4  280004     MOV #0x8000, W4
0029B6  628204     AND W5, W4, W4
0029B8  520FE0     SUB W4, #0x0, [W15]
0029BA  3AFFFA     BRA NZ, 0x29B0
682:               
683:                   TBLPAG = __builtin_tblpage(&EEhighLow);
0029BC  2007F4     MOV #0x7F, W4
0029BE  784204     MOV.B W4, W4
0029C0  780004     MOV W4, W0
0029C2  B7E032     MOV.B WREG, TBLPAG
684:                   unsigned int offset = __builtin_tbloffset(&EEhighLow);
0029C4  2FE404     MOV #0xFE40, W4
0029C6  780F04     MOV W4, [W14]
685:                   isHigh = (char) __builtin_tblrdl(offset);
0029C8  78021E     MOV [W14], W4
0029CA  BA0214     TBLRDL [W4], W4
0029CC  784204     MOV.B W4, W4
0029CE  780004     MOV W4, W0
0029D0  B7E80E     MOV.B WREG, isHigh
686:               }
0029D2  FA8000     ULNK
687:               
688:               void EEwriteHL() {
0029D6  FA0002     LNK #0x2
689:                   while (_WR) continue;
0029D8  000000     NOP
0029DA  370001     BRA 0x29DE
0029DC  000000     NOP
0029DE  803B05     MOV NVMCON, W5
0029E0  280004     MOV #0x8000, W4
0029E2  628204     AND W5, W4, W4
0029E4  520FE0     SUB W4, #0x0, [W15]
0029E6  3AFFFA     BRA NZ, 0x29DC
690:                   NVMCON = 0x4004;
0029E8  240044     MOV #0x4004, W4
0029EA  883B04     MOV W4, NVMCON
691:               
692:                   TBLPAG = __builtin_tblpage(&EEhighLow);
0029EC  2007F4     MOV #0x7F, W4
0029EE  784204     MOV.B W4, W4
0029F0  780004     MOV W4, W0
0029F2  B7E032     MOV.B WREG, TBLPAG
693:                   unsigned int offset = __builtin_tbloffset(&EEhighLow);
0029F4  2FE404     MOV #0xFE40, W4
0029F6  780F04     MOV W4, [W14]
694:                   __builtin_tblwtl(offset, isHigh);
0029F8  2080E4     MOV #0x80E, W4
0029FA  784214     MOV.B [W4], W4
0029FC  FB0284     SE W4, W5
0029FE  78021E     MOV [W14], W4
002A00  BB0A05     TBLWTL W5, [W4]
695:               
696:                   asm volatile ("disi #5");
002A02  FC0005     DISI #0x5
697:                   __builtin_write_NVM();
002A04  200554     MOV #0x55, W4
002A06  883B34     MOV W4, NVMKEY
002A08  200AA4     MOV #0xAA, W4
002A0A  883B34     MOV W4, NVMKEY
002A0C  A8E761     BSET 0x761, #7
002A0E  000000     NOP
002A10  000000     NOP
698:               }
002A12  FA8000     ULNK
699:               
700:               void EEreadRelay() {
002A16  FA0002     LNK #0x2
701:                   while (_WR) continue;
002A18  000000     NOP
002A1A  370001     BRA 0x2A1E
002A1C  000000     NOP
002A1E  803B05     MOV NVMCON, W5
002A20  280004     MOV #0x8000, W4
002A22  628204     AND W5, W4, W4
002A24  520FE0     SUB W4, #0x0, [W15]
002A26  3AFFFA     BRA NZ, 0x2A1C
702:               
703:                   TBLPAG = __builtin_tblpage(&EErelay);
002A28  2007F4     MOV #0x7F, W4
002A2A  784204     MOV.B W4, W4
002A2C  780004     MOV W4, W0
002A2E  B7E032     MOV.B WREG, TBLPAG
704:                   unsigned int offset = __builtin_tbloffset(&EErelay);
002A30  2FE424     MOV #0xFE42, W4
002A32  780F04     MOV W4, [W14]
705:                   relayActive = (char) __builtin_tblrdl(offset);
002A34  78021E     MOV [W14], W4
002A36  BA0214     TBLRDL [W4], W4
002A38  784204     MOV.B W4, W4
002A3A  780004     MOV W4, W0
002A3C  B7E80F     MOV.B WREG, relayActive
706:               }
002A3E  FA8000     ULNK
707:               
708:               void EEwriteRelay() {
002A42  FA0002     LNK #0x2
709:                   while (_WR) continue;
002A44  000000     NOP
002A46  370001     BRA 0x2A4A
002A48  000000     NOP
002A4A  803B05     MOV NVMCON, W5
002A4C  280004     MOV #0x8000, W4
002A4E  628204     AND W5, W4, W4
002A50  520FE0     SUB W4, #0x0, [W15]
002A52  3AFFFA     BRA NZ, 0x2A48
710:                   NVMCON = 0x4004;
002A54  240044     MOV #0x4004, W4
002A56  883B04     MOV W4, NVMCON
711:               
712:                   TBLPAG = __builtin_tblpage(&EErelay);
002A58  2007F4     MOV #0x7F, W4
002A5A  784204     MOV.B W4, W4
002A5C  780004     MOV W4, W0
002A5E  B7E032     MOV.B WREG, TBLPAG
713:                   unsigned int offset = __builtin_tbloffset(&EErelay);
002A60  2FE424     MOV #0xFE42, W4
002A62  780F04     MOV W4, [W14]
714:                   __builtin_tblwtl(offset, relayActive);
002A64  2080F4     MOV #0x80F, W4
002A66  784214     MOV.B [W4], W4
002A68  FB0284     SE W4, W5
002A6A  78021E     MOV [W14], W4
002A6C  BB0A05     TBLWTL W5, [W4]
715:               
716:                   asm volatile ("disi #5");
002A6E  FC0005     DISI #0x5
717:                   __builtin_write_NVM();
002A70  200554     MOV #0x55, W4
002A72  883B34     MOV W4, NVMKEY
002A74  200AA4     MOV #0xAA, W4
002A76  883B34     MOV W4, NVMKEY
002A78  A8E761     BSET 0x761, #7
002A7A  000000     NOP
002A7C  000000     NOP
718:               }
002A7E  FA8000     ULNK
719:               
720:               unsigned char findPowerToRead() {
002A82  FA0014     LNK #0x14
721:               
722:                   unsigned int tempPower;
723:                   unsigned char EEpowerSelect;
724:               
725:                   TBLPAG = __builtin_tblpage(&EEpowerUsed1H);
002A84  2007F4     MOV #0x7F, W4
002A86  784204     MOV.B W4, W4
002A88  FD0200     EXCH W0, W4
002A8A  B7E032     MOV.B WREG, TBLPAG
002A8C  FD0200     EXCH W0, W4
726:                   unsigned int offset = __builtin_tbloffset(&EEpowerUsed1H);
002A8E  2FE204     MOV #0xFE20, W4
002A90  980714     MOV W4, [W14+2]
727:                   tempPower = __builtin_tblrdl(offset);
002A92  90021E     MOV [W14+2], W4
002A94  BA0214     TBLRDL [W4], W4
002A96  980724     MOV W4, [W14+4]
728:               
729:                   if (tempPower == 0xFFFF) {
002A98  90022E     MOV [W14+4], W4
002A9A  420FE1     ADD W4, #0x1, [W15]
002A9C  3A0003     BRA NZ, 0x2AA4
730:                       EEpowerSelect = 8;
002A9E  B3C084     MOV.B #0x8, W4
002AA0  784F04     MOV.B W4, [W14]
002AA2  370072     BRA 0x2B88
731:                   } else {
732:                       TBLPAG = __builtin_tblpage(&EEpowerUsed2H);
002AA4  2007F4     MOV #0x7F, W4
002AA6  784204     MOV.B W4, W4
002AA8  FD0200     EXCH W0, W4
002AAA  B7E032     MOV.B WREG, TBLPAG
002AAC  FD0200     EXCH W0, W4
733:                       unsigned int offset = __builtin_tbloffset(&EEpowerUsed2H);
002AAE  2FE244     MOV #0xFE24, W4
002AB0  980734     MOV W4, [W14+6]
734:                       tempPower = __builtin_tblrdl(offset);
002AB2  90023E     MOV [W14+6], W4
002AB4  BA0214     TBLRDL [W4], W4
002AB6  980724     MOV W4, [W14+4]
735:               
736:                       if (tempPower == 0xFFFF) {
002AB8  90022E     MOV [W14+4], W4
002ABA  420FE1     ADD W4, #0x1, [W15]
002ABC  3A0003     BRA NZ, 0x2AC4
737:                           EEpowerSelect = 1;
002ABE  B3C014     MOV.B #0x1, W4
002AC0  784F04     MOV.B W4, [W14]
002AC2  370062     BRA 0x2B88
738:                       } else {
739:                           TBLPAG = __builtin_tblpage(&EEpowerUsed3H);
002AC4  2007F4     MOV #0x7F, W4
002AC6  784204     MOV.B W4, W4
002AC8  FD0200     EXCH W0, W4
002ACA  B7E032     MOV.B WREG, TBLPAG
002ACC  FD0200     EXCH W0, W4
740:                           unsigned int offset = __builtin_tbloffset(&EEpowerUsed3H);
002ACE  2FE284     MOV #0xFE28, W4
002AD0  980744     MOV W4, [W14+8]
741:                           tempPower = __builtin_tblrdl(offset);
002AD2  90024E     MOV [W14+8], W4
002AD4  BA0214     TBLRDL [W4], W4
002AD6  980724     MOV W4, [W14+4]
742:               
743:                           if (tempPower == 0xFFFF) {
002AD8  90022E     MOV [W14+4], W4
002ADA  420FE1     ADD W4, #0x1, [W15]
002ADC  3A0003     BRA NZ, 0x2AE4
744:                               EEpowerSelect = 2;
002ADE  B3C024     MOV.B #0x2, W4
002AE0  784F04     MOV.B W4, [W14]
002AE2  370052     BRA 0x2B88
745:                           } else {
746:                               TBLPAG = __builtin_tblpage(&EEpowerUsed4H);
002AE4  2007F4     MOV #0x7F, W4
002AE6  784204     MOV.B W4, W4
002AE8  FD0200     EXCH W0, W4
002AEA  B7E032     MOV.B WREG, TBLPAG
002AEC  FD0200     EXCH W0, W4
747:                               unsigned int offset = __builtin_tbloffset(&EEpowerUsed4H);
002AEE  2FE2C4     MOV #0xFE2C, W4
002AF0  980754     MOV W4, [W14+10]
748:                               tempPower = __builtin_tblrdl(offset);
002AF2  90025E     MOV [W14+10], W4
002AF4  BA0214     TBLRDL [W4], W4
002AF6  980724     MOV W4, [W14+4]
749:               
750:                               if (tempPower == 0xFFFF) {
002AF8  90022E     MOV [W14+4], W4
002AFA  420FE1     ADD W4, #0x1, [W15]
002AFC  3A0003     BRA NZ, 0x2B04
751:                                   EEpowerSelect = 3;
002AFE  B3C034     MOV.B #0x3, W4
002B00  784F04     MOV.B W4, [W14]
002B02  370042     BRA 0x2B88
752:                               } else {
753:                                   TBLPAG = __builtin_tblpage(&EEpowerUsed5H);
002B04  2007F4     MOV #0x7F, W4
002B06  784204     MOV.B W4, W4
002B08  FD0200     EXCH W0, W4
002B0A  B7E032     MOV.B WREG, TBLPAG
002B0C  FD0200     EXCH W0, W4
754:                                   unsigned int offset = __builtin_tbloffset(&EEpowerUsed5H);
002B0E  2FE304     MOV #0xFE30, W4
002B10  980764     MOV W4, [W14+12]
755:                                   tempPower = __builtin_tblrdl(offset);
002B12  90026E     MOV [W14+12], W4
002B14  BA0214     TBLRDL [W4], W4
002B16  980724     MOV W4, [W14+4]
756:               
757:                                   if (tempPower == 0xFFFF) {
002B18  90022E     MOV [W14+4], W4
002B1A  420FE1     ADD W4, #0x1, [W15]
002B1C  3A0003     BRA NZ, 0x2B24
758:                                       EEpowerSelect = 4;
002B1E  B3C044     MOV.B #0x4, W4
002B20  784F04     MOV.B W4, [W14]
002B22  370032     BRA 0x2B88
759:                                   } else {
760:                                       TBLPAG = __builtin_tblpage(&EEpowerUsed6H);
002B24  2007F4     MOV #0x7F, W4
002B26  784204     MOV.B W4, W4
002B28  FD0200     EXCH W0, W4
002B2A  B7E032     MOV.B WREG, TBLPAG
002B2C  FD0200     EXCH W0, W4
761:                                       unsigned int offset = __builtin_tbloffset(&EEpowerUsed6H);
002B2E  2FE344     MOV #0xFE34, W4
002B30  980774     MOV W4, [W14+14]
762:                                       tempPower = __builtin_tblrdl(offset);
002B32  90027E     MOV [W14+14], W4
002B34  BA0214     TBLRDL [W4], W4
002B36  980724     MOV W4, [W14+4]
763:               
764:                                       if (tempPower == 0xFFFF) {
002B38  90022E     MOV [W14+4], W4
002B3A  420FE1     ADD W4, #0x1, [W15]
002B3C  3A0003     BRA NZ, 0x2B44
765:                                           EEpowerSelect = 5;
002B3E  B3C054     MOV.B #0x5, W4
002B40  784F04     MOV.B W4, [W14]
002B42  370022     BRA 0x2B88
766:                                       } else {
767:                                           TBLPAG = __builtin_tblpage(&EEpowerUsed7H);
002B44  2007F4     MOV #0x7F, W4
002B46  784204     MOV.B W4, W4
002B48  FD0200     EXCH W0, W4
002B4A  B7E032     MOV.B WREG, TBLPAG
002B4C  FD0200     EXCH W0, W4
768:                                           unsigned int offset = __builtin_tbloffset(&EEpowerUsed7H);
002B4E  2FE384     MOV #0xFE38, W4
002B50  980F04     MOV W4, [W14+16]
769:                                           tempPower = __builtin_tblrdl(offset);
002B52  900A0E     MOV [W14+16], W4
002B54  BA0214     TBLRDL [W4], W4
002B56  980724     MOV W4, [W14+4]
770:               
771:                                           if (tempPower == 0xFFFF) {
002B58  90022E     MOV [W14+4], W4
002B5A  420FE1     ADD W4, #0x1, [W15]
002B5C  3A0003     BRA NZ, 0x2B64
772:                                               EEpowerSelect = 6;
002B5E  B3C064     MOV.B #0x6, W4
002B60  784F04     MOV.B W4, [W14]
002B62  370012     BRA 0x2B88
773:                                           } else {
774:                                               TBLPAG = __builtin_tblpage(&EEpowerUsed8H);
002B64  2007F4     MOV #0x7F, W4
002B66  784204     MOV.B W4, W4
002B68  FD0200     EXCH W0, W4
002B6A  B7E032     MOV.B WREG, TBLPAG
002B6C  FD0200     EXCH W0, W4
775:                                               unsigned int offset = __builtin_tbloffset(&EEpowerUsed8H);
002B6E  2FE3C4     MOV #0xFE3C, W4
002B70  980F14     MOV W4, [W14+18]
776:                                               tempPower = __builtin_tblrdl(offset);
002B72  900A1E     MOV [W14+18], W4
002B74  BA0214     TBLRDL [W4], W4
002B76  980724     MOV W4, [W14+4]
777:               
778:                                               if (tempPower == 0xFFFF) {
002B78  90022E     MOV [W14+4], W4
002B7A  420FE1     ADD W4, #0x1, [W15]
002B7C  3A0003     BRA NZ, 0x2B84
779:                                                   EEpowerSelect = 7;
002B7E  B3C074     MOV.B #0x7, W4
002B80  784F04     MOV.B W4, [W14]
002B82  370002     BRA 0x2B88
780:                                               } else {
781:                                                   EEpowerSelect = 0;
002B84  EB4200     CLR.B W4
002B86  784F04     MOV.B W4, [W14]
782:                                               }
783:                                           }
784:                                       }
785:                                   }
786:                               }
787:                           }
788:                       }
789:                   }
790:               
791:                   return EEpowerSelect;
002B88  78421E     MOV.B [W14], W4
792:               }
002B8A  784004     MOV.B W4, W0
793:               
794:               unsigned char findPowerToWrite() {
002B90  FA0002     LNK #0x2
795:                   unsigned char temp = findPowerToRead();
002B92  07FF77     RCALL findPowerToRead
002B94  784200     MOV.B W0, W4
002B96  784F04     MOV.B W4, [W14]
796:                   temp = (temp % 8) + 1;
002B98  78429E     MOV.B [W14], W5
002B9A  62C267     AND.B W5, #0x7, W4
002B9C  E84F04     INC.B W4, [W14]
797:                   return temp;
002B9E  78421E     MOV.B [W14], W4
798:               }
002BA0  784004     MOV.B W4, W0
---  D:/My_Documents/Tom/MessiahCollaboratory/EMMS/2016-12-29_all_code/Code/BF/BFPowerPIC-WORKING.X/Delays.c
1:                 /* File:    Delays.c
2:                  * Authors: Dan Baker
3:                  *          Nathan Chaney
4:                  */
5:                 
6:                 /* Includes *******************************************************************/
7:                 #include "ExternSharedDefinitions.h"
8:                 
9:                 
10:                
11:                /* Functions ******************************************************************/
12:                
13:                /* delayFourUS
14:                 * delays for approximately four microseconds per input
15:                 * parameter a: delays for a * 4 microseconds
16:                 */
17:                void delayFourUS(unsigned int a) {
0034D8  FA0004     LNK #0x4
0034DA  980710     MOV W0, [W14+2]
18:                    unsigned int i;
19:                
20:                    for (i = 0; i < a; i++);
0034DC  EB0200     CLR W4
0034DE  780F04     MOV W4, [W14]
0034E0  370001     BRA 0x34E4
0034E2  E80F1E     INC [W14], [W14]
0034E4  90021E     MOV [W14+2], W4
0034E6  78029E     MOV [W14], W5
0034E8  528F84     SUB W5, W4, [W15]
0034EA  39FFFB     BRA NC, 0x34E2
21:                }
0034EC  FA8000     ULNK
22:                
23:                /* delayMS
24:                 * delays for approximately one millisecond per input
25:                 * paramter a: delays for a milliseconds
26:                 */
27:                void delayMS(unsigned int a) {
0034F0  FA0006     LNK #0x6
0034F2  980720     MOV W0, [W14+4]
28:                    unsigned int i, j;
29:                
30:                    for (i = 0; i < a; i++)
0034F4  EB0200     CLR W4
0034F6  780F04     MOV W4, [W14]
0034F8  37000B     BRA 0x3510
00350E  E80F1E     INC [W14], [W14]
003510  90022E     MOV [W14+4], W4
003512  78029E     MOV [W14], W5
003514  528F84     SUB W5, W4, [W15]
003516  39FFF1     BRA NC, 0x34FA
31:                        for (j = 0; j < 250; j++); // delay for 1ms
0034FA  EB0200     CLR W4
0034FC  980714     MOV W4, [W14+2]
0034FE  370003     BRA 0x3506
003500  90021E     MOV [W14+2], W4
003502  E80204     INC W4, W4
003504  980714     MOV W4, [W14+2]
003506  90029E     MOV [W14+2], W5
003508  200F94     MOV #0xF9, W4
00350A  528F84     SUB W5, W4, [W15]
00350C  36FFF9     BRA LEU, 0x3500
32:                }
003518  FA8000     ULNK
33:                
34:                void commDelay(unsigned int a) {
00351C  FA0004     LNK #0x4
00351E  980710     MOV W0, [W14+2]
35:                    unsigned int i;
36:                
37:                    for(i = 0; i < a; i++)
003520  EB0200     CLR W4
003522  780F04     MOV W4, [W14]
003524  370002     BRA 0x352A
003528  E80F1E     INC [W14], [W14]
00352A  90021E     MOV [W14+2], W4
00352C  78029E     MOV [W14], W5
00352E  528F84     SUB W5, W4, [W15]
003530  39FFFA     BRA NC, 0x3526
38:                        commFunctions();
003526  07E7BE     RCALL commFunctions
39:                }
003532  FA8000     ULNK
